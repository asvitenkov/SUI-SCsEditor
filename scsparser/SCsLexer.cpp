/** \file
 *  This C++ source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g
 *     -                            On : 2013-03-10 07:25:11
 *     -                 for the lexer : SCsLexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SCsLexer.hpp"
/* ----------------------------------------- */



	namespace  SCsParserNS  {


/** String literals used by SCsLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR_UCHAR	lit_1[]  = { 0x73, 0x63, 0x5F, 0x61, 0x72, 0x63, 0x5F, 0x6D, 0x61, 0x69, 0x6E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_2[]  = { 0x73, 0x63, 0x5F, 0x61, 0x72, 0x63, 0x5F, 0x63, 0x6F, 0x6D, 0x6D, 0x6F, 0x6E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_3[]  = { 0x73, 0x63, 0x5F, 0x6C, 0x69, 0x6E, 0x6B,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_4[]  = { 0x73, 0x63, 0x5F, 0x6E, 0x6F, 0x64, 0x65,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_5[]  = { 0x73, 0x63, 0x5F, 0x65, 0x64, 0x67, 0x65,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_6[]  = { 0x73, 0x63, 0x5F, 0x61, 0x72, 0x63, 0x5F, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_7[]  = { 0x3B, 0x3B,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_8[]  = { 0x2A, 0x2A, 0x2A, 0x2A,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_9[]  = { 0x28, 0x2A,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_10[]  = { 0x2A, 0x29,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_11[]  = { 0x3C, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_12[]  = { 0x2E, 0x2E, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_13[]  = { 0x3C, 0x2E, 0x2E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_14[]  = { 0x2D, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_15[]  = { 0x3C, 0x2D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_16[]  = { 0x3C, 0x3D, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_17[]  = { 0x5F, 0x3C, 0x3D, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_18[]  = { 0x3D, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_19[]  = { 0x3C, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_20[]  = { 0x5F, 0x3D, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_21[]  = { 0x5F, 0x3C, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_22[]  = { 0x5F, 0x2D, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_23[]  = { 0x5F, 0x3C, 0x2D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_24[]  = { 0x2D, 0x7C, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_25[]  = { 0x3C, 0x7C, 0x2D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_26[]  = { 0x5F, 0x2D, 0x7C, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_27[]  = { 0x5F, 0x3C, 0x7C, 0x2D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_28[]  = { 0x2D, 0x2F, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_29[]  = { 0x3C, 0x2F, 0x2D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_30[]  = { 0x5F, 0x2D, 0x2F, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_31[]  = { 0x5F, 0x3C, 0x2F, 0x2D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_32[]  = { 0x7E, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_33[]  = { 0x3C, 0x7E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_34[]  = { 0x5F, 0x7E, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_35[]  = { 0x5F, 0x3C, 0x7E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_36[]  = { 0x7E, 0x7C, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_37[]  = { 0x3C, 0x7C, 0x7E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_38[]  = { 0x5F, 0x7E, 0x7C, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_39[]  = { 0x5F, 0x3C, 0x7C, 0x7E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_40[]  = { 0x7E, 0x2F, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_41[]  = { 0x3C, 0x2F, 0x7E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_42[]  = { 0x5F, 0x7E, 0x2F, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_43[]  = { 0x5F, 0x3C, 0x2F, 0x7E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_44[]  = { 0x2F, 0x2F,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_45[]  = { 0x2F, 0x21, 0x2A,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_46[]  = { 0x2A, 0x2F,  antlr3::ANTLR_STRING_TERMINATOR};

	}



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

using namespace antlr3;

	namespace  SCsParserNS  {


/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



SCsLexer::~SCsLexer()
{
}

void
SCsLexer::reset()
{
    this->get_rec()->reset();
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* SCsLexer::getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called SCsLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return
 *     - Success pSCsLexer initialized for the lex start
 *     - Fail NULL
 */
SCsLexer::SCsLexer(StreamType* instream)
:SCsLexerImplTraits::BaseLexerType(ANTLR_SIZE_HINT, instream, NULL)
{
	// See if we can create a new lexer with the standard constructor
	//
	this->init(instream );
}

/** \brief Create a new lexer called SCsLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return
 *     - Success pSCsLexer initialized for the lex start
 *     - Fail NULL
 */
SCsLexer::SCsLexer(StreamType* instream, RecognizerSharedStateType* state)
:SCsLexerImplTraits::BaseLexerType(ANTLR_SIZE_HINT, instream, state)
{
	this->init(instream );
}

void SCsLexer::init(StreamType* instream)
{
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in SCsLexer.h here so you can get a sense
     * of what goes where.
     */

}

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 35:7: ( '/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__27
 *
 * Looks to match the characters the constitute the token T__27
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mT__27()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__27;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:35:7: ( '/' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:35:9: '/'
    {
         this->matchc('/');
        if  (this->hasException())
        {
            goto ruleT__27Ex;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__27Ex; /* Prevent compiler warnings */
    ruleT__27Ex: ;

}
// $ANTLR end T__27

//   Comes from: 138:2: ( '[' ( options {greedy=false; } : . )* ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CONTENT
 *
 * Looks to match the characters the constitute the token CONTENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mCONTENT()
{
    ANTLR_UINT32	_type;
      


    _type	    = CONTENT;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:138:2: ( '[' ( options {greedy=false; } : . )* ']' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:138:4: '[' ( options {greedy=false; } : . )* ']'
    {
         this->matchc('[');
        if  (this->hasException())
        {
            goto ruleCONTENTEx;
        }


        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:138:8: ( options {greedy=false; } : . )*

        for (;;)
        {
            int alt1=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA1_0 = this->LA(1);
                if ( (LA1_0 == ']'))
                {
                    alt1=2;
                }
                else if ( (((LA1_0 >= 0x0000) && (LA1_0 <= '\\')) || ((LA1_0 >= '^') && (LA1_0 <= 0xFFFF))))
                {
                    alt1=1;
                }

            }
            switch (alt1)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:138:36: .
        	    {
        	        this->matchAny();
        	        if  (this->hasException())
        	        {
        	            goto ruleCONTENTEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop1;	/* break out of the loop */
        	    break;
            }
        }
        loop1: ; /* Jump out to here if this rule does not match */


         this->matchc(']');
        if  (this->hasException())
        {
            goto ruleCONTENTEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCONTENTEx; /* Prevent compiler warnings */
    ruleCONTENTEx: ;

}
// $ANTLR end CONTENT

//   Comes from: 142:5: ( 'sc_arc_main' | 'sc_arc_common' | 'sc_link' | 'sc_node' | 'sc_edge' | 'sc_arc_access' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ELEMTYPE
 *
 * Looks to match the characters the constitute the token ELEMTYPE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mELEMTYPE()
{
    ANTLR_UINT32	_type;
      


    _type	    = ELEMTYPE;


    {
        //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:142:5: ( 'sc_arc_main' | 'sc_arc_common' | 'sc_link' | 'sc_node' | 'sc_edge' | 'sc_arc_access' )

        ANTLR_UINT32 alt2;

        alt2=6;

        switch ( this->LA(1) )
        {
        case 's':
        	{
        		switch ( this->LA(2) )
        		{
        		case 'c':
        			{
        				switch ( this->LA(3) )
        				{
        				case '_':
        					{
        						switch ( this->LA(4) )
        						{
        						case 'a':
        							{
        								switch ( this->LA(5) )
        								{
        								case 'r':
        									{
        										switch ( this->LA(6) )
        										{
        										case 'c':
        											{
        												switch ( this->LA(7) )
        												{
        												case '_':
        													{
        														switch ( this->LA(8) )
        														{
        														case 'm':
        															{
        																alt2=1;
        															}
        														    break;
        														case 'c':
        															{
        																alt2=2;
        															}
        														    break;
        														case 'a':
        															{
        																alt2=6;
        															}
        														    break;

        														default:
        														    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        														    ex->set_decisionNum( 2 );
        														    ex->set_state( 10 );


        														    goto ruleELEMTYPEEx;

        														}

        													}
        												    break;

        												default:
        												    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        												    ex->set_decisionNum( 2 );
        												    ex->set_state( 9 );


        												    goto ruleELEMTYPEEx;

        												}

        											}
        										    break;

        										default:
        										    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        										    ex->set_decisionNum( 2 );
        										    ex->set_state( 8 );


        										    goto ruleELEMTYPEEx;

        										}

        									}
        								    break;

        								default:
        								    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        								    ex->set_decisionNum( 2 );
        								    ex->set_state( 4 );


        								    goto ruleELEMTYPEEx;

        								}

        							}
        						    break;
        						case 'l':
        							{
        								alt2=3;
        							}
        						    break;
        						case 'n':
        							{
        								alt2=4;
        							}
        						    break;
        						case 'e':
        							{
        								alt2=5;
        							}
        						    break;

        						default:
        						    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        						    ex->set_decisionNum( 2 );
        						    ex->set_state( 3 );


        						    goto ruleELEMTYPEEx;

        						}

        					}
        				    break;

        				default:
        				    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        				    ex->set_decisionNum( 2 );
        				    ex->set_state( 2 );


        				    goto ruleELEMTYPEEx;

        				}

        			}
        		    break;

        		default:
        		    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        		    ex->set_decisionNum( 2 );
        		    ex->set_state( 1 );


        		    goto ruleELEMTYPEEx;

        		}

        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 2 );
            ex->set_state( 0 );


            goto ruleELEMTYPEEx;

        }

        switch (alt2)
        {
    	case 1:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:142:7: 'sc_arc_main'
    	    {
    	        this->matchs(lit_1);
    	        if  (this->hasException())
    	        {
    	            goto ruleELEMTYPEEx;
    	        }




    	    }
    	    break;
    	case 2:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:143:7: 'sc_arc_common'
    	    {
    	        this->matchs(lit_2);
    	        if  (this->hasException())
    	        {
    	            goto ruleELEMTYPEEx;
    	        }




    	    }
    	    break;
    	case 3:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:144:7: 'sc_link'
    	    {
    	        this->matchs(lit_3);
    	        if  (this->hasException())
    	        {
    	            goto ruleELEMTYPEEx;
    	        }




    	    }
    	    break;
    	case 4:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:145:7: 'sc_node'
    	    {
    	        this->matchs(lit_4);
    	        if  (this->hasException())
    	        {
    	            goto ruleELEMTYPEEx;
    	        }




    	    }
    	    break;
    	case 5:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:146:7: 'sc_edge'
    	    {
    	        this->matchs(lit_5);
    	        if  (this->hasException())
    	        {
    	            goto ruleELEMTYPEEx;
    	        }




    	    }
    	    break;
    	case 6:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:147:7: 'sc_arc_access'
    	    {
    	        this->matchs(lit_6);
    	        if  (this->hasException())
    	        {
    	            goto ruleELEMTYPEEx;
    	        }




    	    }
    	    break;

        }
    }
	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleELEMTYPEEx; /* Prevent compiler warnings */
    ruleELEMTYPEEx: ;

}
// $ANTLR end ELEMTYPE

//   Comes from: 150:5: ( '\"' (~ ( '\"' ) )* '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start URL
 *
 * Looks to match the characters the constitute the token URL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mURL()
{
    ANTLR_UINT32	_type;
      


    _type	    = URL;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:150:5: ( '\"' (~ ( '\"' ) )* '\"' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:151:3: '\"' (~ ( '\"' ) )* '\"'
    {
         this->matchc('"');
        if  (this->hasException())
        {
            goto ruleURLEx;
        }


        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:151:7: (~ ( '\"' ) )*

        for (;;)
        {
            int alt3=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA3_0 = this->LA(1);
                if ( (((LA3_0 >= 0x0000) && (LA3_0 <= '!')) || ((LA3_0 >= '#') && (LA3_0 <= 0xFFFF))))
                {
                    alt3=1;
                }

            }
            switch (alt3)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:
        	    {
        	        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '!')) || ((this->LA(1) >= '#') && (this->LA(1) <= 0xFFFF)) )
        	        {
        	            this->consume();
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< SCsLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            this->recover();
        	            goto ruleURLEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop3;	/* break out of the loop */
        	    break;
            }
        }
        loop3: ; /* Jump out to here if this rule does not match */


         this->matchc('"');
        if  (this->hasException())
        {
            goto ruleURLEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleURLEx; /* Prevent compiler warnings */
    ruleURLEx: ;

}
// $ANTLR end URL

//   Comes from: 156:5: ( '|' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TRIPLESEP
 *
 * Looks to match the characters the constitute the token TRIPLESEP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mTRIPLESEP()
{
    ANTLR_UINT32	_type;
      


    _type	    = TRIPLESEP;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:156:5: ( '|' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:156:7: '|'
    {
         this->matchc('|');
        if  (this->hasException())
        {
            goto ruleTRIPLESEPEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleTRIPLESEPEx; /* Prevent compiler warnings */
    ruleTRIPLESEPEx: ;

}
// $ANTLR end TRIPLESEP

//   Comes from: 160:5: ( ':' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ATTRSEP
 *
 * Looks to match the characters the constitute the token ATTRSEP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mATTRSEP()
{
    ANTLR_UINT32	_type;
      


    _type	    = ATTRSEP;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:160:5: ( ':' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:160:7: ':'
    {
         this->matchc(':');
        if  (this->hasException())
        {
            goto ruleATTRSEPEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleATTRSEPEx; /* Prevent compiler warnings */
    ruleATTRSEPEx: ;

}
// $ANTLR end ATTRSEP

//   Comes from: 164:5: ( ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OBJSEP
 *
 * Looks to match the characters the constitute the token OBJSEP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mOBJSEP()
{
    ANTLR_UINT32	_type;
      


    _type	    = OBJSEP;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:164:5: ( ';' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:164:7: ';'
    {
         this->matchc(';');
        if  (this->hasException())
        {
            goto ruleOBJSEPEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleOBJSEPEx; /* Prevent compiler warnings */
    ruleOBJSEPEx: ;

}
// $ANTLR end OBJSEP

//   Comes from: 168:5: ( ';;' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SENTSEP
 *
 * Looks to match the characters the constitute the token SENTSEP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mSENTSEP()
{
    ANTLR_UINT32	_type;
      


    _type	    = SENTSEP;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:168:5: ( ';;' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:168:7: ';;'
    {
        this->matchs(lit_7);
        if  (this->hasException())
        {
            goto ruleSENTSEPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSENTSEPEx; /* Prevent compiler warnings */
    ruleSENTSEPEx: ;

}
// $ANTLR end SENTSEP

//   Comes from: 172:5: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SYNSEP
 *
 * Looks to match the characters the constitute the token SYNSEP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mSYNSEP()
{
    ANTLR_UINT32	_type;
      


    _type	    = SYNSEP;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:172:5: ( '=' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:172:7: '='
    {
         this->matchc('=');
        if  (this->hasException())
        {
            goto ruleSYNSEPEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSYNSEPEx; /* Prevent compiler warnings */
    ruleSYNSEPEx: ;

}
// $ANTLR end SYNSEP

//   Comes from: 176:5: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LPAR
 *
 * Looks to match the characters the constitute the token LPAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mLPAR()
{
    ANTLR_UINT32	_type;
      


    _type	    = LPAR;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:176:5: ( '(' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:176:7: '('
    {
         this->matchc('(');
        if  (this->hasException())
        {
            goto ruleLPAREx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLPAREx; /* Prevent compiler warnings */
    ruleLPAREx: ;

}
// $ANTLR end LPAR

//   Comes from: 180:5: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RPAR
 *
 * Looks to match the characters the constitute the token RPAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mRPAR()
{
    ANTLR_UINT32	_type;
      


    _type	    = RPAR;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:180:5: ( ')' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:180:7: ')'
    {
         this->matchc(')');
        if  (this->hasException())
        {
            goto ruleRPAREx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleRPAREx; /* Prevent compiler warnings */
    ruleRPAREx: ;

}
// $ANTLR end RPAR

//   Comes from: 184:5: ( '****' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ALIASNONAME
 *
 * Looks to match the characters the constitute the token ALIASNONAME
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mALIASNONAME()
{
    ANTLR_UINT32	_type;
      


    _type	    = ALIASNONAME;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:184:5: ( '****' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:184:7: '****'
    {
        this->matchs(lit_8);
        if  (this->hasException())
        {
            goto ruleALIASNONAMEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleALIASNONAMEEx; /* Prevent compiler warnings */
    ruleALIASNONAMEEx: ;

}
// $ANTLR end ALIASNONAME

//   Comes from: 188:5: ( '{' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LPAR_SET
 *
 * Looks to match the characters the constitute the token LPAR_SET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mLPAR_SET()
{
    ANTLR_UINT32	_type;
      


    _type	    = LPAR_SET;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:188:5: ( '{' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:188:7: '{'
    {
         this->matchc('{');
        if  (this->hasException())
        {
            goto ruleLPAR_SETEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLPAR_SETEx; /* Prevent compiler warnings */
    ruleLPAR_SETEx: ;

}
// $ANTLR end LPAR_SET

//   Comes from: 192:5: ( '}' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RPAR_SET
 *
 * Looks to match the characters the constitute the token RPAR_SET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mRPAR_SET()
{
    ANTLR_UINT32	_type;
      


    _type	    = RPAR_SET;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:192:5: ( '}' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:192:7: '}'
    {
         this->matchc('}');
        if  (this->hasException())
        {
            goto ruleRPAR_SETEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleRPAR_SETEx; /* Prevent compiler warnings */
    ruleRPAR_SETEx: ;

}
// $ANTLR end RPAR_SET

//   Comes from: 196:5: ( '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LPAR_OSET
 *
 * Looks to match the characters the constitute the token LPAR_OSET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mLPAR_OSET()
{
    ANTLR_UINT32	_type;
      


    _type	    = LPAR_OSET;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:196:5: ( '<' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:196:7: '<'
    {
         this->matchc('<');
        if  (this->hasException())
        {
            goto ruleLPAR_OSETEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLPAR_OSETEx; /* Prevent compiler warnings */
    ruleLPAR_OSETEx: ;

}
// $ANTLR end LPAR_OSET

//   Comes from: 200:5: ( '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RPAR_OSET
 *
 * Looks to match the characters the constitute the token RPAR_OSET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mRPAR_OSET()
{
    ANTLR_UINT32	_type;
      


    _type	    = RPAR_OSET;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:200:5: ( '>' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:200:7: '>'
    {
         this->matchc('>');
        if  (this->hasException())
        {
            goto ruleRPAR_OSETEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleRPAR_OSETEx; /* Prevent compiler warnings */
    ruleRPAR_OSETEx: ;

}
// $ANTLR end RPAR_OSET

//   Comes from: 204:5: ( '[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LPAR_TRF
 *
 * Looks to match the characters the constitute the token LPAR_TRF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mLPAR_TRF()
{
    ANTLR_UINT32	_type;
      


    _type	    = LPAR_TRF;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:204:5: ( '[' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:204:7: '['
    {
         this->matchc('[');
        if  (this->hasException())
        {
            goto ruleLPAR_TRFEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLPAR_TRFEx; /* Prevent compiler warnings */
    ruleLPAR_TRFEx: ;

}
// $ANTLR end LPAR_TRF

//   Comes from: 208:5: ( ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RPAR_TRF
 *
 * Looks to match the characters the constitute the token RPAR_TRF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mRPAR_TRF()
{
    ANTLR_UINT32	_type;
      


    _type	    = RPAR_TRF;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:208:5: ( ']' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:208:7: ']'
    {
         this->matchc(']');
        if  (this->hasException())
        {
            goto ruleRPAR_TRFEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleRPAR_TRFEx; /* Prevent compiler warnings */
    ruleRPAR_TRFEx: ;

}
// $ANTLR end RPAR_TRF

//   Comes from: 212:5: ( '(*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LPAR_INT
 *
 * Looks to match the characters the constitute the token LPAR_INT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mLPAR_INT()
{
    ANTLR_UINT32	_type;
      


    _type	    = LPAR_INT;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:212:5: ( '(*' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:212:7: '(*'
    {
        this->matchs(lit_9);
        if  (this->hasException())
        {
            goto ruleLPAR_INTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLPAR_INTEx; /* Prevent compiler warnings */
    ruleLPAR_INTEx: ;

}
// $ANTLR end LPAR_INT

//   Comes from: 216:5: ( '*)' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RPAR_INT
 *
 * Looks to match the characters the constitute the token RPAR_INT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mRPAR_INT()
{
    ANTLR_UINT32	_type;
      


    _type	    = RPAR_INT;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:216:5: ( '*)' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:216:7: '*)'
    {
        this->matchs(lit_10);
        if  (this->hasException())
        {
            goto ruleRPAR_INTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleRPAR_INTEx; /* Prevent compiler warnings */
    ruleRPAR_INTEx: ;

}
// $ANTLR end RPAR_INT

//   Comes from: 221:13: ( '<>' | '>' | '<' | '..>' | '<..' | '->' | '<-' | '<=>' | '_<=>' | '=' | '=>' | '<=' | '_=>' | '_<=' | '_->' | '_<-' | '-|>' | '<|-' | '_-|>' | '_<|-' | '-/>' | '</-' | '_-/>' | '_</-' | '~>' | '<~' | '_~>' | '_<~' | '~|>' | '<|~' | '_~|>' | '_<|~' | '~/>' | '</~' | '_~/>' | '_</~' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CONNECTORS
 *
 * Looks to match the characters the constitute the token CONNECTORS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mCONNECTORS()
{
    ANTLR_UINT32	_type;
      


    _type	    = CONNECTORS;


    {
        //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:221:13: ( '<>' | '>' | '<' | '..>' | '<..' | '->' | '<-' | '<=>' | '_<=>' | '=' | '=>' | '<=' | '_=>' | '_<=' | '_->' | '_<-' | '-|>' | '<|-' | '_-|>' | '_<|-' | '-/>' | '</-' | '_-/>' | '_</-' | '~>' | '<~' | '_~>' | '_<~' | '~|>' | '<|~' | '_~|>' | '_<|~' | '~/>' | '</~' | '_~/>' | '_</~' )

        ANTLR_UINT32 alt4;

        alt4=36;

        switch ( this->LA(1) )
        {
        case '<':
        	{
        		switch ( this->LA(2) )
        		{
        		case '>':
        			{
        				alt4=1;
        			}
        		    break;
        		case '.':
        			{
        				alt4=5;
        			}
        		    break;
        		case '-':
        			{
        				alt4=7;
        			}
        		    break;
        		case '=':
        			{
        				switch ( this->LA(3) )
        				{
        				case '>':
        					{
        						alt4=8;
        					}
        				    break;

        				default:
        				    alt4=12;
        				}

        			}
        		    break;
        		case '|':
        			{
        				switch ( this->LA(3) )
        				{
        				case '-':
        					{
        						alt4=18;
        					}
        				    break;
        				case '~':
        					{
        						alt4=30;
        					}
        				    break;

        				default:
        				    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        				    ex->set_decisionNum( 4 );
        				    ex->set_state( 12 );


        				    goto ruleCONNECTORSEx;

        				}

        			}
        		    break;
        		case '/':
        			{
        				switch ( this->LA(3) )
        				{
        				case '-':
        					{
        						alt4=22;
        					}
        				    break;
        				case '~':
        					{
        						alt4=34;
        					}
        				    break;

        				default:
        				    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        				    ex->set_decisionNum( 4 );
        				    ex->set_state( 13 );


        				    goto ruleCONNECTORSEx;

        				}

        			}
        		    break;
        		case '~':
        			{
        				alt4=26;
        			}
        		    break;

        		default:
        		    alt4=3;
        		}

        	}
            break;
        case '>':
        	{
        		alt4=2;
        	}
            break;
        case '.':
        	{
        		alt4=4;
        	}
            break;
        case '-':
        	{
        		switch ( this->LA(2) )
        		{
        		case '>':
        			{
        				alt4=6;
        			}
        		    break;
        		case '|':
        			{
        				alt4=17;
        			}
        		    break;
        		case '/':
        			{
        				alt4=21;
        			}
        		    break;

        		default:
        		    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        		    ex->set_decisionNum( 4 );
        		    ex->set_state( 4 );


        		    goto ruleCONNECTORSEx;

        		}

        	}
            break;
        case '_':
        	{
        		switch ( this->LA(2) )
        		{
        		case '<':
        			{
        				switch ( this->LA(3) )
        				{
        				case '=':
        					{
        						switch ( this->LA(4) )
        						{
        						case '>':
        							{
        								alt4=9;
        							}
        						    break;

        						default:
        						    alt4=14;
        						}

        					}
        				    break;
        				case '-':
        					{
        						alt4=16;
        					}
        				    break;
        				case '|':
        					{
        						switch ( this->LA(4) )
        						{
        						case '-':
        							{
        								alt4=20;
        							}
        						    break;
        						case '~':
        							{
        								alt4=32;
        							}
        						    break;

        						default:
        						    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        						    ex->set_decisionNum( 4 );
        						    ex->set_state( 36 );


        						    goto ruleCONNECTORSEx;

        						}

        					}
        				    break;
        				case '/':
        					{
        						switch ( this->LA(4) )
        						{
        						case '-':
        							{
        								alt4=24;
        							}
        						    break;
        						case '~':
        							{
        								alt4=36;
        							}
        						    break;

        						default:
        						    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        						    ex->set_decisionNum( 4 );
        						    ex->set_state( 37 );


        						    goto ruleCONNECTORSEx;

        						}

        					}
        				    break;
        				case '~':
        					{
        						alt4=28;
        					}
        				    break;

        				default:
        				    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        				    ex->set_decisionNum( 4 );
        				    ex->set_state( 19 );


        				    goto ruleCONNECTORSEx;

        				}

        			}
        		    break;
        		case '=':
        			{
        				alt4=13;
        			}
        		    break;
        		case '-':
        			{
        				switch ( this->LA(3) )
        				{
        				case '>':
        					{
        						alt4=15;
        					}
        				    break;
        				case '|':
        					{
        						alt4=19;
        					}
        				    break;
        				case '/':
        					{
        						alt4=23;
        					}
        				    break;

        				default:
        				    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        				    ex->set_decisionNum( 4 );
        				    ex->set_state( 21 );


        				    goto ruleCONNECTORSEx;

        				}

        			}
        		    break;
        		case '~':
        			{
        				switch ( this->LA(3) )
        				{
        				case '>':
        					{
        						alt4=27;
        					}
        				    break;
        				case '|':
        					{
        						alt4=31;
        					}
        				    break;
        				case '/':
        					{
        						alt4=35;
        					}
        				    break;

        				default:
        				    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        				    ex->set_decisionNum( 4 );
        				    ex->set_state( 22 );


        				    goto ruleCONNECTORSEx;

        				}

        			}
        		    break;

        		default:
        		    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        		    ex->set_decisionNum( 4 );
        		    ex->set_state( 5 );


        		    goto ruleCONNECTORSEx;

        		}

        	}
            break;
        case '=':
        	{
        		switch ( this->LA(2) )
        		{
        		case '>':
        			{
        				alt4=11;
        			}
        		    break;

        		default:
        		    alt4=10;
        		}

        	}
            break;
        case '~':
        	{
        		switch ( this->LA(2) )
        		{
        		case '>':
        			{
        				alt4=25;
        			}
        		    break;
        		case '|':
        			{
        				alt4=29;
        			}
        		    break;
        		case '/':
        			{
        				alt4=33;
        			}
        		    break;

        		default:
        		    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        		    ex->set_decisionNum( 4 );
        		    ex->set_state( 7 );


        		    goto ruleCONNECTORSEx;

        		}

        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 4 );
            ex->set_state( 0 );


            goto ruleCONNECTORSEx;

        }

        switch (alt4)
        {
    	case 1:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:222:17: '<>'
    	    {
    	        this->matchs(lit_11);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 2:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:223:17: '>'
    	    {
    	         this->matchc('>');
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }


    	    }
    	    break;
    	case 3:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:224:17: '<'
    	    {
    	         this->matchc('<');
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }


    	    }
    	    break;
    	case 4:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:225:17: '..>'
    	    {
    	        this->matchs(lit_12);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 5:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:226:17: '<..'
    	    {
    	        this->matchs(lit_13);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 6:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:227:17: '->'
    	    {
    	        this->matchs(lit_14);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 7:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:228:17: '<-'
    	    {
    	        this->matchs(lit_15);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 8:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:229:17: '<=>'
    	    {
    	        this->matchs(lit_16);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 9:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:230:17: '_<=>'
    	    {
    	        this->matchs(lit_17);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 10:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:231:17: '='
    	    {
    	         this->matchc('=');
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }


    	    }
    	    break;
    	case 11:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:232:17: '=>'
    	    {
    	        this->matchs(lit_18);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 12:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:233:17: '<='
    	    {
    	        this->matchs(lit_19);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 13:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:234:17: '_=>'
    	    {
    	        this->matchs(lit_20);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 14:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:235:17: '_<='
    	    {
    	        this->matchs(lit_21);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 15:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:236:17: '_->'
    	    {
    	        this->matchs(lit_22);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 16:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:237:17: '_<-'
    	    {
    	        this->matchs(lit_23);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 17:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:238:17: '-|>'
    	    {
    	        this->matchs(lit_24);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 18:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:239:17: '<|-'
    	    {
    	        this->matchs(lit_25);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 19:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:240:17: '_-|>'
    	    {
    	        this->matchs(lit_26);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 20:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:241:17: '_<|-'
    	    {
    	        this->matchs(lit_27);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 21:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:242:17: '-/>'
    	    {
    	        this->matchs(lit_28);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 22:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:243:17: '</-'
    	    {
    	        this->matchs(lit_29);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 23:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:244:17: '_-/>'
    	    {
    	        this->matchs(lit_30);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 24:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:245:17: '_</-'
    	    {
    	        this->matchs(lit_31);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 25:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:246:17: '~>'
    	    {
    	        this->matchs(lit_32);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 26:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:247:17: '<~'
    	    {
    	        this->matchs(lit_33);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 27:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:248:17: '_~>'
    	    {
    	        this->matchs(lit_34);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 28:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:249:17: '_<~'
    	    {
    	        this->matchs(lit_35);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 29:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:250:17: '~|>'
    	    {
    	        this->matchs(lit_36);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 30:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:251:17: '<|~'
    	    {
    	        this->matchs(lit_37);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 31:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:252:17: '_~|>'
    	    {
    	        this->matchs(lit_38);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 32:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:253:17: '_<|~'
    	    {
    	        this->matchs(lit_39);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 33:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:254:17: '~/>'
    	    {
    	        this->matchs(lit_40);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 34:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:255:17: '</~'
    	    {
    	        this->matchs(lit_41);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 35:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:256:17: '_~/>'
    	    {
    	        this->matchs(lit_42);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 36:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:257:17: '_</~'
    	    {
    	        this->matchs(lit_43);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;

        }
    }
	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCONNECTORSEx; /* Prevent compiler warnings */
    ruleCONNECTORSEx: ;

}
// $ANTLR end CONNECTORS

//   Comes from: 263:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NAME
 *
 * Looks to match the characters the constitute the token NAME
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mNAME()
{
    ANTLR_UINT32	_type;
      


    _type	    = NAME;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:263:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )+ )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:263:10: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )+
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:263:10: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )+
        {
            int cnt5=0;

            for (;;)
            {
                int alt5=2;
        	switch ( this->LA(1) )
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        	case 'A':
        	case 'B':
        	case 'C':
        	case 'D':
        	case 'E':
        	case 'F':
        	case 'G':
        	case 'H':
        	case 'I':
        	case 'J':
        	case 'K':
        	case 'L':
        	case 'M':
        	case 'N':
        	case 'O':
        	case 'P':
        	case 'Q':
        	case 'R':
        	case 'S':
        	case 'T':
        	case 'U':
        	case 'V':
        	case 'W':
        	case 'X':
        	case 'Y':
        	case 'Z':
        	case '_':
        	case 'a':
        	case 'b':
        	case 'c':
        	case 'd':
        	case 'e':
        	case 'f':
        	case 'g':
        	case 'h':
        	case 'i':
        	case 'j':
        	case 'k':
        	case 'l':
        	case 'm':
        	case 'n':
        	case 'o':
        	case 'p':
        	case 'q':
        	case 'r':
        	case 's':
        	case 't':
        	case 'u':
        	case 'v':
        	case 'w':
        	case 'x':
        	case 'y':
        	case 'z':
        		{
        			alt5=1;
        		}
        	    break;

        	}

        	switch (alt5)
        	{
        	    case 1:
        	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:
        	        {
        	            if ( ((this->LA(1) >= '0') && (this->LA(1) <= '9')) || ((this->LA(1) >= 'A') && (this->LA(1) <= 'Z')) || this->LA(1) == '_' || ((this->LA(1) >= 'a') && (this->LA(1) <= 'z')) )
        	            {
        	                this->consume();
        	            }
        	            else
        	            {
        	                new ANTLR_Exception< SCsLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	                this->recover();
        	                goto ruleNAMEEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt5 >= 1 )
        		{
        		    goto loop5;
        		}
        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< SCsLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto ruleNAMEEx;
        	}
        	cnt5++;
            }
            loop5: ;	/* Jump to here if this rule does not match */
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleNAMEEx; /* Prevent compiler warnings */
    ruleNAMEEx: ;

}
// $ANTLR end NAME

//   Comes from: 268:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' | '/!*' ( options {greedy=false; } : . )* '*/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT
 *
 * Looks to match the characters the constitute the token COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mCOMMENT()
{
    ANTLR_UINT32	_type;
      


    _type	    = COMMENT;


    {
        //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:268:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' | '/!*' ( options {greedy=false; } : . )* '*/' )

        ANTLR_UINT32 alt9;

        alt9=2;

        switch ( this->LA(1) )
        {
        case '/':
        	{
        		switch ( this->LA(2) )
        		{
        		case '/':
        			{
        				alt9=1;
        			}
        		    break;
        		case '!':
        			{
        				alt9=2;
        			}
        		    break;

        		default:
        		    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        		    ex->set_decisionNum( 9 );
        		    ex->set_state( 1 );


        		    goto ruleCOMMENTEx;

        		}

        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 9 );
            ex->set_state( 0 );


            goto ruleCOMMENTEx;

        }

        switch (alt9)
        {
    	case 1:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:268:9: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
    	    {
    	        this->matchs(lit_44);
    	        if  (this->hasException())
    	        {
    	            goto ruleCOMMENTEx;
    	        }




    	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:268:14: (~ ( '\\n' | '\\r' ) )*

    	        for (;;)
    	        {
    	            int alt6=2;
    	            {
    	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                */
    	                int LA6_0 = this->LA(1);
    	                if ( (((LA6_0 >= 0x0000) && (LA6_0 <= '\t')) || ((LA6_0 >= 0x000B) && (LA6_0 <= '\f')) || ((LA6_0 >= 0x000E) && (LA6_0 <= 0xFFFF))))
    	                {
    	                    alt6=1;
    	                }

    	            }
    	            switch (alt6)
    	            {
    	        	case 1:
    	        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:
    	        	    {
    	        	        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\t')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= 0xFFFF)) )
    	        	        {
    	        	            this->consume();
    	        	        }
    	        	        else
    	        	        {
    	        	            new ANTLR_Exception< SCsLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

    	        	            this->recover();
    	        	            goto ruleCOMMENTEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop6;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop6: ; /* Jump out to here if this rule does not match */


    	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:268:28: ( '\\r' )?
    	        {
    	            int alt7=2;
    	            switch ( this->LA(1) )
    	            {
    	                case '\r':
    	                	{
    	                		alt7=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt7)
    	            {
    	        	case 1:
    	        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:268:28: '\\r'
    	        	    {
    	        	         this->matchc('\r');
    	        	        if  (this->hasException())
    	        	        {
    	        	            goto ruleCOMMENTEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }

    	         this->matchc('\n');
    	        if  (this->hasException())
    	        {
    	            goto ruleCOMMENTEx;
    	        }


    	        {
    	            this->get_state()->get_channel()=HIDDEN;
    	        }


    	    }
    	    break;
    	case 2:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:269:9: '/!*' ( options {greedy=false; } : . )* '*/'
    	    {
    	        this->matchs(lit_45);
    	        if  (this->hasException())
    	        {
    	            goto ruleCOMMENTEx;
    	        }




    	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:269:15: ( options {greedy=false; } : . )*

    	        for (;;)
    	        {
    	            int alt8=2;
    	            {
    	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                */
    	                int LA8_0 = this->LA(1);
    	                if ( (LA8_0 == '*'))
    	                {
    	                    {
    	                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                        */
    	                        int LA8_1 = this->LA(2);
    	                        if ( (LA8_1 == '/'))
    	                        {
    	                            alt8=2;
    	                        }
    	                        else if ( (((LA8_1 >= 0x0000) && (LA8_1 <= '.')) || ((LA8_1 >= '0') && (LA8_1 <= 0xFFFF))))
    	                        {
    	                            alt8=1;
    	                        }

    	                    }
    	                }
    	                else if ( (((LA8_0 >= 0x0000) && (LA8_0 <= ')')) || ((LA8_0 >= '+') && (LA8_0 <= 0xFFFF))))
    	                {
    	                    alt8=1;
    	                }

    	            }
    	            switch (alt8)
    	            {
    	        	case 1:
    	        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:269:43: .
    	        	    {
    	        	        this->matchAny();
    	        	        if  (this->hasException())
    	        	        {
    	        	            goto ruleCOMMENTEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop8;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop8: ; /* Jump out to here if this rule does not match */


    	        this->matchs(lit_46);
    	        if  (this->hasException())
    	        {
    	            goto ruleCOMMENTEx;
    	        }




    	        {
    	            this->get_state()->get_channel()=HIDDEN;
    	        }


    	    }
    	    break;

        }
    }
	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCOMMENTEx; /* Prevent compiler warnings */
    ruleCOMMENTEx: ;

}
// $ANTLR end COMMENT

//   Comes from: 272:5: ( ( ' ' | '\\t' | '\\r' | '\\n' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WS
 *
 * Looks to match the characters the constitute the token WS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mWS()
{
    ANTLR_UINT32	_type;
      


    _type	    = WS;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:272:5: ( ( ' ' | '\\t' | '\\r' | '\\n' ) )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:272:9: ( ' ' | '\\t' | '\\r' | '\\n' )
    {
        if ( ((this->LA(1) >= '\t') && (this->LA(1) <= '\n')) || this->LA(1) == '\r' || this->LA(1) == ' ' )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< SCsLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleWSEx;
        }


        {
            this->get_state()->get_channel()=HIDDEN;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleWSEx; /* Prevent compiler warnings */
    ruleWSEx: ;

}
// $ANTLR end WS

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
void
SCsLexer::mTokens()
{
    {
        //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:8: ( T__27 | CONTENT | ELEMTYPE | URL | TRIPLESEP | ATTRSEP | OBJSEP | SENTSEP | SYNSEP | LPAR | RPAR | ALIASNONAME | LPAR_SET | RPAR_SET | LPAR_OSET | RPAR_OSET | LPAR_TRF | RPAR_TRF | LPAR_INT | RPAR_INT | CONNECTORS | NAME | COMMENT | WS )

        ANTLR_UINT32 alt10;

        alt10=24;

        switch ( this->LA(1) )
        {
        case '/':
        	{
        		switch ( this->LA(2) )
        		{
        		case '!':
        		case '/':
        			{
        				alt10=23;
        			}
        		    break;

        		default:
        		    alt10=1;
        		}

        	}
            break;
        case '[':
        	{
        		{
        		    int LA10_2 = this->LA(2);
        		    if ( (((LA10_2 >= 0x0000) && (LA10_2 <= 0xFFFF))))
        		    {
        		        alt10=2;
        		    }
        		    else
        		    {
        		        alt10=17;
        		    }
        		}
        	}
            break;
        case 's':
        	{
        		switch ( this->LA(2) )
        		{
        		case 'c':
        			{
        				switch ( this->LA(3) )
        				{
        				case '_':
        					{
        						switch ( this->LA(4) )
        						{
        						case 'a':
        							{
        								switch ( this->LA(5) )
        								{
        								case 'r':
        									{
        										switch ( this->LA(6) )
        										{
        										case 'c':
        											{
        												switch ( this->LA(7) )
        												{
        												case '_':
        													{
        														switch ( this->LA(8) )
        														{
        														case 'm':
        															{
        																switch ( this->LA(9) )
        																{
        																case 'a':
        																	{
        																		switch ( this->LA(10) )
        																		{
        																		case 'i':
        																			{
        																				switch ( this->LA(11) )
        																				{
        																				case 'n':
        																					{
        																						switch ( this->LA(12) )
        																						{
        																						case '0':
        																						case '1':
        																						case '2':
        																						case '3':
        																						case '4':
        																						case '5':
        																						case '6':
        																						case '7':
        																						case '8':
        																						case '9':
        																						case 'A':
        																						case 'B':
        																						case 'C':
        																						case 'D':
        																						case 'E':
        																						case 'F':
        																						case 'G':
        																						case 'H':
        																						case 'I':
        																						case 'J':
        																						case 'K':
        																						case 'L':
        																						case 'M':
        																						case 'N':
        																						case 'O':
        																						case 'P':
        																						case 'Q':
        																						case 'R':
        																						case 'S':
        																						case 'T':
        																						case 'U':
        																						case 'V':
        																						case 'W':
        																						case 'X':
        																						case 'Y':
        																						case 'Z':
        																						case '_':
        																						case 'a':
        																						case 'b':
        																						case 'c':
        																						case 'd':
        																						case 'e':
        																						case 'f':
        																						case 'g':
        																						case 'h':
        																						case 'i':
        																						case 'j':
        																						case 'k':
        																						case 'l':
        																						case 'm':
        																						case 'n':
        																						case 'o':
        																						case 'p':
        																						case 'q':
        																						case 'r':
        																						case 's':
        																						case 't':
        																						case 'u':
        																						case 'v':
        																						case 'w':
        																						case 'x':
        																						case 'y':
        																						case 'z':
        																							{
        																								alt10=22;
        																							}
        																						    break;

        																						default:
        																						    alt10=3;
        																						}

        																					}
        																				    break;

        																				default:
        																				    alt10=22;
        																				}

        																			}
        																		    break;

        																		default:
        																		    alt10=22;
        																		}

        																	}
        																    break;

        																default:
        																    alt10=22;
        																}

        															}
        														    break;
        														case 'c':
        															{
        																switch ( this->LA(9) )
        																{
        																case 'o':
        																	{
        																		switch ( this->LA(10) )
        																		{
        																		case 'm':
        																			{
        																				switch ( this->LA(11) )
        																				{
        																				case 'm':
        																					{
        																						switch ( this->LA(12) )
        																						{
        																						case 'o':
        																							{
        																								switch ( this->LA(13) )
        																								{
        																								case 'n':
        																									{
        																										switch ( this->LA(14) )
        																										{
        																										case '0':
        																										case '1':
        																										case '2':
        																										case '3':
        																										case '4':
        																										case '5':
        																										case '6':
        																										case '7':
        																										case '8':
        																										case '9':
        																										case 'A':
        																										case 'B':
        																										case 'C':
        																										case 'D':
        																										case 'E':
        																										case 'F':
        																										case 'G':
        																										case 'H':
        																										case 'I':
        																										case 'J':
        																										case 'K':
        																										case 'L':
        																										case 'M':
        																										case 'N':
        																										case 'O':
        																										case 'P':
        																										case 'Q':
        																										case 'R':
        																										case 'S':
        																										case 'T':
        																										case 'U':
        																										case 'V':
        																										case 'W':
        																										case 'X':
        																										case 'Y':
        																										case 'Z':
        																										case '_':
        																										case 'a':
        																										case 'b':
        																										case 'c':
        																										case 'd':
        																										case 'e':
        																										case 'f':
        																										case 'g':
        																										case 'h':
        																										case 'i':
        																										case 'j':
        																										case 'k':
        																										case 'l':
        																										case 'm':
        																										case 'n':
        																										case 'o':
        																										case 'p':
        																										case 'q':
        																										case 'r':
        																										case 's':
        																										case 't':
        																										case 'u':
        																										case 'v':
        																										case 'w':
        																										case 'x':
        																										case 'y':
        																										case 'z':
        																											{
        																												alt10=22;
        																											}
        																										    break;

        																										default:
        																										    alt10=3;
        																										}

        																									}
        																								    break;

        																								default:
        																								    alt10=22;
        																								}

        																							}
        																						    break;

        																						default:
        																						    alt10=22;
        																						}

        																					}
        																				    break;

        																				default:
        																				    alt10=22;
        																				}

        																			}
        																		    break;

        																		default:
        																		    alt10=22;
        																		}

        																	}
        																    break;

        																default:
        																    alt10=22;
        																}

        															}
        														    break;
        														case 'a':
        															{
        																switch ( this->LA(9) )
        																{
        																case 'c':
        																	{
        																		switch ( this->LA(10) )
        																		{
        																		case 'c':
        																			{
        																				switch ( this->LA(11) )
        																				{
        																				case 'e':
        																					{
        																						switch ( this->LA(12) )
        																						{
        																						case 's':
        																							{
        																								switch ( this->LA(13) )
        																								{
        																								case 's':
        																									{
        																										switch ( this->LA(14) )
        																										{
        																										case '0':
        																										case '1':
        																										case '2':
        																										case '3':
        																										case '4':
        																										case '5':
        																										case '6':
        																										case '7':
        																										case '8':
        																										case '9':
        																										case 'A':
        																										case 'B':
        																										case 'C':
        																										case 'D':
        																										case 'E':
        																										case 'F':
        																										case 'G':
        																										case 'H':
        																										case 'I':
        																										case 'J':
        																										case 'K':
        																										case 'L':
        																										case 'M':
        																										case 'N':
        																										case 'O':
        																										case 'P':
        																										case 'Q':
        																										case 'R':
        																										case 'S':
        																										case 'T':
        																										case 'U':
        																										case 'V':
        																										case 'W':
        																										case 'X':
        																										case 'Y':
        																										case 'Z':
        																										case '_':
        																										case 'a':
        																										case 'b':
        																										case 'c':
        																										case 'd':
        																										case 'e':
        																										case 'f':
        																										case 'g':
        																										case 'h':
        																										case 'i':
        																										case 'j':
        																										case 'k':
        																										case 'l':
        																										case 'm':
        																										case 'n':
        																										case 'o':
        																										case 'p':
        																										case 'q':
        																										case 'r':
        																										case 's':
        																										case 't':
        																										case 'u':
        																										case 'v':
        																										case 'w':
        																										case 'x':
        																										case 'y':
        																										case 'z':
        																											{
        																												alt10=22;
        																											}
        																										    break;

        																										default:
        																										    alt10=3;
        																										}

        																									}
        																								    break;

        																								default:
        																								    alt10=22;
        																								}

        																							}
        																						    break;

        																						default:
        																						    alt10=22;
        																						}

        																					}
        																				    break;

        																				default:
        																				    alt10=22;
        																				}

        																			}
        																		    break;

        																		default:
        																		    alt10=22;
        																		}

        																	}
        																    break;

        																default:
        																    alt10=22;
        																}

        															}
        														    break;

        														default:
        														    alt10=22;
        														}

        													}
        												    break;

        												default:
        												    alt10=22;
        												}

        											}
        										    break;

        										default:
        										    alt10=22;
        										}

        									}
        								    break;

        								default:
        								    alt10=22;
        								}

        							}
        						    break;
        						case 'l':
        							{
        								switch ( this->LA(5) )
        								{
        								case 'i':
        									{
        										switch ( this->LA(6) )
        										{
        										case 'n':
        											{
        												switch ( this->LA(7) )
        												{
        												case 'k':
        													{
        														switch ( this->LA(8) )
        														{
        														case '0':
        														case '1':
        														case '2':
        														case '3':
        														case '4':
        														case '5':
        														case '6':
        														case '7':
        														case '8':
        														case '9':
        														case 'A':
        														case 'B':
        														case 'C':
        														case 'D':
        														case 'E':
        														case 'F':
        														case 'G':
        														case 'H':
        														case 'I':
        														case 'J':
        														case 'K':
        														case 'L':
        														case 'M':
        														case 'N':
        														case 'O':
        														case 'P':
        														case 'Q':
        														case 'R':
        														case 'S':
        														case 'T':
        														case 'U':
        														case 'V':
        														case 'W':
        														case 'X':
        														case 'Y':
        														case 'Z':
        														case '_':
        														case 'a':
        														case 'b':
        														case 'c':
        														case 'd':
        														case 'e':
        														case 'f':
        														case 'g':
        														case 'h':
        														case 'i':
        														case 'j':
        														case 'k':
        														case 'l':
        														case 'm':
        														case 'n':
        														case 'o':
        														case 'p':
        														case 'q':
        														case 'r':
        														case 's':
        														case 't':
        														case 'u':
        														case 'v':
        														case 'w':
        														case 'x':
        														case 'y':
        														case 'z':
        															{
        																alt10=22;
        															}
        														    break;

        														default:
        														    alt10=3;
        														}

        													}
        												    break;

        												default:
        												    alt10=22;
        												}

        											}
        										    break;

        										default:
        										    alt10=22;
        										}

        									}
        								    break;

        								default:
        								    alt10=22;
        								}

        							}
        						    break;
        						case 'n':
        							{
        								switch ( this->LA(5) )
        								{
        								case 'o':
        									{
        										switch ( this->LA(6) )
        										{
        										case 'd':
        											{
        												switch ( this->LA(7) )
        												{
        												case 'e':
        													{
        														switch ( this->LA(8) )
        														{
        														case '0':
        														case '1':
        														case '2':
        														case '3':
        														case '4':
        														case '5':
        														case '6':
        														case '7':
        														case '8':
        														case '9':
        														case 'A':
        														case 'B':
        														case 'C':
        														case 'D':
        														case 'E':
        														case 'F':
        														case 'G':
        														case 'H':
        														case 'I':
        														case 'J':
        														case 'K':
        														case 'L':
        														case 'M':
        														case 'N':
        														case 'O':
        														case 'P':
        														case 'Q':
        														case 'R':
        														case 'S':
        														case 'T':
        														case 'U':
        														case 'V':
        														case 'W':
        														case 'X':
        														case 'Y':
        														case 'Z':
        														case '_':
        														case 'a':
        														case 'b':
        														case 'c':
        														case 'd':
        														case 'e':
        														case 'f':
        														case 'g':
        														case 'h':
        														case 'i':
        														case 'j':
        														case 'k':
        														case 'l':
        														case 'm':
        														case 'n':
        														case 'o':
        														case 'p':
        														case 'q':
        														case 'r':
        														case 's':
        														case 't':
        														case 'u':
        														case 'v':
        														case 'w':
        														case 'x':
        														case 'y':
        														case 'z':
        															{
        																alt10=22;
        															}
        														    break;

        														default:
        														    alt10=3;
        														}

        													}
        												    break;

        												default:
        												    alt10=22;
        												}

        											}
        										    break;

        										default:
        										    alt10=22;
        										}

        									}
        								    break;

        								default:
        								    alt10=22;
        								}

        							}
        						    break;
        						case 'e':
        							{
        								switch ( this->LA(5) )
        								{
        								case 'd':
        									{
        										switch ( this->LA(6) )
        										{
        										case 'g':
        											{
        												switch ( this->LA(7) )
        												{
        												case 'e':
        													{
        														switch ( this->LA(8) )
        														{
        														case '0':
        														case '1':
        														case '2':
        														case '3':
        														case '4':
        														case '5':
        														case '6':
        														case '7':
        														case '8':
        														case '9':
        														case 'A':
        														case 'B':
        														case 'C':
        														case 'D':
        														case 'E':
        														case 'F':
        														case 'G':
        														case 'H':
        														case 'I':
        														case 'J':
        														case 'K':
        														case 'L':
        														case 'M':
        														case 'N':
        														case 'O':
        														case 'P':
        														case 'Q':
        														case 'R':
        														case 'S':
        														case 'T':
        														case 'U':
        														case 'V':
        														case 'W':
        														case 'X':
        														case 'Y':
        														case 'Z':
        														case '_':
        														case 'a':
        														case 'b':
        														case 'c':
        														case 'd':
        														case 'e':
        														case 'f':
        														case 'g':
        														case 'h':
        														case 'i':
        														case 'j':
        														case 'k':
        														case 'l':
        														case 'm':
        														case 'n':
        														case 'o':
        														case 'p':
        														case 'q':
        														case 'r':
        														case 's':
        														case 't':
        														case 'u':
        														case 'v':
        														case 'w':
        														case 'x':
        														case 'y':
        														case 'z':
        															{
        																alt10=22;
        															}
        														    break;

        														default:
        														    alt10=3;
        														}

        													}
        												    break;

        												default:
        												    alt10=22;
        												}

        											}
        										    break;

        										default:
        										    alt10=22;
        										}

        									}
        								    break;

        								default:
        								    alt10=22;
        								}

        							}
        						    break;

        						default:
        						    alt10=22;
        						}

        					}
        				    break;

        				default:
        				    alt10=22;
        				}

        			}
        		    break;

        		default:
        		    alt10=22;
        		}

        	}
            break;
        case '"':
        	{
        		alt10=4;
        	}
            break;
        case '|':
        	{
        		alt10=5;
        	}
            break;
        case ':':
        	{
        		alt10=6;
        	}
            break;
        case ';':
        	{
        		switch ( this->LA(2) )
        		{
        		case ';':
        			{
        				alt10=8;
        			}
        		    break;

        		default:
        		    alt10=7;
        		}

        	}
            break;
        case '=':
        	{
        		switch ( this->LA(2) )
        		{
        		case '>':
        			{
        				alt10=21;
        			}
        		    break;

        		default:
        		    alt10=9;
        		}

        	}
            break;
        case '(':
        	{
        		switch ( this->LA(2) )
        		{
        		case '*':
        			{
        				alt10=19;
        			}
        		    break;

        		default:
        		    alt10=10;
        		}

        	}
            break;
        case ')':
        	{
        		alt10=11;
        	}
            break;
        case '*':
        	{
        		switch ( this->LA(2) )
        		{
        		case '*':
        			{
        				alt10=12;
        			}
        		    break;
        		case ')':
        			{
        				alt10=20;
        			}
        		    break;

        		default:
        		    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        		    ex->set_decisionNum( 10 );
        		    ex->set_state( 11 );


        		    goto ruleTokensEx;

        		}

        	}
            break;
        case '{':
        	{
        		alt10=13;
        	}
            break;
        case '}':
        	{
        		alt10=14;
        	}
            break;
        case '<':
        	{
        		switch ( this->LA(2) )
        		{
        		case '-':
        		case '.':
        		case '/':
        		case '=':
        		case '>':
        		case '|':
        		case '~':
        			{
        				alt10=21;
        			}
        		    break;

        		default:
        		    alt10=15;
        		}

        	}
            break;
        case '>':
        	{
        		alt10=16;
        	}
            break;
        case ']':
        	{
        		alt10=18;
        	}
            break;
        case '-':
        case '.':
        case '~':
        	{
        		alt10=21;
        	}
            break;
        case '_':
        	{
        		switch ( this->LA(2) )
        		{
        		case '-':
        		case '<':
        		case '=':
        		case '~':
        			{
        				alt10=21;
        			}
        		    break;

        		default:
        		    alt10=22;
        		}

        	}
            break;
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':
        	{
        		alt10=22;
        	}
            break;
        case '\t':
        case '\n':
        case '\r':
        case ' ':
        	{
        		alt10=24;
        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 10 );
            ex->set_state( 0 );


            goto ruleTokensEx;

        }

        switch (alt10)
        {
    	case 1:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:10: T__27
    	    {
    	        /* 1:10: T__27 */
    	        mT__27();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 2:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:16: CONTENT
    	    {
    	        /* 1:16: CONTENT */
    	        mCONTENT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 3:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:24: ELEMTYPE
    	    {
    	        /* 1:24: ELEMTYPE */
    	        mELEMTYPE();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 4:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:33: URL
    	    {
    	        /* 1:33: URL */
    	        mURL();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 5:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:37: TRIPLESEP
    	    {
    	        /* 1:37: TRIPLESEP */
    	        mTRIPLESEP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 6:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:47: ATTRSEP
    	    {
    	        /* 1:47: ATTRSEP */
    	        mATTRSEP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 7:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:55: OBJSEP
    	    {
    	        /* 1:55: OBJSEP */
    	        mOBJSEP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 8:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:62: SENTSEP
    	    {
    	        /* 1:62: SENTSEP */
    	        mSENTSEP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 9:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:70: SYNSEP
    	    {
    	        /* 1:70: SYNSEP */
    	        mSYNSEP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 10:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:77: LPAR
    	    {
    	        /* 1:77: LPAR */
    	        mLPAR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 11:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:82: RPAR
    	    {
    	        /* 1:82: RPAR */
    	        mRPAR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 12:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:87: ALIASNONAME
    	    {
    	        /* 1:87: ALIASNONAME */
    	        mALIASNONAME();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 13:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:99: LPAR_SET
    	    {
    	        /* 1:99: LPAR_SET */
    	        mLPAR_SET();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 14:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:108: RPAR_SET
    	    {
    	        /* 1:108: RPAR_SET */
    	        mRPAR_SET();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 15:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:117: LPAR_OSET
    	    {
    	        /* 1:117: LPAR_OSET */
    	        mLPAR_OSET();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 16:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:127: RPAR_OSET
    	    {
    	        /* 1:127: RPAR_OSET */
    	        mRPAR_OSET();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 17:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:137: LPAR_TRF
    	    {
    	        /* 1:137: LPAR_TRF */
    	        mLPAR_TRF();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 18:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:146: RPAR_TRF
    	    {
    	        /* 1:146: RPAR_TRF */
    	        mRPAR_TRF();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 19:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:155: LPAR_INT
    	    {
    	        /* 1:155: LPAR_INT */
    	        mLPAR_INT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 20:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:164: RPAR_INT
    	    {
    	        /* 1:164: RPAR_INT */
    	        mRPAR_INT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 21:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:173: CONNECTORS
    	    {
    	        /* 1:173: CONNECTORS */
    	        mCONNECTORS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 22:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:184: NAME
    	    {
    	        /* 1:184: NAME */
    	        mNAME();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 23:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:189: COMMENT
    	    {
    	        /* 1:189: COMMENT */
    	        mCOMMENT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 24:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:197: WS
    	    {
    	        /* 1:197: WS */
    	        mWS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;

        }
    }


    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */

	}



/* End of code
 * =============================================================================
 */
