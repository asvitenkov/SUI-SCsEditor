/** \file
 *  This C++ source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g
 *     -                            On : 2012-12-03 14:11:17
 *     -                 for the lexer : SCsLexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SCsLexer.hpp"
/* ----------------------------------------- */



	namespace  SCsParserNS  {


/** String literals used by SCsLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR_UCHAR	lit_1[]  = { 0x5C, 0x5B,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_2[]  = { 0x5C, 0x5D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_3[]  = { 0x3B, 0x3B,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_4[]  = { 0x2A, 0x2A, 0x2A, 0x2A,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_5[]  = { 0x28, 0x2A,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_6[]  = { 0x2A, 0x29,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_7[]  = { 0x3C, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_8[]  = { 0x2E, 0x2E, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_9[]  = { 0x3C, 0x2E, 0x2E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_10[]  = { 0x2D, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_11[]  = { 0x3C, 0x2D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_12[]  = { 0x3C, 0x3D, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_13[]  = { 0x5F, 0x3C, 0x3D, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_14[]  = { 0x3D, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_15[]  = { 0x3C, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_16[]  = { 0x5F, 0x3D, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_17[]  = { 0x5F, 0x3C, 0x3D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_18[]  = { 0x5F, 0x2D, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_19[]  = { 0x5F, 0x3C, 0x2D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_20[]  = { 0x2D, 0x7C, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_21[]  = { 0x3C, 0x7C, 0x2D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_22[]  = { 0x5F, 0x2D, 0x7C, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_23[]  = { 0x5F, 0x3C, 0x7C, 0x2D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_24[]  = { 0x2D, 0x2F, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_25[]  = { 0x3C, 0x2F, 0x2D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_26[]  = { 0x5F, 0x2D, 0x2F, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_27[]  = { 0x5F, 0x3C, 0x2F, 0x2D,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_28[]  = { 0x7E, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_29[]  = { 0x3C, 0x7E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_30[]  = { 0x5F, 0x7E, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_31[]  = { 0x5F, 0x3C, 0x7E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_32[]  = { 0x7E, 0x7C, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_33[]  = { 0x3C, 0x7C, 0x7E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_34[]  = { 0x5F, 0x7E, 0x7C, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_35[]  = { 0x5F, 0x3C, 0x7C, 0x7E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_36[]  = { 0x7E, 0x2F, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_37[]  = { 0x3C, 0x2F, 0x7E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_38[]  = { 0x5F, 0x7E, 0x2F, 0x3E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_39[]  = { 0x5F, 0x3C, 0x2F, 0x7E,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_40[]  = { 0x2F, 0x2F,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_41[]  = { 0x2F, 0x21, 0x2A,  antlr3::ANTLR_STRING_TERMINATOR};
static ANTLR_UCHAR	lit_42[]  = { 0x2A, 0x2F,  antlr3::ANTLR_STRING_TERMINATOR};

	}



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

using namespace antlr3;

	namespace  SCsParserNS  {


/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



SCsLexer::~SCsLexer()
{
}

void
SCsLexer::reset()
{
    this->get_rec()->reset();
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* SCsLexer::getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called SCsLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return
 *     - Success pSCsLexer initialized for the lex start
 *     - Fail NULL
 */
SCsLexer::SCsLexer(StreamType* instream)
:SCsLexerImplTraits::BaseLexerType(ANTLR_SIZE_HINT, instream, NULL)
{
	// See if we can create a new lexer with the standard constructor
	//
	this->init(instream );
}

/** \brief Create a new lexer called SCsLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return
 *     - Success pSCsLexer initialized for the lex start
 *     - Fail NULL
 */
SCsLexer::SCsLexer(StreamType* instream, RecognizerSharedStateType* state)
:SCsLexerImplTraits::BaseLexerType(ANTLR_SIZE_HINT, instream, state)
{
	this->init(instream );
}

void SCsLexer::init(StreamType* instream)
{
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in SCsLexer.h here so you can get a sense
     * of what goes where.
     */

}

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 32:7: ( '\\\\[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__26
 *
 * Looks to match the characters the constitute the token T__26
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */





void SCsLexer::mT__26()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__26;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:32:7: ( '\\\\[' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:32:9: '\\\\['
    {
        this->matchs(lit_1);
        if  (this->hasException())
        {
            goto ruleT__26Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__26Ex; /* Prevent compiler warnings */
    ruleT__26Ex: ;

}
// $ANTLR end T__26

//   Comes from: 33:7: ( '\\\\]' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__27
 *
 * Looks to match the characters the constitute the token T__27
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mT__27()
{
    ANTLR_UINT32	_type;
      


    _type	    = T__27;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:33:7: ( '\\\\]' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:33:9: '\\\\]'
    {
        this->matchs(lit_2);
        if  (this->hasException())
        {
            goto ruleT__27Ex;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleT__27Ex; /* Prevent compiler warnings */
    ruleT__27Ex: ;

}
// $ANTLR end T__27

//   Comes from: 148:5: ( '\"' (~ ( '\"' ) )* '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start URL
 *
 * Looks to match the characters the constitute the token URL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mURL()
{
    ANTLR_UINT32	_type;
      


    _type	    = URL;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:148:5: ( '\"' (~ ( '\"' ) )* '\"' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:149:3: '\"' (~ ( '\"' ) )* '\"'
    {
         this->matchc('"');
        if  (this->hasException())
        {
            goto ruleURLEx;
        }


        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:149:7: (~ ( '\"' ) )*

        for (;;)
        {
            int alt1=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA1_0 = this->LA(1);
                if ( (((LA1_0 >= 0x0000) && (LA1_0 <= '!')) || ((LA1_0 >= '#') && (LA1_0 <= 0xFFFF))))
                {
                    alt1=1;
                }

            }
            switch (alt1)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:
        	    {
        	        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '!')) || ((this->LA(1) >= '#') && (this->LA(1) <= 0xFFFF)) )
        	        {
        	            this->consume();
        	        }
        	        else
        	        {
        	            new ANTLR_Exception< SCsLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	            this->recover();
        	            goto ruleURLEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop1;	/* break out of the loop */
        	    break;
            }
        }
        loop1: ; /* Jump out to here if this rule does not match */


         this->matchc('"');
        if  (this->hasException())
        {
            goto ruleURLEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleURLEx; /* Prevent compiler warnings */
    ruleURLEx: ;

}
// $ANTLR end URL

//   Comes from: 154:5: ( '|' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TRIPLESEP
 *
 * Looks to match the characters the constitute the token TRIPLESEP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mTRIPLESEP()
{
    ANTLR_UINT32	_type;
      


    _type	    = TRIPLESEP;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:154:5: ( '|' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:154:7: '|'
    {
         this->matchc('|');
        if  (this->hasException())
        {
            goto ruleTRIPLESEPEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleTRIPLESEPEx; /* Prevent compiler warnings */
    ruleTRIPLESEPEx: ;

}
// $ANTLR end TRIPLESEP

//   Comes from: 158:5: ( ':' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ATTRSEP
 *
 * Looks to match the characters the constitute the token ATTRSEP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mATTRSEP()
{
    ANTLR_UINT32	_type;
      


    _type	    = ATTRSEP;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:158:5: ( ':' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:158:7: ':'
    {
         this->matchc(':');
        if  (this->hasException())
        {
            goto ruleATTRSEPEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleATTRSEPEx; /* Prevent compiler warnings */
    ruleATTRSEPEx: ;

}
// $ANTLR end ATTRSEP

//   Comes from: 162:5: ( ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OBJSEP
 *
 * Looks to match the characters the constitute the token OBJSEP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mOBJSEP()
{
    ANTLR_UINT32	_type;
      


    _type	    = OBJSEP;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:162:5: ( ';' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:162:7: ';'
    {
         this->matchc(';');
        if  (this->hasException())
        {
            goto ruleOBJSEPEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleOBJSEPEx; /* Prevent compiler warnings */
    ruleOBJSEPEx: ;

}
// $ANTLR end OBJSEP

//   Comes from: 166:5: ( ';;' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SENTSEP
 *
 * Looks to match the characters the constitute the token SENTSEP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mSENTSEP()
{
    ANTLR_UINT32	_type;
      


    _type	    = SENTSEP;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:166:5: ( ';;' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:166:7: ';;'
    {
        this->matchs(lit_3);
        if  (this->hasException())
        {
            goto ruleSENTSEPEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSENTSEPEx; /* Prevent compiler warnings */
    ruleSENTSEPEx: ;

}
// $ANTLR end SENTSEP

//   Comes from: 170:5: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SYNSEP
 *
 * Looks to match the characters the constitute the token SYNSEP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mSYNSEP()
{
    ANTLR_UINT32	_type;
      


    _type	    = SYNSEP;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:170:5: ( '=' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:170:7: '='
    {
         this->matchc('=');
        if  (this->hasException())
        {
            goto ruleSYNSEPEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleSYNSEPEx; /* Prevent compiler warnings */
    ruleSYNSEPEx: ;

}
// $ANTLR end SYNSEP

//   Comes from: 174:5: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LPAR
 *
 * Looks to match the characters the constitute the token LPAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mLPAR()
{
    ANTLR_UINT32	_type;
      


    _type	    = LPAR;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:174:5: ( '(' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:174:7: '('
    {
         this->matchc('(');
        if  (this->hasException())
        {
            goto ruleLPAREx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLPAREx; /* Prevent compiler warnings */
    ruleLPAREx: ;

}
// $ANTLR end LPAR

//   Comes from: 178:5: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RPAR
 *
 * Looks to match the characters the constitute the token RPAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mRPAR()
{
    ANTLR_UINT32	_type;
      


    _type	    = RPAR;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:178:5: ( ')' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:178:7: ')'
    {
         this->matchc(')');
        if  (this->hasException())
        {
            goto ruleRPAREx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleRPAREx; /* Prevent compiler warnings */
    ruleRPAREx: ;

}
// $ANTLR end RPAR

//   Comes from: 182:5: ( '****' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ALIASNONAME
 *
 * Looks to match the characters the constitute the token ALIASNONAME
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mALIASNONAME()
{
    ANTLR_UINT32	_type;
      


    _type	    = ALIASNONAME;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:182:5: ( '****' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:182:7: '****'
    {
        this->matchs(lit_4);
        if  (this->hasException())
        {
            goto ruleALIASNONAMEEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleALIASNONAMEEx; /* Prevent compiler warnings */
    ruleALIASNONAMEEx: ;

}
// $ANTLR end ALIASNONAME

//   Comes from: 186:5: ( '{' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LPAR_SET
 *
 * Looks to match the characters the constitute the token LPAR_SET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mLPAR_SET()
{
    ANTLR_UINT32	_type;
      


    _type	    = LPAR_SET;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:186:5: ( '{' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:186:7: '{'
    {
         this->matchc('{');
        if  (this->hasException())
        {
            goto ruleLPAR_SETEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLPAR_SETEx; /* Prevent compiler warnings */
    ruleLPAR_SETEx: ;

}
// $ANTLR end LPAR_SET

//   Comes from: 190:5: ( '}' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RPAR_SET
 *
 * Looks to match the characters the constitute the token RPAR_SET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mRPAR_SET()
{
    ANTLR_UINT32	_type;
      


    _type	    = RPAR_SET;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:190:5: ( '}' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:190:7: '}'
    {
         this->matchc('}');
        if  (this->hasException())
        {
            goto ruleRPAR_SETEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleRPAR_SETEx; /* Prevent compiler warnings */
    ruleRPAR_SETEx: ;

}
// $ANTLR end RPAR_SET

//   Comes from: 194:5: ( '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LPAR_OSET
 *
 * Looks to match the characters the constitute the token LPAR_OSET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mLPAR_OSET()
{
    ANTLR_UINT32	_type;
      


    _type	    = LPAR_OSET;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:194:5: ( '<' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:194:7: '<'
    {
         this->matchc('<');
        if  (this->hasException())
        {
            goto ruleLPAR_OSETEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLPAR_OSETEx; /* Prevent compiler warnings */
    ruleLPAR_OSETEx: ;

}
// $ANTLR end LPAR_OSET

//   Comes from: 198:5: ( '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RPAR_OSET
 *
 * Looks to match the characters the constitute the token RPAR_OSET
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mRPAR_OSET()
{
    ANTLR_UINT32	_type;
      


    _type	    = RPAR_OSET;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:198:5: ( '>' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:198:7: '>'
    {
         this->matchc('>');
        if  (this->hasException())
        {
            goto ruleRPAR_OSETEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleRPAR_OSETEx; /* Prevent compiler warnings */
    ruleRPAR_OSETEx: ;

}
// $ANTLR end RPAR_OSET

//   Comes from: 202:5: ( '[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LPAR_TRF
 *
 * Looks to match the characters the constitute the token LPAR_TRF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mLPAR_TRF()
{
    ANTLR_UINT32	_type;
      


    _type	    = LPAR_TRF;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:202:5: ( '[' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:202:7: '['
    {
         this->matchc('[');
        if  (this->hasException())
        {
            goto ruleLPAR_TRFEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLPAR_TRFEx; /* Prevent compiler warnings */
    ruleLPAR_TRFEx: ;

}
// $ANTLR end LPAR_TRF

//   Comes from: 206:5: ( ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RPAR_TRF
 *
 * Looks to match the characters the constitute the token RPAR_TRF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mRPAR_TRF()
{
    ANTLR_UINT32	_type;
      


    _type	    = RPAR_TRF;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:206:5: ( ']' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:206:7: ']'
    {
         this->matchc(']');
        if  (this->hasException())
        {
            goto ruleRPAR_TRFEx;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleRPAR_TRFEx; /* Prevent compiler warnings */
    ruleRPAR_TRFEx: ;

}
// $ANTLR end RPAR_TRF

//   Comes from: 210:5: ( '(*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LPAR_INT
 *
 * Looks to match the characters the constitute the token LPAR_INT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mLPAR_INT()
{
    ANTLR_UINT32	_type;
      


    _type	    = LPAR_INT;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:210:5: ( '(*' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:210:7: '(*'
    {
        this->matchs(lit_5);
        if  (this->hasException())
        {
            goto ruleLPAR_INTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleLPAR_INTEx; /* Prevent compiler warnings */
    ruleLPAR_INTEx: ;

}
// $ANTLR end LPAR_INT

//   Comes from: 214:5: ( '*)' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RPAR_INT
 *
 * Looks to match the characters the constitute the token RPAR_INT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mRPAR_INT()
{
    ANTLR_UINT32	_type;
      


    _type	    = RPAR_INT;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:214:5: ( '*)' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:214:7: '*)'
    {
        this->matchs(lit_6);
        if  (this->hasException())
        {
            goto ruleRPAR_INTEx;
        }




    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleRPAR_INTEx; /* Prevent compiler warnings */
    ruleRPAR_INTEx: ;

}
// $ANTLR end RPAR_INT

//   Comes from: 219:13: ( '<>' | '>' | '<' | '..>' | '<..' | '->' | '<-' | '<=>' | '_<=>' | '=>' | '<=' | '_=>' | '_<=' | '_->' | '_<-' | '-|>' | '<|-' | '_-|>' | '_<|-' | '-/>' | '</-' | '_-/>' | '_</-' | '~>' | '<~' | '_~>' | '_<~' | '~|>' | '<|~' | '_~|>' | '_<|~' | '~/>' | '</~' | '_~/>' | '_</~' | '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CONNECTORS
 *
 * Looks to match the characters the constitute the token CONNECTORS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mCONNECTORS()
{
    ANTLR_UINT32	_type;
      


    _type	    = CONNECTORS;


    {
        //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:219:13: ( '<>' | '>' | '<' | '..>' | '<..' | '->' | '<-' | '<=>' | '_<=>' | '=>' | '<=' | '_=>' | '_<=' | '_->' | '_<-' | '-|>' | '<|-' | '_-|>' | '_<|-' | '-/>' | '</-' | '_-/>' | '_</-' | '~>' | '<~' | '_~>' | '_<~' | '~|>' | '<|~' | '_~|>' | '_<|~' | '~/>' | '</~' | '_~/>' | '_</~' | '=' )

        ANTLR_UINT32 alt2;

        alt2=36;

        switch ( this->LA(1) )
        {
        case '<':
        	{
        		switch ( this->LA(2) )
        		{
        		case '>':
        			{
        				alt2=1;
        			}
        		    break;
        		case '.':
        			{
        				alt2=5;
        			}
        		    break;
        		case '-':
        			{
        				alt2=7;
        			}
        		    break;
        		case '=':
        			{
        				switch ( this->LA(3) )
        				{
        				case '>':
        					{
        						alt2=8;
        					}
        				    break;

        				default:
        				    alt2=11;
        				}

        			}
        		    break;
        		case '|':
        			{
        				switch ( this->LA(3) )
        				{
        				case '-':
        					{
        						alt2=17;
        					}
        				    break;
        				case '~':
        					{
        						alt2=29;
        					}
        				    break;

        				default:
        				    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        				    ex->set_decisionNum( 2 );
        				    ex->set_state( 12 );


        				    goto ruleCONNECTORSEx;

        				}

        			}
        		    break;
        		case '/':
        			{
        				switch ( this->LA(3) )
        				{
        				case '-':
        					{
        						alt2=21;
        					}
        				    break;
        				case '~':
        					{
        						alt2=33;
        					}
        				    break;

        				default:
        				    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        				    ex->set_decisionNum( 2 );
        				    ex->set_state( 13 );


        				    goto ruleCONNECTORSEx;

        				}

        			}
        		    break;
        		case '~':
        			{
        				alt2=25;
        			}
        		    break;

        		default:
        		    alt2=3;
        		}

        	}
            break;
        case '>':
        	{
        		alt2=2;
        	}
            break;
        case '.':
        	{
        		alt2=4;
        	}
            break;
        case '-':
        	{
        		switch ( this->LA(2) )
        		{
        		case '>':
        			{
        				alt2=6;
        			}
        		    break;
        		case '|':
        			{
        				alt2=16;
        			}
        		    break;
        		case '/':
        			{
        				alt2=20;
        			}
        		    break;

        		default:
        		    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        		    ex->set_decisionNum( 2 );
        		    ex->set_state( 4 );


        		    goto ruleCONNECTORSEx;

        		}

        	}
            break;
        case '_':
        	{
        		switch ( this->LA(2) )
        		{
        		case '<':
        			{
        				switch ( this->LA(3) )
        				{
        				case '=':
        					{
        						switch ( this->LA(4) )
        						{
        						case '>':
        							{
        								alt2=9;
        							}
        						    break;

        						default:
        						    alt2=13;
        						}

        					}
        				    break;
        				case '-':
        					{
        						alt2=15;
        					}
        				    break;
        				case '|':
        					{
        						switch ( this->LA(4) )
        						{
        						case '-':
        							{
        								alt2=19;
        							}
        						    break;
        						case '~':
        							{
        								alt2=31;
        							}
        						    break;

        						default:
        						    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        						    ex->set_decisionNum( 2 );
        						    ex->set_state( 36 );


        						    goto ruleCONNECTORSEx;

        						}

        					}
        				    break;
        				case '/':
        					{
        						switch ( this->LA(4) )
        						{
        						case '-':
        							{
        								alt2=23;
        							}
        						    break;
        						case '~':
        							{
        								alt2=35;
        							}
        						    break;

        						default:
        						    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        						    ex->set_decisionNum( 2 );
        						    ex->set_state( 37 );


        						    goto ruleCONNECTORSEx;

        						}

        					}
        				    break;
        				case '~':
        					{
        						alt2=27;
        					}
        				    break;

        				default:
        				    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        				    ex->set_decisionNum( 2 );
        				    ex->set_state( 19 );


        				    goto ruleCONNECTORSEx;

        				}

        			}
        		    break;
        		case '=':
        			{
        				alt2=12;
        			}
        		    break;
        		case '-':
        			{
        				switch ( this->LA(3) )
        				{
        				case '>':
        					{
        						alt2=14;
        					}
        				    break;
        				case '|':
        					{
        						alt2=18;
        					}
        				    break;
        				case '/':
        					{
        						alt2=22;
        					}
        				    break;

        				default:
        				    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        				    ex->set_decisionNum( 2 );
        				    ex->set_state( 21 );


        				    goto ruleCONNECTORSEx;

        				}

        			}
        		    break;
        		case '~':
        			{
        				switch ( this->LA(3) )
        				{
        				case '>':
        					{
        						alt2=26;
        					}
        				    break;
        				case '|':
        					{
        						alt2=30;
        					}
        				    break;
        				case '/':
        					{
        						alt2=34;
        					}
        				    break;

        				default:
        				    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        				    ex->set_decisionNum( 2 );
        				    ex->set_state( 22 );


        				    goto ruleCONNECTORSEx;

        				}

        			}
        		    break;

        		default:
        		    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        		    ex->set_decisionNum( 2 );
        		    ex->set_state( 5 );


        		    goto ruleCONNECTORSEx;

        		}

        	}
            break;
        case '=':
        	{
        		switch ( this->LA(2) )
        		{
        		case '>':
        			{
        				alt2=10;
        			}
        		    break;

        		default:
        		    alt2=36;
        		}

        	}
            break;
        case '~':
        	{
        		switch ( this->LA(2) )
        		{
        		case '>':
        			{
        				alt2=24;
        			}
        		    break;
        		case '|':
        			{
        				alt2=28;
        			}
        		    break;
        		case '/':
        			{
        				alt2=32;
        			}
        		    break;

        		default:
        		    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        		    ex->set_decisionNum( 2 );
        		    ex->set_state( 7 );


        		    goto ruleCONNECTORSEx;

        		}

        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 2 );
            ex->set_state( 0 );


            goto ruleCONNECTORSEx;

        }

        switch (alt2)
        {
    	case 1:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:220:17: '<>'
    	    {
    	        this->matchs(lit_7);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 2:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:221:17: '>'
    	    {
    	         this->matchc('>');
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }


    	    }
    	    break;
    	case 3:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:222:17: '<'
    	    {
    	         this->matchc('<');
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }


    	    }
    	    break;
    	case 4:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:223:17: '..>'
    	    {
    	        this->matchs(lit_8);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 5:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:224:17: '<..'
    	    {
    	        this->matchs(lit_9);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 6:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:225:17: '->'
    	    {
    	        this->matchs(lit_10);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 7:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:226:17: '<-'
    	    {
    	        this->matchs(lit_11);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 8:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:227:17: '<=>'
    	    {
    	        this->matchs(lit_12);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 9:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:228:17: '_<=>'
    	    {
    	        this->matchs(lit_13);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 10:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:229:17: '=>'
    	    {
    	        this->matchs(lit_14);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 11:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:230:17: '<='
    	    {
    	        this->matchs(lit_15);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 12:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:231:17: '_=>'
    	    {
    	        this->matchs(lit_16);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 13:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:232:17: '_<='
    	    {
    	        this->matchs(lit_17);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 14:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:233:17: '_->'
    	    {
    	        this->matchs(lit_18);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 15:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:234:17: '_<-'
    	    {
    	        this->matchs(lit_19);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 16:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:235:17: '-|>'
    	    {
    	        this->matchs(lit_20);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 17:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:236:17: '<|-'
    	    {
    	        this->matchs(lit_21);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 18:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:237:17: '_-|>'
    	    {
    	        this->matchs(lit_22);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 19:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:238:17: '_<|-'
    	    {
    	        this->matchs(lit_23);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 20:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:239:17: '-/>'
    	    {
    	        this->matchs(lit_24);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 21:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:240:17: '</-'
    	    {
    	        this->matchs(lit_25);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 22:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:241:17: '_-/>'
    	    {
    	        this->matchs(lit_26);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 23:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:242:17: '_</-'
    	    {
    	        this->matchs(lit_27);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 24:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:243:17: '~>'
    	    {
    	        this->matchs(lit_28);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 25:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:244:17: '<~'
    	    {
    	        this->matchs(lit_29);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 26:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:245:17: '_~>'
    	    {
    	        this->matchs(lit_30);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 27:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:246:17: '_<~'
    	    {
    	        this->matchs(lit_31);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 28:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:247:17: '~|>'
    	    {
    	        this->matchs(lit_32);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 29:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:248:17: '<|~'
    	    {
    	        this->matchs(lit_33);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 30:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:249:17: '_~|>'
    	    {
    	        this->matchs(lit_34);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 31:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:250:17: '_<|~'
    	    {
    	        this->matchs(lit_35);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 32:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:251:17: '~/>'
    	    {
    	        this->matchs(lit_36);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 33:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:252:17: '</~'
    	    {
    	        this->matchs(lit_37);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 34:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:253:17: '_~/>'
    	    {
    	        this->matchs(lit_38);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 35:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:254:17: '_</~'
    	    {
    	        this->matchs(lit_39);
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }




    	    }
    	    break;
    	case 36:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:255:17: '='
    	    {
    	         this->matchc('=');
    	        if  (this->hasException())
    	        {
    	            goto ruleCONNECTORSEx;
    	        }


    	    }
    	    break;

        }
    }
	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCONNECTORSEx; /* Prevent compiler warnings */
    ruleCONNECTORSEx: ;

}
// $ANTLR end CONNECTORS

//   Comes from: 259:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '*' | '_' | '.' | UNICODE_CHAR | '(' | ')' | '#' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NAME
 *
 * Looks to match the characters the constitute the token NAME
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mNAME()
{
    ANTLR_UINT32	_type;
      


    _type	    = NAME;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:259:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '*' | '_' | '.' | UNICODE_CHAR | '(' | ')' | '#' )+ )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:259:10: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '*' | '_' | '.' | UNICODE_CHAR | '(' | ')' | '#' )+
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:259:10: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '*' | '_' | '.' | UNICODE_CHAR | '(' | ')' | '#' )+
        {
            int cnt3=0;

            for (;;)
            {
                int alt3=2;
        	switch ( this->LA(1) )
        	{
        	case '#':
        	case '(':
        	case ')':
        	case '*':
        	case '.':
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        	case 'A':
        	case 'B':
        	case 'C':
        	case 'D':
        	case 'E':
        	case 'F':
        	case 'G':
        	case 'H':
        	case 'I':
        	case 'J':
        	case 'K':
        	case 'L':
        	case 'M':
        	case 'N':
        	case 'O':
        	case 'P':
        	case 'Q':
        	case 'R':
        	case 'S':
        	case 'T':
        	case 'U':
        	case 'V':
        	case 'W':
        	case 'X':
        	case 'Y':
        	case 'Z':
        	case '_':
        	case 'a':
        	case 'b':
        	case 'c':
        	case 'd':
        	case 'e':
        	case 'f':
        	case 'g':
        	case 'h':
        	case 'i':
        	case 'j':
        	case 'k':
        	case 'l':
        	case 'm':
        	case 'n':
        	case 'o':
        	case 'p':
        	case 'q':
        	case 'r':
        	case 's':
        	case 't':
        	case 'u':
        	case 'v':
        	case 'w':
        	case 'x':
        	case 'y':
        	case 'z':
        	case 0x0410:
        	case 0x0411:
        	case 0x0412:
        	case 0x0413:
        	case 0x0414:
        	case 0x0415:
        	case 0x0416:
        	case 0x0417:
        	case 0x0418:
        	case 0x0419:
        	case 0x041A:
        	case 0x041B:
        	case 0x041C:
        	case 0x041D:
        	case 0x041E:
        	case 0x041F:
        	case 0x0420:
        	case 0x0421:
        	case 0x0422:
        	case 0x0423:
        	case 0x0424:
        	case 0x0425:
        	case 0x0426:
        	case 0x0427:
        	case 0x0428:
        	case 0x0429:
        	case 0x042A:
        	case 0x042B:
        	case 0x042C:
        	case 0x042D:
        	case 0x042E:
        	case 0x042F:
        	case 0x0430:
        	case 0x0431:
        	case 0x0432:
        	case 0x0433:
        	case 0x0434:
        	case 0x0435:
        	case 0x0436:
        	case 0x0437:
        	case 0x0438:
        	case 0x0439:
        	case 0x043A:
        	case 0x043B:
        	case 0x043C:
        	case 0x043D:
        	case 0x043E:
        	case 0x043F:
        	case 0x0440:
        	case 0x0441:
        	case 0x0442:
        	case 0x0443:
        	case 0x0444:
        	case 0x0445:
        	case 0x0446:
        	case 0x0447:
        	case 0x0448:
        	case 0x0449:
        	case 0x044A:
        	case 0x044B:
        	case 0x044C:
        	case 0x044D:
        	case 0x044E:
        	case 0x044F:
        		{
        			alt3=1;
        		}
        	    break;

        	}

        	switch (alt3)
        	{
        	    case 1:
        	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:
        	        {
        	            if ( this->LA(1) == '#' || ((this->LA(1) >= '(') && (this->LA(1) <= '*')) || this->LA(1) == '.' || ((this->LA(1) >= '0') && (this->LA(1) <= '9')) || ((this->LA(1) >= 'A') && (this->LA(1) <= 'Z')) || this->LA(1) == '_' || ((this->LA(1) >= 'a') && (this->LA(1) <= 'z')) || ((this->LA(1) >= 0x0410) && (this->LA(1) <= 0x044F)) )
        	            {
        	                this->consume();
        	            }
        	            else
        	            {
        	                new ANTLR_Exception< SCsLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

        	                this->recover();
        	                goto ruleNAMEEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt3 >= 1 )
        		{
        		    goto loop3;
        		}
        		/* mismatchedSetEx()
        		 */
        		new ANTLR_Exception< SCsLexerImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


        		goto ruleNAMEEx;
        	}
        	cnt3++;
            }
            loop3: ;	/* Jump to here if this rule does not match */
        }

    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleNAMEEx; /* Prevent compiler warnings */
    ruleNAMEEx: ;

}
// $ANTLR end NAME

//   Comes from: 263:5: ( '\\u0410' .. '\\u044F' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNICODE_CHAR
 *
 * Looks to match the characters the constitute the token UNICODE_CHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mUNICODE_CHAR()
{
    ANTLR_UINT32	_type;
      



    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:263:5: ( '\\u0410' .. '\\u044F' )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:
    {
        if ( ((this->LA(1) >= 0x0410) && (this->LA(1) <= 0x044F)) )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< SCsLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleUNICODE_CHAREx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleUNICODE_CHAREx; /* Prevent compiler warnings */
    ruleUNICODE_CHAREx: ;

}
// $ANTLR end UNICODE_CHAR

//   Comes from: 267:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' | '/!*' ( options {greedy=false; } : . )* '*/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT
 *
 * Looks to match the characters the constitute the token COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mCOMMENT()
{
    ANTLR_UINT32	_type;
      


    _type	    = COMMENT;


    {
        //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:267:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' | '/!*' ( options {greedy=false; } : . )* '*/' )

        ANTLR_UINT32 alt7;

        alt7=2;

        switch ( this->LA(1) )
        {
        case '/':
        	{
        		switch ( this->LA(2) )
        		{
        		case '/':
        			{
        				alt7=1;
        			}
        		    break;
        		case '!':
        			{
        				alt7=2;
        			}
        		    break;

        		default:
        		    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        		    ex->set_decisionNum( 7 );
        		    ex->set_state( 1 );


        		    goto ruleCOMMENTEx;

        		}

        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 7 );
            ex->set_state( 0 );


            goto ruleCOMMENTEx;

        }

        switch (alt7)
        {
    	case 1:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:267:9: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
    	    {
    	        this->matchs(lit_40);
    	        if  (this->hasException())
    	        {
    	            goto ruleCOMMENTEx;
    	        }




    	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:267:14: (~ ( '\\n' | '\\r' ) )*

    	        for (;;)
    	        {
    	            int alt4=2;
    	            {
    	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                */
    	                int LA4_0 = this->LA(1);
    	                if ( (((LA4_0 >= 0x0000) && (LA4_0 <= '\t')) || ((LA4_0 >= 0x000B) && (LA4_0 <= '\f')) || ((LA4_0 >= 0x000E) && (LA4_0 <= 0xFFFF))))
    	                {
    	                    alt4=1;
    	                }

    	            }
    	            switch (alt4)
    	            {
    	        	case 1:
    	        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:
    	        	    {
    	        	        if ( ((this->LA(1) >= 0x0000) && (this->LA(1) <= '\t')) || ((this->LA(1) >= 0x000B) && (this->LA(1) <= '\f')) || ((this->LA(1) >= 0x000E) && (this->LA(1) <= 0xFFFF)) )
    	        	        {
    	        	            this->consume();
    	        	        }
    	        	        else
    	        	        {
    	        	            new ANTLR_Exception< SCsLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

    	        	            this->recover();
    	        	            goto ruleCOMMENTEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop4;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop4: ; /* Jump out to here if this rule does not match */


    	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:267:28: ( '\\r' )?
    	        {
    	            int alt5=2;
    	            switch ( this->LA(1) )
    	            {
    	                case '\r':
    	                	{
    	                		alt5=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt5)
    	            {
    	        	case 1:
    	        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:267:28: '\\r'
    	        	    {
    	        	         this->matchc('\r');
    	        	        if  (this->hasException())
    	        	        {
    	        	            goto ruleCOMMENTEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }

    	         this->matchc('\n');
    	        if  (this->hasException())
    	        {
    	            goto ruleCOMMENTEx;
    	        }


    	        {
    	            this->get_state()->get_channel()=HIDDEN;
    	        }


    	    }
    	    break;
    	case 2:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:268:9: '/!*' ( options {greedy=false; } : . )* '*/'
    	    {
    	        this->matchs(lit_41);
    	        if  (this->hasException())
    	        {
    	            goto ruleCOMMENTEx;
    	        }




    	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:268:15: ( options {greedy=false; } : . )*

    	        for (;;)
    	        {
    	            int alt6=2;
    	            {
    	               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                */
    	                int LA6_0 = this->LA(1);
    	                if ( (LA6_0 == '*'))
    	                {
    	                    {
    	                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    	                        */
    	                        int LA6_1 = this->LA(2);
    	                        if ( (LA6_1 == '/'))
    	                        {
    	                            alt6=2;
    	                        }
    	                        else if ( (((LA6_1 >= 0x0000) && (LA6_1 <= '.')) || ((LA6_1 >= '0') && (LA6_1 <= 0xFFFF))))
    	                        {
    	                            alt6=1;
    	                        }

    	                    }
    	                }
    	                else if ( (((LA6_0 >= 0x0000) && (LA6_0 <= ')')) || ((LA6_0 >= '+') && (LA6_0 <= 0xFFFF))))
    	                {
    	                    alt6=1;
    	                }

    	            }
    	            switch (alt6)
    	            {
    	        	case 1:
    	        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:268:43: .
    	        	    {
    	        	        this->matchAny();
    	        	        if  (this->hasException())
    	        	        {
    	        	            goto ruleCOMMENTEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop6;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop6: ; /* Jump out to here if this rule does not match */


    	        this->matchs(lit_42);
    	        if  (this->hasException())
    	        {
    	            goto ruleCOMMENTEx;
    	        }




    	        {
    	            this->get_state()->get_channel()=HIDDEN;
    	        }


    	    }
    	    break;

        }
    }
	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleCOMMENTEx; /* Prevent compiler warnings */
    ruleCOMMENTEx: ;

}
// $ANTLR end COMMENT

//   Comes from: 271:5: ( ( ' ' | '\\t' | '\\r' | '\\n' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WS
 *
 * Looks to match the characters the constitute the token WS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == true if an exception was thrown.
 */
void SCsLexer::mWS()
{
    ANTLR_UINT32	_type;
      


    _type	    = WS;


    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:271:5: ( ( ' ' | '\\t' | '\\r' | '\\n' ) )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:271:9: ( ' ' | '\\t' | '\\r' | '\\n' )
    {
        if ( ((this->LA(1) >= '\t') && (this->LA(1) <= '\n')) || this->LA(1) == '\r' || this->LA(1) == ' ' )
        {
            this->consume();
        }
        else
        {
            new ANTLR_Exception< SCsLexerImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );

            this->recover();
            goto ruleWSEx;
        }


        {
            this->get_state()->get_channel()=HIDDEN;
        }


    }

	this->get_lexstate()->set_type(_type);
    // This is where rules clean up and exit
    //
    goto ruleWSEx; /* Prevent compiler warnings */
    ruleWSEx: ;

}
// $ANTLR end WS

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
void
SCsLexer::mTokens()
{
    {
        //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:8: ( T__26 | T__27 | URL | TRIPLESEP | ATTRSEP | OBJSEP | SENTSEP | SYNSEP | LPAR | RPAR | ALIASNONAME | LPAR_SET | RPAR_SET | LPAR_OSET | RPAR_OSET | LPAR_TRF | RPAR_TRF | LPAR_INT | RPAR_INT | CONNECTORS | NAME | COMMENT | WS )

        ANTLR_UINT32 alt8;

        alt8=23;

        switch ( this->LA(1) )
        {
        case '\\':
        	{
        		switch ( this->LA(2) )
        		{
        		case '[':
        			{
        				alt8=1;
        			}
        		    break;
        		case ']':
        			{
        				alt8=2;
        			}
        		    break;

        		default:
        		    ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
        		    ex->set_decisionNum( 8 );
        		    ex->set_state( 1 );


        		    goto ruleTokensEx;

        		}

        	}
            break;
        case '"':
        	{
        		alt8=3;
        	}
            break;
        case '|':
        	{
        		alt8=4;
        	}
            break;
        case ':':
        	{
        		alt8=5;
        	}
            break;
        case ';':
        	{
        		switch ( this->LA(2) )
        		{
        		case ';':
        			{
        				alt8=7;
        			}
        		    break;

        		default:
        		    alt8=6;
        		}

        	}
            break;
        case '=':
        	{
        		switch ( this->LA(2) )
        		{
        		case '>':
        			{
        				alt8=20;
        			}
        		    break;

        		default:
        		    alt8=8;
        		}

        	}
            break;
        case '(':
        	{
        		switch ( this->LA(2) )
        		{
        		case '*':
        			{
        				switch ( this->LA(3) )
        				{
        				case '#':
        				case '(':
        				case ')':
        				case '*':
        				case '.':
        				case '0':
        				case '1':
        				case '2':
        				case '3':
        				case '4':
        				case '5':
        				case '6':
        				case '7':
        				case '8':
        				case '9':
        				case 'A':
        				case 'B':
        				case 'C':
        				case 'D':
        				case 'E':
        				case 'F':
        				case 'G':
        				case 'H':
        				case 'I':
        				case 'J':
        				case 'K':
        				case 'L':
        				case 'M':
        				case 'N':
        				case 'O':
        				case 'P':
        				case 'Q':
        				case 'R':
        				case 'S':
        				case 'T':
        				case 'U':
        				case 'V':
        				case 'W':
        				case 'X':
        				case 'Y':
        				case 'Z':
        				case '_':
        				case 'a':
        				case 'b':
        				case 'c':
        				case 'd':
        				case 'e':
        				case 'f':
        				case 'g':
        				case 'h':
        				case 'i':
        				case 'j':
        				case 'k':
        				case 'l':
        				case 'm':
        				case 'n':
        				case 'o':
        				case 'p':
        				case 'q':
        				case 'r':
        				case 's':
        				case 't':
        				case 'u':
        				case 'v':
        				case 'w':
        				case 'x':
        				case 'y':
        				case 'z':
        				case 0x0410:
        				case 0x0411:
        				case 0x0412:
        				case 0x0413:
        				case 0x0414:
        				case 0x0415:
        				case 0x0416:
        				case 0x0417:
        				case 0x0418:
        				case 0x0419:
        				case 0x041A:
        				case 0x041B:
        				case 0x041C:
        				case 0x041D:
        				case 0x041E:
        				case 0x041F:
        				case 0x0420:
        				case 0x0421:
        				case 0x0422:
        				case 0x0423:
        				case 0x0424:
        				case 0x0425:
        				case 0x0426:
        				case 0x0427:
        				case 0x0428:
        				case 0x0429:
        				case 0x042A:
        				case 0x042B:
        				case 0x042C:
        				case 0x042D:
        				case 0x042E:
        				case 0x042F:
        				case 0x0430:
        				case 0x0431:
        				case 0x0432:
        				case 0x0433:
        				case 0x0434:
        				case 0x0435:
        				case 0x0436:
        				case 0x0437:
        				case 0x0438:
        				case 0x0439:
        				case 0x043A:
        				case 0x043B:
        				case 0x043C:
        				case 0x043D:
        				case 0x043E:
        				case 0x043F:
        				case 0x0440:
        				case 0x0441:
        				case 0x0442:
        				case 0x0443:
        				case 0x0444:
        				case 0x0445:
        				case 0x0446:
        				case 0x0447:
        				case 0x0448:
        				case 0x0449:
        				case 0x044A:
        				case 0x044B:
        				case 0x044C:
        				case 0x044D:
        				case 0x044E:
        				case 0x044F:
        					{
        						alt8=21;
        					}
        				    break;

        				default:
        				    alt8=18;
        				}

        			}
        		    break;
        		case '#':
        		case '(':
        		case ')':
        		case '.':
        		case '0':
        		case '1':
        		case '2':
        		case '3':
        		case '4':
        		case '5':
        		case '6':
        		case '7':
        		case '8':
        		case '9':
        		case 'A':
        		case 'B':
        		case 'C':
        		case 'D':
        		case 'E':
        		case 'F':
        		case 'G':
        		case 'H':
        		case 'I':
        		case 'J':
        		case 'K':
        		case 'L':
        		case 'M':
        		case 'N':
        		case 'O':
        		case 'P':
        		case 'Q':
        		case 'R':
        		case 'S':
        		case 'T':
        		case 'U':
        		case 'V':
        		case 'W':
        		case 'X':
        		case 'Y':
        		case 'Z':
        		case '_':
        		case 'a':
        		case 'b':
        		case 'c':
        		case 'd':
        		case 'e':
        		case 'f':
        		case 'g':
        		case 'h':
        		case 'i':
        		case 'j':
        		case 'k':
        		case 'l':
        		case 'm':
        		case 'n':
        		case 'o':
        		case 'p':
        		case 'q':
        		case 'r':
        		case 's':
        		case 't':
        		case 'u':
        		case 'v':
        		case 'w':
        		case 'x':
        		case 'y':
        		case 'z':
        		case 0x0410:
        		case 0x0411:
        		case 0x0412:
        		case 0x0413:
        		case 0x0414:
        		case 0x0415:
        		case 0x0416:
        		case 0x0417:
        		case 0x0418:
        		case 0x0419:
        		case 0x041A:
        		case 0x041B:
        		case 0x041C:
        		case 0x041D:
        		case 0x041E:
        		case 0x041F:
        		case 0x0420:
        		case 0x0421:
        		case 0x0422:
        		case 0x0423:
        		case 0x0424:
        		case 0x0425:
        		case 0x0426:
        		case 0x0427:
        		case 0x0428:
        		case 0x0429:
        		case 0x042A:
        		case 0x042B:
        		case 0x042C:
        		case 0x042D:
        		case 0x042E:
        		case 0x042F:
        		case 0x0430:
        		case 0x0431:
        		case 0x0432:
        		case 0x0433:
        		case 0x0434:
        		case 0x0435:
        		case 0x0436:
        		case 0x0437:
        		case 0x0438:
        		case 0x0439:
        		case 0x043A:
        		case 0x043B:
        		case 0x043C:
        		case 0x043D:
        		case 0x043E:
        		case 0x043F:
        		case 0x0440:
        		case 0x0441:
        		case 0x0442:
        		case 0x0443:
        		case 0x0444:
        		case 0x0445:
        		case 0x0446:
        		case 0x0447:
        		case 0x0448:
        		case 0x0449:
        		case 0x044A:
        		case 0x044B:
        		case 0x044C:
        		case 0x044D:
        		case 0x044E:
        		case 0x044F:
        			{
        				alt8=21;
        			}
        		    break;

        		default:
        		    alt8=9;
        		}

        	}
            break;
        case ')':
        	{
        		switch ( this->LA(2) )
        		{
        		case '#':
        		case '(':
        		case ')':
        		case '*':
        		case '.':
        		case '0':
        		case '1':
        		case '2':
        		case '3':
        		case '4':
        		case '5':
        		case '6':
        		case '7':
        		case '8':
        		case '9':
        		case 'A':
        		case 'B':
        		case 'C':
        		case 'D':
        		case 'E':
        		case 'F':
        		case 'G':
        		case 'H':
        		case 'I':
        		case 'J':
        		case 'K':
        		case 'L':
        		case 'M':
        		case 'N':
        		case 'O':
        		case 'P':
        		case 'Q':
        		case 'R':
        		case 'S':
        		case 'T':
        		case 'U':
        		case 'V':
        		case 'W':
        		case 'X':
        		case 'Y':
        		case 'Z':
        		case '_':
        		case 'a':
        		case 'b':
        		case 'c':
        		case 'd':
        		case 'e':
        		case 'f':
        		case 'g':
        		case 'h':
        		case 'i':
        		case 'j':
        		case 'k':
        		case 'l':
        		case 'm':
        		case 'n':
        		case 'o':
        		case 'p':
        		case 'q':
        		case 'r':
        		case 's':
        		case 't':
        		case 'u':
        		case 'v':
        		case 'w':
        		case 'x':
        		case 'y':
        		case 'z':
        		case 0x0410:
        		case 0x0411:
        		case 0x0412:
        		case 0x0413:
        		case 0x0414:
        		case 0x0415:
        		case 0x0416:
        		case 0x0417:
        		case 0x0418:
        		case 0x0419:
        		case 0x041A:
        		case 0x041B:
        		case 0x041C:
        		case 0x041D:
        		case 0x041E:
        		case 0x041F:
        		case 0x0420:
        		case 0x0421:
        		case 0x0422:
        		case 0x0423:
        		case 0x0424:
        		case 0x0425:
        		case 0x0426:
        		case 0x0427:
        		case 0x0428:
        		case 0x0429:
        		case 0x042A:
        		case 0x042B:
        		case 0x042C:
        		case 0x042D:
        		case 0x042E:
        		case 0x042F:
        		case 0x0430:
        		case 0x0431:
        		case 0x0432:
        		case 0x0433:
        		case 0x0434:
        		case 0x0435:
        		case 0x0436:
        		case 0x0437:
        		case 0x0438:
        		case 0x0439:
        		case 0x043A:
        		case 0x043B:
        		case 0x043C:
        		case 0x043D:
        		case 0x043E:
        		case 0x043F:
        		case 0x0440:
        		case 0x0441:
        		case 0x0442:
        		case 0x0443:
        		case 0x0444:
        		case 0x0445:
        		case 0x0446:
        		case 0x0447:
        		case 0x0448:
        		case 0x0449:
        		case 0x044A:
        		case 0x044B:
        		case 0x044C:
        		case 0x044D:
        		case 0x044E:
        		case 0x044F:
        			{
        				alt8=21;
        			}
        		    break;

        		default:
        		    alt8=10;
        		}

        	}
            break;
        case '*':
        	{
        		switch ( this->LA(2) )
        		{
        		case '*':
        			{
        				switch ( this->LA(3) )
        				{
        				case '*':
        					{
        						switch ( this->LA(4) )
        						{
        						case '*':
        							{
        								switch ( this->LA(5) )
        								{
        								case '#':
        								case '(':
        								case ')':
        								case '*':
        								case '.':
        								case '0':
        								case '1':
        								case '2':
        								case '3':
        								case '4':
        								case '5':
        								case '6':
        								case '7':
        								case '8':
        								case '9':
        								case 'A':
        								case 'B':
        								case 'C':
        								case 'D':
        								case 'E':
        								case 'F':
        								case 'G':
        								case 'H':
        								case 'I':
        								case 'J':
        								case 'K':
        								case 'L':
        								case 'M':
        								case 'N':
        								case 'O':
        								case 'P':
        								case 'Q':
        								case 'R':
        								case 'S':
        								case 'T':
        								case 'U':
        								case 'V':
        								case 'W':
        								case 'X':
        								case 'Y':
        								case 'Z':
        								case '_':
        								case 'a':
        								case 'b':
        								case 'c':
        								case 'd':
        								case 'e':
        								case 'f':
        								case 'g':
        								case 'h':
        								case 'i':
        								case 'j':
        								case 'k':
        								case 'l':
        								case 'm':
        								case 'n':
        								case 'o':
        								case 'p':
        								case 'q':
        								case 'r':
        								case 's':
        								case 't':
        								case 'u':
        								case 'v':
        								case 'w':
        								case 'x':
        								case 'y':
        								case 'z':
        								case 0x0410:
        								case 0x0411:
        								case 0x0412:
        								case 0x0413:
        								case 0x0414:
        								case 0x0415:
        								case 0x0416:
        								case 0x0417:
        								case 0x0418:
        								case 0x0419:
        								case 0x041A:
        								case 0x041B:
        								case 0x041C:
        								case 0x041D:
        								case 0x041E:
        								case 0x041F:
        								case 0x0420:
        								case 0x0421:
        								case 0x0422:
        								case 0x0423:
        								case 0x0424:
        								case 0x0425:
        								case 0x0426:
        								case 0x0427:
        								case 0x0428:
        								case 0x0429:
        								case 0x042A:
        								case 0x042B:
        								case 0x042C:
        								case 0x042D:
        								case 0x042E:
        								case 0x042F:
        								case 0x0430:
        								case 0x0431:
        								case 0x0432:
        								case 0x0433:
        								case 0x0434:
        								case 0x0435:
        								case 0x0436:
        								case 0x0437:
        								case 0x0438:
        								case 0x0439:
        								case 0x043A:
        								case 0x043B:
        								case 0x043C:
        								case 0x043D:
        								case 0x043E:
        								case 0x043F:
        								case 0x0440:
        								case 0x0441:
        								case 0x0442:
        								case 0x0443:
        								case 0x0444:
        								case 0x0445:
        								case 0x0446:
        								case 0x0447:
        								case 0x0448:
        								case 0x0449:
        								case 0x044A:
        								case 0x044B:
        								case 0x044C:
        								case 0x044D:
        								case 0x044E:
        								case 0x044F:
        									{
        										alt8=21;
        									}
        								    break;

        								default:
        								    alt8=11;
        								}

        							}
        						    break;

        						default:
        						    alt8=21;
        						}

        					}
        				    break;

        				default:
        				    alt8=21;
        				}

        			}
        		    break;
        		case ')':
        			{
        				switch ( this->LA(3) )
        				{
        				case '#':
        				case '(':
        				case ')':
        				case '*':
        				case '.':
        				case '0':
        				case '1':
        				case '2':
        				case '3':
        				case '4':
        				case '5':
        				case '6':
        				case '7':
        				case '8':
        				case '9':
        				case 'A':
        				case 'B':
        				case 'C':
        				case 'D':
        				case 'E':
        				case 'F':
        				case 'G':
        				case 'H':
        				case 'I':
        				case 'J':
        				case 'K':
        				case 'L':
        				case 'M':
        				case 'N':
        				case 'O':
        				case 'P':
        				case 'Q':
        				case 'R':
        				case 'S':
        				case 'T':
        				case 'U':
        				case 'V':
        				case 'W':
        				case 'X':
        				case 'Y':
        				case 'Z':
        				case '_':
        				case 'a':
        				case 'b':
        				case 'c':
        				case 'd':
        				case 'e':
        				case 'f':
        				case 'g':
        				case 'h':
        				case 'i':
        				case 'j':
        				case 'k':
        				case 'l':
        				case 'm':
        				case 'n':
        				case 'o':
        				case 'p':
        				case 'q':
        				case 'r':
        				case 's':
        				case 't':
        				case 'u':
        				case 'v':
        				case 'w':
        				case 'x':
        				case 'y':
        				case 'z':
        				case 0x0410:
        				case 0x0411:
        				case 0x0412:
        				case 0x0413:
        				case 0x0414:
        				case 0x0415:
        				case 0x0416:
        				case 0x0417:
        				case 0x0418:
        				case 0x0419:
        				case 0x041A:
        				case 0x041B:
        				case 0x041C:
        				case 0x041D:
        				case 0x041E:
        				case 0x041F:
        				case 0x0420:
        				case 0x0421:
        				case 0x0422:
        				case 0x0423:
        				case 0x0424:
        				case 0x0425:
        				case 0x0426:
        				case 0x0427:
        				case 0x0428:
        				case 0x0429:
        				case 0x042A:
        				case 0x042B:
        				case 0x042C:
        				case 0x042D:
        				case 0x042E:
        				case 0x042F:
        				case 0x0430:
        				case 0x0431:
        				case 0x0432:
        				case 0x0433:
        				case 0x0434:
        				case 0x0435:
        				case 0x0436:
        				case 0x0437:
        				case 0x0438:
        				case 0x0439:
        				case 0x043A:
        				case 0x043B:
        				case 0x043C:
        				case 0x043D:
        				case 0x043E:
        				case 0x043F:
        				case 0x0440:
        				case 0x0441:
        				case 0x0442:
        				case 0x0443:
        				case 0x0444:
        				case 0x0445:
        				case 0x0446:
        				case 0x0447:
        				case 0x0448:
        				case 0x0449:
        				case 0x044A:
        				case 0x044B:
        				case 0x044C:
        				case 0x044D:
        				case 0x044E:
        				case 0x044F:
        					{
        						alt8=21;
        					}
        				    break;

        				default:
        				    alt8=19;
        				}

        			}
        		    break;

        		default:
        		    alt8=21;
        		}

        	}
            break;
        case '{':
        	{
        		alt8=12;
        	}
            break;
        case '}':
        	{
        		alt8=13;
        	}
            break;
        case '<':
        	{
        		switch ( this->LA(2) )
        		{
        		case '-':
        		case '.':
        		case '/':
        		case '=':
        		case '>':
        		case '|':
        		case '~':
        			{
        				alt8=20;
        			}
        		    break;

        		default:
        		    alt8=14;
        		}

        	}
            break;
        case '>':
        	{
        		alt8=15;
        	}
            break;
        case '[':
        	{
        		alt8=16;
        	}
            break;
        case ']':
        	{
        		alt8=17;
        	}
            break;
        case '.':
        	{
        		switch ( this->LA(2) )
        		{
        		case '.':
        			{
        				switch ( this->LA(3) )
        				{
        				case '>':
        					{
        						alt8=20;
        					}
        				    break;

        				default:
        				    alt8=21;
        				}

        			}
        		    break;

        		default:
        		    alt8=21;
        		}

        	}
            break;
        case '-':
        case '~':
        	{
        		alt8=20;
        	}
            break;
        case '_':
        	{
        		switch ( this->LA(2) )
        		{
        		case '-':
        		case '<':
        		case '=':
        		case '~':
        			{
        				alt8=20;
        			}
        		    break;

        		default:
        		    alt8=21;
        		}

        	}
            break;
        case '#':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z':
        case 0x0410:
        case 0x0411:
        case 0x0412:
        case 0x0413:
        case 0x0414:
        case 0x0415:
        case 0x0416:
        case 0x0417:
        case 0x0418:
        case 0x0419:
        case 0x041A:
        case 0x041B:
        case 0x041C:
        case 0x041D:
        case 0x041E:
        case 0x041F:
        case 0x0420:
        case 0x0421:
        case 0x0422:
        case 0x0423:
        case 0x0424:
        case 0x0425:
        case 0x0426:
        case 0x0427:
        case 0x0428:
        case 0x0429:
        case 0x042A:
        case 0x042B:
        case 0x042C:
        case 0x042D:
        case 0x042E:
        case 0x042F:
        case 0x0430:
        case 0x0431:
        case 0x0432:
        case 0x0433:
        case 0x0434:
        case 0x0435:
        case 0x0436:
        case 0x0437:
        case 0x0438:
        case 0x0439:
        case 0x043A:
        case 0x043B:
        case 0x043C:
        case 0x043D:
        case 0x043E:
        case 0x043F:
        case 0x0440:
        case 0x0441:
        case 0x0442:
        case 0x0443:
        case 0x0444:
        case 0x0445:
        case 0x0446:
        case 0x0447:
        case 0x0448:
        case 0x0449:
        case 0x044A:
        case 0x044B:
        case 0x044C:
        case 0x044D:
        case 0x044E:
        case 0x044F:
        	{
        		alt8=21;
        	}
            break;
        case '/':
        	{
        		alt8=22;
        	}
            break;
        case '\t':
        case '\n':
        case '\r':
        case ' ':
        	{
        		alt8=23;
        	}
            break;

        default:
            ExceptionBaseType* ex = new ANTLR_Exception< SCsLexerImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            ex->set_decisionNum( 8 );
            ex->set_state( 0 );


            goto ruleTokensEx;

        }

        switch (alt8)
        {
    	case 1:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:10: T__26
    	    {
    	        /* 1:10: T__26 */
    	        mT__26();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 2:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:16: T__27
    	    {
    	        /* 1:16: T__27 */
    	        mT__27();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 3:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:22: URL
    	    {
    	        /* 1:22: URL */
    	        mURL();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 4:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:26: TRIPLESEP
    	    {
    	        /* 1:26: TRIPLESEP */
    	        mTRIPLESEP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 5:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:36: ATTRSEP
    	    {
    	        /* 1:36: ATTRSEP */
    	        mATTRSEP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 6:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:44: OBJSEP
    	    {
    	        /* 1:44: OBJSEP */
    	        mOBJSEP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 7:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:51: SENTSEP
    	    {
    	        /* 1:51: SENTSEP */
    	        mSENTSEP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 8:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:59: SYNSEP
    	    {
    	        /* 1:59: SYNSEP */
    	        mSYNSEP();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 9:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:66: LPAR
    	    {
    	        /* 1:66: LPAR */
    	        mLPAR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 10:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:71: RPAR
    	    {
    	        /* 1:71: RPAR */
    	        mRPAR();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 11:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:76: ALIASNONAME
    	    {
    	        /* 1:76: ALIASNONAME */
    	        mALIASNONAME();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 12:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:88: LPAR_SET
    	    {
    	        /* 1:88: LPAR_SET */
    	        mLPAR_SET();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 13:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:97: RPAR_SET
    	    {
    	        /* 1:97: RPAR_SET */
    	        mRPAR_SET();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 14:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:106: LPAR_OSET
    	    {
    	        /* 1:106: LPAR_OSET */
    	        mLPAR_OSET();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 15:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:116: RPAR_OSET
    	    {
    	        /* 1:116: RPAR_OSET */
    	        mRPAR_OSET();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 16:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:126: LPAR_TRF
    	    {
    	        /* 1:126: LPAR_TRF */
    	        mLPAR_TRF();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 17:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:135: RPAR_TRF
    	    {
    	        /* 1:135: RPAR_TRF */
    	        mRPAR_TRF();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 18:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:144: LPAR_INT
    	    {
    	        /* 1:144: LPAR_INT */
    	        mLPAR_INT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 19:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:153: RPAR_INT
    	    {
    	        /* 1:153: RPAR_INT */
    	        mRPAR_INT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 20:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:162: CONNECTORS
    	    {
    	        /* 1:162: CONNECTORS */
    	        mCONNECTORS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 21:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:173: NAME
    	    {
    	        /* 1:173: NAME */
    	        mNAME();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 22:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:178: COMMENT
    	    {
    	        /* 1:178: COMMENT */
    	        mCOMMENT();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 23:
    	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:1:186: WS
    	    {
    	        /* 1:186: WS */
    	        mWS();
    	        if  (this->hasException())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;

        }
    }


    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

//add
void SCsLexer::displayRecognitionError(ANTLR_UINT8** tokenNames, ExceptionBaseType* ex )
{
    fprintf(stderr,"lexer line:%d pos:%d\n",ex->get_line(),ex->get_charPositionInLine());
    mErrorsArray.push_back(new SCsLexer::RuntimeParserError(tokenNames, ex));
}


/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */

	}



/* End of code
 * =============================================================================
 */
