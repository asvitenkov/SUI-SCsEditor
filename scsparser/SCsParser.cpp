/** \file
 *  This C++ source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g
 *     -                            On : 2013-03-10 07:25:11
 *     -                for the parser : SCsParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SCsParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

	namespace  SCsParserNS  {

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   SCsParserTokenNames[24+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "ALIASNONAME",
        (ANTLR_UINT8*) "ATTRSEP",
        (ANTLR_UINT8*) "COMMENT",
        (ANTLR_UINT8*) "CONNECTORS",
        (ANTLR_UINT8*) "CONTENT",
        (ANTLR_UINT8*) "ELEMTYPE",
        (ANTLR_UINT8*) "LPAR",
        (ANTLR_UINT8*) "LPAR_INT",
        (ANTLR_UINT8*) "LPAR_OSET",
        (ANTLR_UINT8*) "LPAR_SET",
        (ANTLR_UINT8*) "LPAR_TRF",
        (ANTLR_UINT8*) "NAME",
        (ANTLR_UINT8*) "OBJSEP",
        (ANTLR_UINT8*) "RPAR",
        (ANTLR_UINT8*) "RPAR_INT",
        (ANTLR_UINT8*) "RPAR_OSET",
        (ANTLR_UINT8*) "RPAR_SET",
        (ANTLR_UINT8*) "RPAR_TRF",
        (ANTLR_UINT8*) "SENTSEP",
        (ANTLR_UINT8*) "SYNSEP",
        (ANTLR_UINT8*) "TRIPLESEP",
        (ANTLR_UINT8*) "URL",
        (ANTLR_UINT8*) "WS",
        (ANTLR_UINT8*) "'/'"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* SCsParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new SCsParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SCsParser::SCsParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new SCsParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SCsParser::SCsParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void SCsParser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( SCsParserTokenNames );


}

void
SCsParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
SCsParser::~SCsParser()
 {
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return SCsParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_in_syntax88_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_in_syntax88( FOLLOW_sentence_in_syntax88_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_SENTSEP_in_syntax90_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B712) };
static  SCsParserImplTraits::BitsetListType FOLLOW_SENTSEP_in_syntax90( FOLLOW_SENTSEP_in_syntax90_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_lv1_in_sentence115_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_lv1_in_sentence115( FOLLOW_sentence_lv1_in_sentence115_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_lv23456_in_sentence119_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_lv23456_in_sentence119( FOLLOW_sentence_lv23456_in_sentence119_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_sentence_lv23456137_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_sentence_lv23456137( FOLLOW_idtf_in_sentence_lv23456137_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONNECTORS_in_sentence_lv23456139_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B710) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONNECTORS_in_sentence_lv23456139( FOLLOW_CONNECTORS_in_sentence_lv23456139_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_sentence_lv23456141_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B710) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_sentence_lv23456141( FOLLOW_attrsList_in_sentence_lv23456141_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objectList_in_sentence_lv23456143_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objectList_in_sentence_lv23456143( FOLLOW_objectList_in_sentence_lv23456143_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1161_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1161( FOLLOW_simpleIdtf_in_sentence_lv1161_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_TRIPLESEP_in_sentence_lv1163_bits[]	= { ANTLR_UINT64_LIT(0x0000000002008200) };
static  SCsParserImplTraits::BitsetListType FOLLOW_TRIPLESEP_in_sentence_lv1163( FOLLOW_TRIPLESEP_in_sentence_lv1163_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1165_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1165( FOLLOW_simpleIdtf_in_sentence_lv1165_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_TRIPLESEP_in_sentence_lv1167_bits[]	= { ANTLR_UINT64_LIT(0x0000000002008200) };
static  SCsParserImplTraits::BitsetListType FOLLOW_TRIPLESEP_in_sentence_lv1167( FOLLOW_TRIPLESEP_in_sentence_lv1167_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1169_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1169( FOLLOW_simpleIdtf_in_sentence_lv1169_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_attrsList190_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000020) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_attrsList190( FOLLOW_simpleIdtf_in_attrsList190_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_ATTRSEP_in_attrsList192_bits[]	= { ANTLR_UINT64_LIT(0x0000000002008202) };
static  SCsParserImplTraits::BitsetListType FOLLOW_ATTRSEP_in_attrsList192( FOLLOW_ATTRSEP_in_attrsList192_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_objectList215_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_objectList215( FOLLOW_idtfWithInt_in_objectList215_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_OBJSEP_in_objectList218_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B710) };
static  SCsParserImplTraits::BitsetListType FOLLOW_OBJSEP_in_objectList218( FOLLOW_OBJSEP_in_objectList218_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_objectList220_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_objectList220( FOLLOW_idtfWithInt_in_objectList220_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONNECTORS_in_intSentence248_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B710) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONNECTORS_in_intSentence248( FOLLOW_CONNECTORS_in_intSentence248_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_intSentence250_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B710) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_intSentence250( FOLLOW_attrsList_in_intSentence250_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objectList_in_intSentence253_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objectList_in_intSentence253( FOLLOW_objectList_in_intSentence253_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_INT_in_intSentenceList271_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_INT_in_intSentenceList271( FOLLOW_LPAR_INT_in_intSentenceList271_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_intSentence_in_intSentenceList275_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_intSentence_in_intSentenceList275( FOLLOW_intSentence_in_intSentenceList275_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_SENTSEP_in_intSentenceList277_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040080) };
static  SCsParserImplTraits::BitsetListType FOLLOW_SENTSEP_in_intSentenceList277( FOLLOW_SENTSEP_in_intSentenceList277_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_INT_in_intSentenceList282_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_INT_in_intSentenceList282( FOLLOW_RPAR_INT_in_intSentenceList282_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_intSentenceList_in_internal300_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_intSentenceList_in_internal300( FOLLOW_intSentenceList_in_internal300_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_in_triple333_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B710) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_in_triple333( FOLLOW_LPAR_in_triple333_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_triple335_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000100) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_triple335( FOLLOW_idtf_in_triple335_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONTENT_in_triple337_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B710) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONTENT_in_triple337( FOLLOW_CONTENT_in_triple337_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_triple339_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_triple339( FOLLOW_idtf_in_triple339_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_in_triple341_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_in_triple341( FOLLOW_RPAR_in_triple341_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_ALIASNONAME_in_alias358_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_ALIASNONAME_in_alias358( FOLLOW_ALIASNONAME_in_alias358_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_SET_in_setIdtf375_bits[]	= { ANTLR_UINT64_LIT(0x000000000210B710) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_SET_in_setIdtf375( FOLLOW_LPAR_SET_in_setIdtf375_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_setIdtf378_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B710) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_setIdtf378( FOLLOW_attrsList_in_setIdtf378_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_setIdtf380_bits[]	= { ANTLR_UINT64_LIT(0x000000000211B710) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_setIdtf380( FOLLOW_idtfWithInt_in_setIdtf380_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_OBJSEP_in_setIdtf382_bits[]	= { ANTLR_UINT64_LIT(0x000000000210B710) };
static  SCsParserImplTraits::BitsetListType FOLLOW_OBJSEP_in_setIdtf382( FOLLOW_OBJSEP_in_setIdtf382_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_SET_in_setIdtf390_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_SET_in_setIdtf390( FOLLOW_RPAR_SET_in_setIdtf390_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_OSET_in_osetIdtf408_bits[]	= { ANTLR_UINT64_LIT(0x000000000208B710) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_OSET_in_osetIdtf408( FOLLOW_LPAR_OSET_in_osetIdtf408_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_osetIdtf412_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B710) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_osetIdtf412( FOLLOW_attrsList_in_osetIdtf412_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_osetIdtf414_bits[]	= { ANTLR_UINT64_LIT(0x000000000209B710) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_osetIdtf414( FOLLOW_idtfWithInt_in_osetIdtf414_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_OBJSEP_in_osetIdtf416_bits[]	= { ANTLR_UINT64_LIT(0x000000000208B710) };
static  SCsParserImplTraits::BitsetListType FOLLOW_OBJSEP_in_osetIdtf416( FOLLOW_OBJSEP_in_osetIdtf416_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_OSET_in_osetIdtf423_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_OSET_in_osetIdtf423( FOLLOW_RPAR_OSET_in_osetIdtf423_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_anyIdtf450_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_anyIdtf450( FOLLOW_simpleIdtf_in_anyIdtf450_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONTENT_in_anyIdtf460_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONTENT_in_anyIdtf460( FOLLOW_CONTENT_in_anyIdtf460_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_triple_in_anyIdtf470_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_triple_in_anyIdtf470( FOLLOW_triple_in_anyIdtf470_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_setIdtf_in_anyIdtf480_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_setIdtf_in_anyIdtf480( FOLLOW_setIdtf_in_anyIdtf480_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_osetIdtf_in_anyIdtf490_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_osetIdtf_in_anyIdtf490( FOLLOW_osetIdtf_in_anyIdtf490_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_alias_in_anyIdtf500_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_alias_in_anyIdtf500( FOLLOW_alias_in_anyIdtf500_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_anyIdtf_in_idtf526_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_anyIdtf_in_idtf526( FOLLOW_anyIdtf_in_idtf526_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_ELEMTYPE_in_simpleIdtf544_bits[]	= { ANTLR_UINT64_LIT(0x0000000008000000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_ELEMTYPE_in_simpleIdtf544( FOLLOW_ELEMTYPE_in_simpleIdtf544_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_27_in_simpleIdtf546_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_27_in_simpleIdtf546( FOLLOW_27_in_simpleIdtf546_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_NAME_in_simpleIdtf551_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_NAME_in_simpleIdtf551( FOLLOW_NAME_in_simpleIdtf551_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_URL_in_simpleIdtf555_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_URL_in_simpleIdtf555( FOLLOW_URL_in_simpleIdtf555_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_idtfWithInt574_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000802) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_idtfWithInt574( FOLLOW_idtf_in_idtfWithInt574_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_internal_in_idtfWithInt576_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_internal_in_idtfWithInt576( FOLLOW_internal_in_idtfWithInt576_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start syntax
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:49:1: syntax : ( sentence SENTSEP )* ;
 */
void
SCsParser::syntax()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:50:5: ( ( sentence SENTSEP )* )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:50:7: ( sentence SENTSEP )*
        {
            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:50:7: ( sentence SENTSEP )*

            for (;;)
            {
                int alt1=2;
                switch ( this->LA(1) )
                {
                case ALIASNONAME:
                case CONTENT:
                case ELEMTYPE:
                case LPAR:
                case LPAR_OSET:
                case LPAR_SET:
                case NAME:
                case URL:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:50:9: sentence SENTSEP
            	    {
            	        this->followPush(FOLLOW_sentence_in_syntax88);
            	        sentence();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesyntaxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(SENTSEP, &FOLLOW_SENTSEP_in_syntax90);
            	        if  (this->hasException())
            	        {
            	            goto rulesyntaxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesyntaxEx; /* Prevent compiler warnings */
    rulesyntaxEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end syntax */

/**
 * $ANTLR start sentence
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:54:1: sentence : ( sentence_lv1 | sentence_lv23456 );
 */
void
SCsParser::sentence()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:55:5: ( sentence_lv1 | sentence_lv23456 )

            ANTLR_UINT32 alt2;

            alt2=2;

            switch ( this->LA(1) )
            {
            case ELEMTYPE:
            	{
            		switch ( this->LA(2) )
            		{
            		case 27:
            			{
            				switch ( this->LA(3) )
            				{
            				case NAME:
            					{
            						switch ( this->LA(4) )
            						{
            						case TRIPLESEP:
            							{
            								alt2=1;
            							}
            						    break;
            						case CONNECTORS:
            							{
            								alt2=2;
            							}
            						    break;

            						default:
            						    if (this->get_backtracking()>0)
            						    {
            						        this->set_failedflag( true );
            						        return ;
            						    }

            						    ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            						    ex->set_decisionNum( 2 );
            						    ex->set_state( 2 );


            						    goto rulesentenceEx;

            						}

            					}
            				    break;

            				default:
            				    if (this->get_backtracking()>0)
            				    {
            				        this->set_failedflag( true );
            				        return ;
            				    }

            				    ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            				    ex->set_decisionNum( 2 );
            				    ex->set_state( 5 );


            				    goto rulesentenceEx;

            				}

            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 2 );
            		    ex->set_state( 1 );


            		    goto rulesentenceEx;

            		}

            	}
                break;
            case NAME:
            	{
            		switch ( this->LA(2) )
            		{
            		case TRIPLESEP:
            			{
            				alt2=1;
            			}
            		    break;
            		case CONNECTORS:
            			{
            				alt2=2;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 2 );
            		    ex->set_state( 2 );


            		    goto rulesentenceEx;

            		}

            	}
                break;
            case URL:
            	{
            		switch ( this->LA(2) )
            		{
            		case TRIPLESEP:
            			{
            				alt2=1;
            			}
            		    break;
            		case CONNECTORS:
            			{
            				alt2=2;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 2 );
            		    ex->set_state( 3 );


            		    goto rulesentenceEx;

            		}

            	}
                break;
            case ALIASNONAME:
            case CONTENT:
            case LPAR:
            case LPAR_OSET:
            case LPAR_SET:
            	{
            		alt2=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 2 );
                ex->set_state( 0 );


                goto rulesentenceEx;

            }

            switch (alt2)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:55:7: sentence_lv1
        	    {
        	        this->followPush(FOLLOW_sentence_lv1_in_sentence115);
        	        sentence_lv1();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesentenceEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:55:22: sentence_lv23456
        	    {
        	        this->followPush(FOLLOW_sentence_lv23456_in_sentence119);
        	        sentence_lv23456();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesentenceEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesentenceEx; /* Prevent compiler warnings */
    rulesentenceEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sentence */

/**
 * $ANTLR start sentence_lv23456
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:59:1: sentence_lv23456 : idtf CONNECTORS attrsList objectList ;
 */
void
SCsParser::sentence_lv23456()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:60:5: ( idtf CONNECTORS attrsList objectList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:60:7: idtf CONNECTORS attrsList objectList
        {
            this->followPush(FOLLOW_idtf_in_sentence_lv23456137);
            idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(CONNECTORS, &FOLLOW_CONNECTORS_in_sentence_lv23456139);
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_attrsList_in_sentence_lv23456141);
            attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_objectList_in_sentence_lv23456143);
            objectList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesentence_lv23456Ex; /* Prevent compiler warnings */
    rulesentence_lv23456Ex: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sentence_lv23456 */

/**
 * $ANTLR start sentence_lv1
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:64:1: sentence_lv1 : simpleIdtf TRIPLESEP simpleIdtf TRIPLESEP simpleIdtf ;
 */
void
SCsParser::sentence_lv1()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:65:5: ( simpleIdtf TRIPLESEP simpleIdtf TRIPLESEP simpleIdtf )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:65:7: simpleIdtf TRIPLESEP simpleIdtf TRIPLESEP simpleIdtf
        {
            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1161);
            simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(TRIPLESEP, &FOLLOW_TRIPLESEP_in_sentence_lv1163);
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1165);
            simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(TRIPLESEP, &FOLLOW_TRIPLESEP_in_sentence_lv1167);
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1169);
            simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesentence_lv1Ex; /* Prevent compiler warnings */
    rulesentence_lv1Ex: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end sentence_lv1 */

/**
 * $ANTLR start attrsList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:69:1: attrsList : ( simpleIdtf ATTRSEP )* ;
 */
void
SCsParser::attrsList()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:70:5: ( ( simpleIdtf ATTRSEP )* )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:70:8: ( simpleIdtf ATTRSEP )*
        {
            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:70:8: ( simpleIdtf ATTRSEP )*

            for (;;)
            {
                int alt3=2;
                switch ( this->LA(1) )
                {
                case ELEMTYPE:
                	{
                		switch ( this->LA(2) )
                		{
                		case 27:
                			{
                				switch ( this->LA(3) )
                				{
                				case NAME:
                					{
                						switch ( this->LA(4) )
                						{
                						case ATTRSEP:
                							{
                								alt3=1;
                							}
                						    break;

                						}

                					}
                				    break;

                				}

                			}
                		    break;

                		}

                	}
                    break;
                case NAME:
                	{
                		switch ( this->LA(2) )
                		{
                		case ATTRSEP:
                			{
                				alt3=1;
                			}
                		    break;

                		}

                	}
                    break;
                case URL:
                	{
                		switch ( this->LA(2) )
                		{
                		case ATTRSEP:
                			{
                				alt3=1;
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt3)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:70:9: simpleIdtf ATTRSEP
            	    {
            	        this->followPush(FOLLOW_simpleIdtf_in_attrsList190);
            	        simpleIdtf();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleattrsListEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(ATTRSEP, &FOLLOW_ATTRSEP_in_attrsList192);
            	        if  (this->hasException())
            	        {
            	            goto ruleattrsListEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop3;	/* break out of the loop */
            	    break;
                }
            }
            loop3: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleattrsListEx; /* Prevent compiler warnings */
    ruleattrsListEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end attrsList */

/**
 * $ANTLR start objectList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:73:1: objectList : idtfWithInt ( OBJSEP idtfWithInt )* ;
 */
void
SCsParser::objectList()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:74:5: ( idtfWithInt ( OBJSEP idtfWithInt )* )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:74:7: idtfWithInt ( OBJSEP idtfWithInt )*
        {
            this->followPush(FOLLOW_idtfWithInt_in_objectList215);
            idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleobjectListEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:74:19: ( OBJSEP idtfWithInt )*

            for (;;)
            {
                int alt4=2;
                switch ( this->LA(1) )
                {
                case OBJSEP:
                	{
                		alt4=1;
                	}
                    break;

                }

                switch (alt4)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:74:20: OBJSEP idtfWithInt
            	    {
            	         this->matchToken(OBJSEP, &FOLLOW_OBJSEP_in_objectList218);
            	        if  (this->hasException())
            	        {
            	            goto ruleobjectListEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_idtfWithInt_in_objectList220);
            	        idtfWithInt();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleobjectListEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleobjectListEx; /* Prevent compiler warnings */
    ruleobjectListEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end objectList */

/**
 * $ANTLR start intSentence
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:78:1: intSentence : CONNECTORS attrsList objectList ;
 */
void
SCsParser::intSentence()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:79:5: ( CONNECTORS attrsList objectList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:79:7: CONNECTORS attrsList objectList
        {
             this->matchToken(CONNECTORS, &FOLLOW_CONNECTORS_in_intSentence248);
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_attrsList_in_intSentence250);
            attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_objectList_in_intSentence253);
            objectList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintSentenceEx; /* Prevent compiler warnings */
    ruleintSentenceEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end intSentence */

/**
 * $ANTLR start intSentenceList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:82:1: intSentenceList : LPAR_INT ( intSentence SENTSEP )+ RPAR_INT ;
 */
void
SCsParser::intSentenceList()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:83:5: ( LPAR_INT ( intSentence SENTSEP )+ RPAR_INT )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:83:7: LPAR_INT ( intSentence SENTSEP )+ RPAR_INT
        {
             this->matchToken(LPAR_INT, &FOLLOW_LPAR_INT_in_intSentenceList271);
            if  (this->hasException())
            {
                goto ruleintSentenceListEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:83:16: ( intSentence SENTSEP )+
            {
                int cnt5=0;

                for (;;)
                {
                    int alt5=2;
            	switch ( this->LA(1) )
            	{
            	case CONNECTORS:
            		{
            			alt5=1;
            		}
            	    break;

            	}

            	switch (alt5)
            	{
            	    case 1:
            	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:83:18: intSentence SENTSEP
            	        {
            	            this->followPush(FOLLOW_intSentence_in_intSentenceList275);
            	            intSentence();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleintSentenceListEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	             this->matchToken(SENTSEP, &FOLLOW_SENTSEP_in_intSentenceList277);
            	            if  (this->hasException())
            	            {
            	                goto ruleintSentenceListEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt5 >= 1 )
            		{
            		    goto loop5;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return ;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< SCsParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleintSentenceListEx;
            	}
            	cnt5++;
                }
                loop5: ;	/* Jump to here if this rule does not match */
            }

             this->matchToken(RPAR_INT, &FOLLOW_RPAR_INT_in_intSentenceList282);
            if  (this->hasException())
            {
                goto ruleintSentenceListEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintSentenceListEx; /* Prevent compiler warnings */
    ruleintSentenceListEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end intSentenceList */

/**
 * $ANTLR start internal
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:86:1: internal : intSentenceList ;
 */
void
SCsParser::internal()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:87:5: ( intSentenceList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:87:8: intSentenceList
        {
            this->followPush(FOLLOW_intSentenceList_in_internal300);
            intSentenceList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleinternalEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinternalEx; /* Prevent compiler warnings */
    ruleinternalEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end internal */

/**
 * $ANTLR start triple
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:94:1: triple : LPAR idtf CONTENT idtf RPAR ;
 */
void
SCsParser::triple()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:95:5: ( LPAR idtf CONTENT idtf RPAR )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:95:7: LPAR idtf CONTENT idtf RPAR
        {
             this->matchToken(LPAR, &FOLLOW_LPAR_in_triple333);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_idtf_in_triple335);
            idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletripleEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(CONTENT, &FOLLOW_CONTENT_in_triple337);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_idtf_in_triple339);
            idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletripleEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RPAR, &FOLLOW_RPAR_in_triple341);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletripleEx; /* Prevent compiler warnings */
    ruletripleEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end triple */

/**
 * $ANTLR start alias
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:98:1: alias : ALIASNONAME ;
 */
void
SCsParser::alias()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:99:5: ( ALIASNONAME )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:99:7: ALIASNONAME
        {
             this->matchToken(ALIASNONAME, &FOLLOW_ALIASNONAME_in_alias358);
            if  (this->hasException())
            {
                goto rulealiasEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealiasEx; /* Prevent compiler warnings */
    rulealiasEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end alias */

/**
 * $ANTLR start setIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:102:1: setIdtf : LPAR_SET ( attrsList idtfWithInt ( OBJSEP )? )* RPAR_SET ;
 */
void
SCsParser::setIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:103:5: ( LPAR_SET ( attrsList idtfWithInt ( OBJSEP )? )* RPAR_SET )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:103:7: LPAR_SET ( attrsList idtfWithInt ( OBJSEP )? )* RPAR_SET
        {
             this->matchToken(LPAR_SET, &FOLLOW_LPAR_SET_in_setIdtf375);
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:103:16: ( attrsList idtfWithInt ( OBJSEP )? )*

            for (;;)
            {
                int alt7=2;
                switch ( this->LA(1) )
                {
                case ALIASNONAME:
                case CONTENT:
                case ELEMTYPE:
                case LPAR:
                case LPAR_OSET:
                case LPAR_SET:
                case NAME:
                case URL:
                	{
                		alt7=1;
                	}
                    break;

                }

                switch (alt7)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:103:17: attrsList idtfWithInt ( OBJSEP )?
            	    {
            	        this->followPush(FOLLOW_attrsList_in_setIdtf378);
            	        attrsList();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesetIdtfEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_idtfWithInt_in_setIdtf380);
            	        idtfWithInt();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesetIdtfEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:103:39: ( OBJSEP )?
            	        {
            	            int alt6=2;
            	            switch ( this->LA(1) )
            	            {
            	                case OBJSEP:
            	                	{
            	                		alt6=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt6)
            	            {
            	        	case 1:
            	        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:103:39: OBJSEP
            	        	    {
            	        	         this->matchToken(OBJSEP, &FOLLOW_OBJSEP_in_setIdtf382);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulesetIdtfEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


             this->matchToken(RPAR_SET, &FOLLOW_RPAR_SET_in_setIdtf390);
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesetIdtfEx; /* Prevent compiler warnings */
    rulesetIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end setIdtf */

/**
 * $ANTLR start osetIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:107:1: osetIdtf : LPAR_OSET ( attrsList idtfWithInt ( OBJSEP )? )* RPAR_OSET ;
 */
void
SCsParser::osetIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:108:5: ( LPAR_OSET ( attrsList idtfWithInt ( OBJSEP )? )* RPAR_OSET )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:108:7: LPAR_OSET ( attrsList idtfWithInt ( OBJSEP )? )* RPAR_OSET
        {
             this->matchToken(LPAR_OSET, &FOLLOW_LPAR_OSET_in_osetIdtf408);
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:108:17: ( attrsList idtfWithInt ( OBJSEP )? )*

            for (;;)
            {
                int alt9=2;
                switch ( this->LA(1) )
                {
                case ALIASNONAME:
                case CONTENT:
                case ELEMTYPE:
                case LPAR:
                case LPAR_OSET:
                case LPAR_SET:
                case NAME:
                case URL:
                	{
                		alt9=1;
                	}
                    break;

                }

                switch (alt9)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:108:19: attrsList idtfWithInt ( OBJSEP )?
            	    {
            	        this->followPush(FOLLOW_attrsList_in_osetIdtf412);
            	        attrsList();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleosetIdtfEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_idtfWithInt_in_osetIdtf414);
            	        idtfWithInt();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleosetIdtfEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:108:41: ( OBJSEP )?
            	        {
            	            int alt8=2;
            	            switch ( this->LA(1) )
            	            {
            	                case OBJSEP:
            	                	{
            	                		alt8=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt8)
            	            {
            	        	case 1:
            	        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:108:41: OBJSEP
            	        	    {
            	        	         this->matchToken(OBJSEP, &FOLLOW_OBJSEP_in_osetIdtf416);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleosetIdtfEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

            	default:
            	    goto loop9;	/* break out of the loop */
            	    break;
                }
            }
            loop9: ; /* Jump out to here if this rule does not match */


             this->matchToken(RPAR_OSET, &FOLLOW_RPAR_OSET_in_osetIdtf423);
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleosetIdtfEx; /* Prevent compiler warnings */
    ruleosetIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end osetIdtf */

/**
 * $ANTLR start anyIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:111:1: anyIdtf : ( simpleIdtf | CONTENT | triple | setIdtf | osetIdtf | alias );
 */
void
SCsParser::anyIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:112:5: ( simpleIdtf | CONTENT | triple | setIdtf | osetIdtf | alias )

            ANTLR_UINT32 alt10;

            alt10=6;

            switch ( this->LA(1) )
            {
            case ELEMTYPE:
            case NAME:
            case URL:
            	{
            		alt10=1;
            	}
                break;
            case CONTENT:
            	{
            		alt10=2;
            	}
                break;
            case LPAR:
            	{
            		alt10=3;
            	}
                break;
            case LPAR_SET:
            	{
            		alt10=4;
            	}
                break;
            case LPAR_OSET:
            	{
            		alt10=5;
            	}
                break;
            case ALIASNONAME:
            	{
            		alt10=6;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 10 );
                ex->set_state( 0 );


                goto ruleanyIdtfEx;

            }

            switch (alt10)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:113:9: simpleIdtf
        	    {
        	        this->followPush(FOLLOW_simpleIdtf_in_anyIdtf450);
        	        simpleIdtf();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:114:9: CONTENT
        	    {
        	         this->matchToken(CONTENT, &FOLLOW_CONTENT_in_anyIdtf460);
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:115:9: triple
        	    {
        	        this->followPush(FOLLOW_triple_in_anyIdtf470);
        	        triple();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:116:9: setIdtf
        	    {
        	        this->followPush(FOLLOW_setIdtf_in_anyIdtf480);
        	        setIdtf();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:117:9: osetIdtf
        	    {
        	        this->followPush(FOLLOW_osetIdtf_in_anyIdtf490);
        	        osetIdtf();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:118:9: alias
        	    {
        	        this->followPush(FOLLOW_alias_in_anyIdtf500);
        	        alias();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleanyIdtfEx; /* Prevent compiler warnings */
    ruleanyIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end anyIdtf */

/**
 * $ANTLR start idtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:122:1: idtf : anyIdtf ;
 */
void
SCsParser::idtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:123:5: ( anyIdtf )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:123:7: anyIdtf
        {
            this->followPush(FOLLOW_anyIdtf_in_idtf526);
            anyIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleidtfEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleidtfEx; /* Prevent compiler warnings */
    ruleidtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end idtf */

/**
 * $ANTLR start simpleIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:126:1: simpleIdtf : ( ( ELEMTYPE '/' )? NAME | URL );
 */
void
SCsParser::simpleIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:126:13: ( ( ELEMTYPE '/' )? NAME | URL )

            ANTLR_UINT32 alt12;

            alt12=2;

            switch ( this->LA(1) )
            {
            case ELEMTYPE:
            case NAME:
            	{
            		alt12=1;
            	}
                break;
            case URL:
            	{
            		alt12=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 12 );
                ex->set_state( 0 );


                goto rulesimpleIdtfEx;

            }

            switch (alt12)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:127:4: ( ELEMTYPE '/' )? NAME
        	    {
        	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:127:4: ( ELEMTYPE '/' )?
        	        {
        	            int alt11=2;
        	            switch ( this->LA(1) )
        	            {
        	                case ELEMTYPE:
        	                	{
        	                		alt11=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt11)
        	            {
        	        	case 1:
        	        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:127:5: ELEMTYPE '/'
        	        	    {
        	        	         this->matchToken(ELEMTYPE, &FOLLOW_ELEMTYPE_in_simpleIdtf544);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulesimpleIdtfEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(27, &FOLLOW_27_in_simpleIdtf546);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulesimpleIdtfEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         this->matchToken(NAME, &FOLLOW_NAME_in_simpleIdtf551);
        	        if  (this->hasException())
        	        {
        	            goto rulesimpleIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:127:28: URL
        	    {
        	         this->matchToken(URL, &FOLLOW_URL_in_simpleIdtf555);
        	        if  (this->hasException())
        	        {
        	            goto rulesimpleIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesimpleIdtfEx; /* Prevent compiler warnings */
    rulesimpleIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end simpleIdtf */

/**
 * $ANTLR start idtfWithInt
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:132:1: idtfWithInt : idtf ( internal )? ;
 */
void
SCsParser::idtfWithInt()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:133:5: ( idtf ( internal )? )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:133:8: idtf ( internal )?
        {
            this->followPush(FOLLOW_idtf_in_idtfWithInt574);
            idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleidtfWithIntEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:133:13: ( internal )?
            {
                int alt13=2;
                switch ( this->LA(1) )
                {
                    case LPAR_INT:
                    	{
                    		alt13=1;
                    	}
                        break;
                }

                switch (alt13)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:133:13: internal
            	    {
            	        this->followPush(FOLLOW_internal_in_idtfWithInt576);
            	        internal();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleidtfWithIntEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleidtfWithIntEx; /* Prevent compiler warnings */
    ruleidtfWithIntEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end idtfWithInt */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

	}


/* End of code
 * =============================================================================
 */
