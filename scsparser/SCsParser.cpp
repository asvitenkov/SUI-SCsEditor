/** \file
 *  This C++ source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g
 *     -                            On : 2013-04-02 11:30:43
 *     -                for the parser : SCsParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SCsParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

	namespace  SCsParserNS  {

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   SCsParserTokenNames[23+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "ALIASNONAME",
        (ANTLR_UINT8*) "ATTRSEP",
        (ANTLR_UINT8*) "COMMENT",
        (ANTLR_UINT8*) "CONNECTORS",
        (ANTLR_UINT8*) "CONTENT",
        (ANTLR_UINT8*) "ELEMTYPE",
        (ANTLR_UINT8*) "LPAR",
        (ANTLR_UINT8*) "LPAR_INT",
        (ANTLR_UINT8*) "LPAR_OSET",
        (ANTLR_UINT8*) "LPAR_SET",
        (ANTLR_UINT8*) "LPAR_TRF",
        (ANTLR_UINT8*) "NAME",
        (ANTLR_UINT8*) "OBJSEP",
        (ANTLR_UINT8*) "RPAR",
        (ANTLR_UINT8*) "RPAR_INT",
        (ANTLR_UINT8*) "RPAR_OSET",
        (ANTLR_UINT8*) "RPAR_SET",
        (ANTLR_UINT8*) "RPAR_TRF",
        (ANTLR_UINT8*) "SENTSEP",
        (ANTLR_UINT8*) "SYNSEP",
        (ANTLR_UINT8*) "TRIPLESEP",
        (ANTLR_UINT8*) "URL",
        (ANTLR_UINT8*) "WS"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* SCsParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new SCsParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SCsParser::SCsParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new SCsParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SCsParser::SCsParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void SCsParser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( SCsParserTokenNames );


}

void
SCsParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
SCsParser::~SCsParser()
 {
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return SCsParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_sentsep_in_syntax125_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_sentsep_in_syntax125( FOLLOW_sentence_sentsep_in_syntax125_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_EOF_in_syntax135_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_EOF_in_syntax135( FOLLOW_EOF_in_syntax135_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_in_sentence_sentsep180_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_in_sentence_sentsep180( FOLLOW_sentence_in_sentence_sentsep180_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_SENTSEP_in_sentence_sentsep195_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_SENTSEP_in_sentence_sentsep195( FOLLOW_SENTSEP_in_sentence_sentsep195_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_lv1_in_sentence247_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_lv1_in_sentence247( FOLLOW_sentence_lv1_in_sentence247_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_lv23456_in_sentence273_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_lv23456_in_sentence273( FOLLOW_sentence_lv23456_in_sentence273_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_sentence_lv23456322_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_sentence_lv23456322( FOLLOW_idtf_in_sentence_lv23456322_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONNECTORS_in_sentence_lv23456348_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONNECTORS_in_sentence_lv23456348( FOLLOW_CONNECTORS_in_sentence_lv23456348_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_sentence_lv23456369_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_sentence_lv23456369( FOLLOW_attrsList_in_sentence_lv23456369_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objectList_in_sentence_lv23456390_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objectList_in_sentence_lv23456390( FOLLOW_objectList_in_sentence_lv23456390_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1444_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1444( FOLLOW_simpleIdtf_in_sentence_lv1444_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_TRIPLESEP_in_sentence_lv1464_bits[]	= { ANTLR_UINT64_LIT(0x0000000002008000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_TRIPLESEP_in_sentence_lv1464( FOLLOW_TRIPLESEP_in_sentence_lv1464_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1486_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1486( FOLLOW_simpleIdtf_in_sentence_lv1486_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_TRIPLESEP_in_sentence_lv1506_bits[]	= { ANTLR_UINT64_LIT(0x0000000002008000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_TRIPLESEP_in_sentence_lv1506( FOLLOW_TRIPLESEP_in_sentence_lv1506_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1527_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1527( FOLLOW_simpleIdtf_in_sentence_lv1527_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_attrsep_in_attrsList578_bits[]	= { ANTLR_UINT64_LIT(0x0000000002008002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_attrsep_in_attrsList578( FOLLOW_simpleIdtf_attrsep_in_attrsList578_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_simpleIdtf_attrsep629_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000020) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_simpleIdtf_attrsep629( FOLLOW_simpleIdtf_in_simpleIdtf_attrsep629_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_ATTRSEP_in_simpleIdtf_attrsep645_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_ATTRSEP_in_simpleIdtf_attrsep645( FOLLOW_ATTRSEP_in_simpleIdtf_attrsep645_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_objectList707_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_objectList707( FOLLOW_idtfWithInt_in_objectList707_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objsep_IdtfWithInt_in_objectList735_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objsep_IdtfWithInt_in_objectList735( FOLLOW_objsep_IdtfWithInt_in_objectList735_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_OBJSEP_in_objsep_IdtfWithInt785_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_OBJSEP_in_objsep_IdtfWithInt785( FOLLOW_OBJSEP_in_objsep_IdtfWithInt785_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_objsep_IdtfWithInt807_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_objsep_IdtfWithInt807( FOLLOW_idtfWithInt_in_objsep_IdtfWithInt807_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONNECTORS_in_intSentence861_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONNECTORS_in_intSentence861( FOLLOW_CONNECTORS_in_intSentence861_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_intSentence882_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_intSentence882( FOLLOW_attrsList_in_intSentence882_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objectList_in_intSentence904_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objectList_in_intSentence904( FOLLOW_objectList_in_intSentence904_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_INT_in_intSentenceList959_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_INT_in_intSentenceList959( FOLLOW_LPAR_INT_in_intSentenceList959_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_intSentence_sentsep_in_intSentenceList994_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040080) };
static  SCsParserImplTraits::BitsetListType FOLLOW_intSentence_sentsep_in_intSentenceList994( FOLLOW_intSentence_sentsep_in_intSentenceList994_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_INT_in_intSentenceList1024_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_INT_in_intSentenceList1024( FOLLOW_RPAR_INT_in_intSentenceList1024_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_intSentence_in_intSentence_sentsep1084_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_intSentence_in_intSentence_sentsep1084( FOLLOW_intSentence_in_intSentence_sentsep1084_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_SENTSEP_in_intSentence_sentsep1108_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_SENTSEP_in_intSentence_sentsep1108( FOLLOW_SENTSEP_in_intSentence_sentsep1108_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_intSentenceList_in_internal1164_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_intSentenceList_in_internal1164( FOLLOW_intSentenceList_in_internal1164_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_in_triple1223_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_in_triple1223( FOLLOW_LPAR_in_triple1223_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_triple1246_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000100) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_triple1246( FOLLOW_idtf_in_triple1246_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONTENT_in_triple1268_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONTENT_in_triple1268( FOLLOW_CONTENT_in_triple1268_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_triple1288_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_triple1288( FOLLOW_idtf_in_triple1288_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_in_triple1310_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_in_triple1310( FOLLOW_RPAR_in_triple1310_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_ALIASNONAME_in_alias1366_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_ALIASNONAME_in_alias1366( FOLLOW_ALIASNONAME_in_alias1366_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_SET_in_setIdtf1428_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_SET_in_setIdtf1428( FOLLOW_LPAR_SET_in_setIdtf1428_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_setIdtf1475_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_setIdtf1475( FOLLOW_attrsList_in_setIdtf1475_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_setIdtf1521_bits[]	= { ANTLR_UINT64_LIT(0x0000000000110000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_setIdtf1521( FOLLOW_idtfWithInt_in_setIdtf1521_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objsep_AttrsList_idtfWithInt_in_setIdtf1566_bits[]	= { ANTLR_UINT64_LIT(0x0000000000110000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objsep_AttrsList_idtfWithInt_in_setIdtf1566( FOLLOW_objsep_AttrsList_idtfWithInt_in_setIdtf1566_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_SET_in_setIdtf1597_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_SET_in_setIdtf1597( FOLLOW_RPAR_SET_in_setIdtf1597_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_OBJSEP_in_objsep_AttrsList_idtfWithInt1666_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_OBJSEP_in_objsep_AttrsList_idtfWithInt1666( FOLLOW_OBJSEP_in_objsep_AttrsList_idtfWithInt1666_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_objsep_AttrsList_idtfWithInt1689_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_objsep_AttrsList_idtfWithInt1689( FOLLOW_attrsList_in_objsep_AttrsList_idtfWithInt1689_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_objsep_AttrsList_idtfWithInt1708_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_objsep_AttrsList_idtfWithInt1708( FOLLOW_idtfWithInt_in_objsep_AttrsList_idtfWithInt1708_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_OSET_in_osetIdtf1766_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_OSET_in_osetIdtf1766( FOLLOW_LPAR_OSET_in_osetIdtf1766_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_osetIdtf1815_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_osetIdtf1815( FOLLOW_attrsList_in_osetIdtf1815_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_osetIdtf1864_bits[]	= { ANTLR_UINT64_LIT(0x0000000000090000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_osetIdtf1864( FOLLOW_idtfWithInt_in_osetIdtf1864_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objsep_AttrsList_idtfWithInt_in_osetIdtf1913_bits[]	= { ANTLR_UINT64_LIT(0x0000000000090000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objsep_AttrsList_idtfWithInt_in_osetIdtf1913( FOLLOW_objsep_AttrsList_idtfWithInt_in_osetIdtf1913_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_OSET_in_osetIdtf1948_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_OSET_in_osetIdtf1948( FOLLOW_RPAR_OSET_in_osetIdtf1948_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_anyIdtf2025_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_anyIdtf2025( FOLLOW_simpleIdtf_in_anyIdtf2025_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONTENT_in_anyIdtf2044_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONTENT_in_anyIdtf2044( FOLLOW_CONTENT_in_anyIdtf2044_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_triple_in_anyIdtf2066_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_triple_in_anyIdtf2066( FOLLOW_triple_in_anyIdtf2066_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_setIdtf_in_anyIdtf2089_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_setIdtf_in_anyIdtf2089( FOLLOW_setIdtf_in_anyIdtf2089_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_osetIdtf_in_anyIdtf2111_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_osetIdtf_in_anyIdtf2111( FOLLOW_osetIdtf_in_anyIdtf2111_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_alias_in_anyIdtf2132_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_alias_in_anyIdtf2132( FOLLOW_alias_in_anyIdtf2132_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_anyIdtf_in_idtf2199_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_anyIdtf_in_idtf2199( FOLLOW_anyIdtf_in_idtf2199_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_NAME_in_simpleIdtf2254_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_NAME_in_simpleIdtf2254( FOLLOW_NAME_in_simpleIdtf2254_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_URL_in_simpleIdtf2270_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_URL_in_simpleIdtf2270( FOLLOW_URL_in_simpleIdtf2270_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_idtfWithInt2322_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000802) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_idtfWithInt2322( FOLLOW_idtf_in_idtfWithInt2322_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_internal_in_idtfWithInt2346_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_internal_in_idtfWithInt2346( FOLLOW_internal_in_idtfWithInt2346_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_lv1_in_synpred2_SCs247_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_lv1_in_synpred2_SCs247( FOLLOW_sentence_lv1_in_synpred2_SCs247_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_attrsep_in_synpred3_SCs578_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_attrsep_in_synpred3_SCs578( FOLLOW_simpleIdtf_attrsep_in_synpred3_SCs578_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start syntax
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:53:1: syntax : (a= sentence_sentsep )* EOF ;
 */
void
SCsParser::syntax()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    SentenceWithSeparator* a;
    typedef	SentenceWithSeparator* RETURN_TYPE_a;

    /* Initialize rule variables
     */



    		  mNeedRecover = false;
    		  SyntaxAST* syntax = new SyntaxAST();
    		

 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:62:7: ( (a= sentence_sentsep )* EOF )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:63:7: (a= sentence_sentsep )* EOF
        {
            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:63:7: (a= sentence_sentsep )*

            for (;;)
            {
                int alt1=2;
                switch ( this->LA(1) )
                {
                case ALIASNONAME:
                case CONTENT:
                case LPAR:
                case LPAR_OSET:
                case LPAR_SET:
                case NAME:
                case URL:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:63:9: a= sentence_sentsep
            	    {
            	        this->followPush(FOLLOW_sentence_sentsep_in_syntax125);
            	        a=sentence_sentsep();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesyntaxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	             IFNR syntax->addSentence(a
            	            ); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


             this->matchToken(EOF, &FOLLOW_EOF_in_syntax135);
            if  (this->hasException())
            {
                goto rulesyntaxEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesyntaxEx; /* Prevent compiler warnings */
    rulesyntaxEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return ;
}
/* $ANTLR end syntax */

/**
 * $ANTLR start sentence_sentsep
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:66:1: sentence_sentsep returns [SentenceWithSeparator* retPtr] :a= sentence b= SENTSEP ;
 */
SentenceWithSeparator*
SCsParser::sentence_sentsep()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SentenceWithSeparator* retPtr;


    const CommonTokenType*    b;
    SentenceAST* a;
    typedef	SentenceAST* RETURN_TYPE_a;

    /* Initialize rule variables
     */


    		    SNRT
    		    retPtr = new SentenceWithSeparator();
    		
    b       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:75:5: (a= sentence b= SENTSEP )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:76:5: a= sentence b= SENTSEP
        {
            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_sentence_in_sentence_sentsep180);
            a=sentence();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_sentsepEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR retPtr->setSentence(a
                );                      
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            b =  this->matchToken(SENTSEP, &FOLLOW_SENTSEP_in_sentence_sentsep195);
            if  (this->hasException())
            {
                goto rulesentence_sentsepEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 SNRF retPtr->setSeparator(QString::fromStdString((b->getText())));
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesentence_sentsepEx; /* Prevent compiler warnings */
    rulesentence_sentsepEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end sentence_sentsep */

/**
 * $ANTLR start sentence
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:80:1: sentence returns [SentenceAST* retPtr] : (a= sentence_lv1 |b= sentence_lv23456 );
 */
SentenceAST*
SCsParser::sentence()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SentenceAST* retPtr;


    SentenceLvl1AST* a;
    typedef	SentenceLvl1AST* RETURN_TYPE_a;

    SentenceLv234561AST* b;
    typedef	SentenceLv234561AST* RETURN_TYPE_b;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new SentenceAST();
    		

 
    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:89:9: (a= sentence_lv1 |b= sentence_lv23456 )

            ANTLR_UINT32 alt2;

            alt2=2;

            switch ( this->LA(1) )
            {
            case NAME:
            case URL:
            	{
            		{
            		    int LA2_1 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred2_SCs>() )))
            		    {
            		        alt2=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt2=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return retPtr;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 2 );
            		        ex->set_state( 1 );


            		        goto rulesentenceEx;

            		    }
            		}
            	}
                break;
            case ALIASNONAME:
            case CONTENT:
            case LPAR:
            case LPAR_OSET:
            case LPAR_SET:
            	{
            		alt2=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retPtr;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 2 );
                ex->set_state( 0 );


                goto rulesentenceEx;

            }

            switch (alt2)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:90:9: a= sentence_lv1
        	    {
        	        if ( this->get_backtracking()==0 )
        	        {
        	            SNRT
        	        }


        	        this->followPush(FOLLOW_sentence_lv1_in_sentence247);
        	        a=sentence_lv1();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesentenceEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            IFNRR retPtr->addSentenceLvl1(a
        	            );        
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:91:9: b= sentence_lv23456
        	    {
        	        if ( this->get_backtracking()==0 )
        	        {
        	            SNRT
        	        }


        	        this->followPush(FOLLOW_sentence_lv23456_in_sentence273);
        	        b=sentence_lv23456();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesentenceEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	            IFNRR retPtr->addSentenceLv234561(b
        	            );    
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesentenceEx; /* Prevent compiler warnings */
    rulesentenceEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end sentence */

/**
 * $ANTLR start sentence_lv23456
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:95:1: sentence_lv23456 returns [SentenceLv234561AST* retPtr] :a= idtf b= CONNECTORS c= attrsList d= objectList ;
 */
SentenceLv234561AST*
SCsParser::sentence_lv23456()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SentenceLv234561AST* retPtr;


    const CommonTokenType*    b;
    IdentifierAST* a;
    typedef	IdentifierAST* RETURN_TYPE_a;

    AttributesListAST* c;
    typedef	AttributesListAST* RETURN_TYPE_c;

    ObjectListAST* d;
    typedef	ObjectListAST* RETURN_TYPE_d;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new SentenceLv234561AST();
    		
    b       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:104:5: (a= idtf b= CONNECTORS c= attrsList d= objectList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:105:5: a= idtf b= CONNECTORS c= attrsList d= objectList
        {
            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_idtf_in_sentence_lv23456322);
            a=idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR retPtr->setIdentifier(a
                );                       
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            b =  this->matchToken(CONNECTORS, &FOLLOW_CONNECTORS_in_sentence_lv23456348);
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 SNRF  retPtr->setConnector(QString::fromStdString((b->getText())));  
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_attrsList_in_sentence_lv23456369);
            c=attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR retPtr->setAttributeList(c
                );                    
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_objectList_in_sentence_lv23456390);
            d=objectList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR retPtr->setObjectList(d
                );                       
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesentence_lv23456Ex; /* Prevent compiler warnings */
    rulesentence_lv23456Ex: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end sentence_lv23456 */

/**
 * $ANTLR start sentence_lv1
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:113:1: sentence_lv1 returns [SentenceLvl1AST* retPtr] :a= simpleIdtf b= TRIPLESEP c= simpleIdtf d= TRIPLESEP e= simpleIdtf ;
 */
SentenceLvl1AST*
SCsParser::sentence_lv1()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SentenceLvl1AST* retPtr;


    const CommonTokenType*    b;
    const CommonTokenType*    d;
    SimpleIdentifierAST* a;
    typedef	SimpleIdentifierAST* RETURN_TYPE_a;

    SimpleIdentifierAST* c;
    typedef	SimpleIdentifierAST* RETURN_TYPE_c;

    SimpleIdentifierAST* e;
    typedef	SimpleIdentifierAST* RETURN_TYPE_e;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new SentenceLvl1AST();
    		
    b       = NULL;
    d       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:122:6: (a= simpleIdtf b= TRIPLESEP c= simpleIdtf d= TRIPLESEP e= simpleIdtf )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:123:6: a= simpleIdtf b= TRIPLESEP c= simpleIdtf d= TRIPLESEP e= simpleIdtf
        {
            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1444);
            a=simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR retPtr->setFirstIdentifier(a
                );                             
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            b =  this->matchToken(TRIPLESEP, &FOLLOW_TRIPLESEP_in_sentence_lv1464);
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 SNRF retPtr->setFirstTripleSeparator(QString::fromStdString((b->getText())));   
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1486);
            c=simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR retPtr->setSecondIdentifier(c
                );                            
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            d =  this->matchToken(TRIPLESEP, &FOLLOW_TRIPLESEP_in_sentence_lv1506);
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 SNRF retPtr->setSecondTripleSeparator(QString::fromStdString((d->getText())));  
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1527);
            e=simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR retPtr->setThirdIdentifier(e
                );                             
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesentence_lv1Ex; /* Prevent compiler warnings */
    rulesentence_lv1Ex: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end sentence_lv1 */

/**
 * $ANTLR start attrsList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:131:1: attrsList returns [AttributesListAST* retPtr] : (a= simpleIdtf_attrsep )* ;
 */
AttributesListAST*
SCsParser::attrsList()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    AttributesListAST* retPtr;


    SimpleIdtfrWAttrSepAST * a;
    typedef	SimpleIdtfrWAttrSepAST * RETURN_TYPE_a;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new AttributesListAST();
    		

 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:139:7: ( (a= simpleIdtf_attrsep )* )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:140:7: (a= simpleIdtf_attrsep )*
        {
            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:140:7: (a= simpleIdtf_attrsep )*

            for (;;)
            {
                int alt3=2;
                switch ( this->LA(1) )
                {
                case NAME:
                case URL:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    int LA3_1 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred3_SCs>() )))
                		    {
                		        alt3=1;
                		    }

                		}
                	}
                    break;

                }

                switch (alt3)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:140:9: a= simpleIdtf_attrsep
            	    {
            	        if ( this->get_backtracking()==0 )
            	        {
            	            SNRT
            	        }


            	        this->followPush(FOLLOW_simpleIdtf_attrsep_in_attrsList578);
            	        a=simpleIdtf_attrsep();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleattrsListEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retPtr;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	            IFNRR retPtr->addIdentifier(a
            	            ); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop3;	/* break out of the loop */
            	    break;
                }
            }
            loop3: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleattrsListEx; /* Prevent compiler warnings */
    ruleattrsListEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end attrsList */

/**
 * $ANTLR start simpleIdtf_attrsep
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:144:1: simpleIdtf_attrsep returns [SimpleIdtfrWAttrSepAST *retPtr] :a= simpleIdtf b= ATTRSEP ;
 */
SimpleIdtfrWAttrSepAST *
SCsParser::simpleIdtf_attrsep()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SimpleIdtfrWAttrSepAST * retPtr;


    const CommonTokenType*    b;
    SimpleIdentifierAST* a;
    typedef	SimpleIdentifierAST* RETURN_TYPE_a;

    /* Initialize rule variables
     */


    	    SNRT
    	    retPtr = new SimpleIdtfrWAttrSepAST();
    	  
    b       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:152:5: (a= simpleIdtf b= ATTRSEP )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:153:5: a= simpleIdtf b= ATTRSEP
        {
            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_simpleIdtf_in_simpleIdtf_attrsep629);
            a=simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimpleIdtf_attrsepEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR retPtr->setIdentifier(a
                );                 
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            b =  this->matchToken(ATTRSEP, &FOLLOW_ATTRSEP_in_simpleIdtf_attrsep645);
            if  (this->hasException())
            {
                goto rulesimpleIdtf_attrsepEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 SNRF  retPtr->setAttributeSeparator(QString::fromStdString((b->getText()))); 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesimpleIdtf_attrsepEx; /* Prevent compiler warnings */
    rulesimpleIdtf_attrsepEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end simpleIdtf_attrsep */

/**
 * $ANTLR start objectList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:158:1: objectList returns [ObjectListAST* retPtr] :a= idtfWithInt (b= objsep_IdtfWithInt )* ;
 */
ObjectListAST*
SCsParser::objectList()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    ObjectListAST* retPtr;


    IdentifierWithInternalAST* a;
    typedef	IdentifierWithInternalAST* RETURN_TYPE_a;

    ObjSepWIdtfWithInt* b;
    typedef	ObjSepWIdtfWithInt* RETURN_TYPE_b;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new ObjectListAST();
    		

 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:166:11: (a= idtfWithInt (b= objsep_IdtfWithInt )* )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:167:11: a= idtfWithInt (b= objsep_IdtfWithInt )*
        {
            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_idtfWithInt_in_objectList707);
            a=idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleobjectListEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR retPtr->setIdentifierWithInt(a
                );  
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:168:9: (b= objsep_IdtfWithInt )*

            for (;;)
            {
                int alt4=2;
                switch ( this->LA(1) )
                {
                case OBJSEP:
                	{
                		alt4=1;
                	}
                    break;

                }

                switch (alt4)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:168:11: b= objsep_IdtfWithInt
            	    {
            	        if ( this->get_backtracking()==0 )
            	        {
            	            SNRT
            	        }


            	        this->followPush(FOLLOW_objsep_IdtfWithInt_in_objectList735);
            	        b=objsep_IdtfWithInt();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleobjectListEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retPtr;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	             IFNRR retPtr->addIdentifier(b
            	            );         
            	        }


            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleobjectListEx; /* Prevent compiler warnings */
    ruleobjectListEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end objectList */

/**
 * $ANTLR start objsep_IdtfWithInt
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:173:1: objsep_IdtfWithInt returns [ObjSepWIdtfWithInt* retPtr] :a= OBJSEP b= idtfWithInt ;
 */
ObjSepWIdtfWithInt*
SCsParser::objsep_IdtfWithInt()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    ObjSepWIdtfWithInt* retPtr;


    const CommonTokenType*    a;
    IdentifierWithInternalAST* b;
    typedef	IdentifierWithInternalAST* RETURN_TYPE_b;

    /* Initialize rule variables
     */


    	    SNRT
    	    retPtr = new ObjSepWIdtfWithInt();
    	  
    a       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:181:5: (a= OBJSEP b= idtfWithInt )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:182:5: a= OBJSEP b= idtfWithInt
        {
            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            a =  this->matchToken(OBJSEP, &FOLLOW_OBJSEP_in_objsep_IdtfWithInt785);
            if  (this->hasException())
            {
                goto ruleobjsep_IdtfWithIntEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 SNRF  retPtr->setObjectSeparator(QString::fromStdString((a->getText())));  
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_idtfWithInt_in_objsep_IdtfWithInt807);
            b=idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleobjsep_IdtfWithIntEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR retPtr->setIdentifierWithInternal(b
                );                 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleobjsep_IdtfWithIntEx; /* Prevent compiler warnings */
    ruleobjsep_IdtfWithIntEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end objsep_IdtfWithInt */

/**
 * $ANTLR start intSentence
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:187:1: intSentence returns [InternalSentenceAST* retPtr] :a= CONNECTORS b= attrsList c= objectList ;
 */
InternalSentenceAST*
SCsParser::intSentence()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    InternalSentenceAST* retPtr;


    const CommonTokenType*    a;
    AttributesListAST* b;
    typedef	AttributesListAST* RETURN_TYPE_b;

    ObjectListAST* c;
    typedef	ObjectListAST* RETURN_TYPE_c;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new InternalSentenceAST();
    		
    a       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:195:9: (a= CONNECTORS b= attrsList c= objectList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:196:9: a= CONNECTORS b= attrsList c= objectList
        {
            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            a =  this->matchToken(CONNECTORS, &FOLLOW_CONNECTORS_in_intSentence861);
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 SNRF  retPtr->setConnector(QString::fromStdString((a->getText())));  
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_attrsList_in_intSentence882);
            b=attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR retPtr->setAttributeList(b
                );  
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_objectList_in_intSentence904);
            c=objectList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR retPtr->setObjectList(c
                );  
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintSentenceEx; /* Prevent compiler warnings */
    ruleintSentenceEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end intSentence */

/**
 * $ANTLR start intSentenceList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:202:1: intSentenceList returns [InternalSentenceListAST* retPtr] :a= LPAR_INT (b= intSentence_sentsep )+ c= RPAR_INT ;
 */
InternalSentenceListAST*
SCsParser::intSentenceList()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    InternalSentenceListAST* retPtr;


    const CommonTokenType*    a;
    const CommonTokenType*    c;
    IntSentenceWSentSep* b;
    typedef	IntSentenceWSentSep* RETURN_TYPE_b;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new InternalSentenceListAST();
    		
    a       = NULL;
    c       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:210:11: (a= LPAR_INT (b= intSentence_sentsep )+ c= RPAR_INT )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:211:11: a= LPAR_INT (b= intSentence_sentsep )+ c= RPAR_INT
        {
            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            a =  this->matchToken(LPAR_INT, &FOLLOW_LPAR_INT_in_intSentenceList959);
            if  (this->hasException())
            {
                goto ruleintSentenceListEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 SNRF  retPtr->setLeftInternalSeparator(QString::fromStdString((a->getText())));  
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:212:9: (b= intSentence_sentsep )+
            {
                int cnt5=0;

                for (;;)
                {
                    int alt5=2;
            	switch ( this->LA(1) )
            	{
            	case CONNECTORS:
            		{
            			alt5=1;
            		}
            	    break;

            	}

            	switch (alt5)
            	{
            	    case 1:
            	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:212:11: b= intSentence_sentsep
            	        {
            	            if ( this->get_backtracking()==0 )
            	            {
            	                SNRT
            	            }


            	            this->followPush(FOLLOW_intSentence_sentsep_in_intSentenceList994);
            	            b=intSentence_sentsep();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleintSentenceListEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return retPtr;
            	            }


            	            if ( this->get_backtracking()==0 )
            	            {
            	                 IFNRR retPtr->addSentence(b
            	                );                                     
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt5 >= 1 )
            		{
            		    goto loop5;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return retPtr;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< SCsParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleintSentenceListEx;
            	}
            	cnt5++;
                }
                loop5: ;	/* Jump to here if this rule does not match */
            }

            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            c =  this->matchToken(RPAR_INT, &FOLLOW_RPAR_INT_in_intSentenceList1024);
            if  (this->hasException())
            {
                goto ruleintSentenceListEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 SNRF  retPtr->setRigthInternalSeparator(QString::fromStdString((c->getText()))); 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintSentenceListEx; /* Prevent compiler warnings */
    ruleintSentenceListEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end intSentenceList */

/**
 * $ANTLR start intSentence_sentsep
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:216:1: intSentence_sentsep returns [IntSentenceWSentSep* retPtr] :a= intSentence b= SENTSEP ;
 */
IntSentenceWSentSep*
SCsParser::intSentence_sentsep()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    IntSentenceWSentSep* retPtr;


    const CommonTokenType*    b;
    InternalSentenceAST* a;
    typedef	InternalSentenceAST* RETURN_TYPE_a;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new IntSentenceWSentSep();
    		
    b       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:224:5: (a= intSentence b= SENTSEP )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:225:5: a= intSentence b= SENTSEP
        {
            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_intSentence_in_intSentence_sentsep1084);
            a=intSentence();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleintSentence_sentsepEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR   retPtr->setInternalSentence(a
                );                         
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            b =  this->matchToken(SENTSEP, &FOLLOW_SENTSEP_in_intSentence_sentsep1108);
            if  (this->hasException())
            {
                goto ruleintSentence_sentsepEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 SNRF    retPtr->setSentenceSeparator(QString::fromStdString((b->getText())));  
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintSentence_sentsepEx; /* Prevent compiler warnings */
    ruleintSentence_sentsepEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end intSentence_sentsep */

/**
 * $ANTLR start internal
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:229:1: internal returns [InternalAST* retPtr] :a= intSentenceList ;
 */
InternalAST*
SCsParser::internal()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    InternalAST* retPtr;


    InternalSentenceListAST* a;
    typedef	InternalSentenceListAST* RETURN_TYPE_a;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new InternalAST();
    		

 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:237:4: (a= intSentenceList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:238:4: a= intSentenceList
        {
            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_intSentenceList_in_internal1164);
            a=intSentenceList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleinternalEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR   retPtr->setInternalSentenceList(a
                );   
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinternalEx; /* Prevent compiler warnings */
    ruleinternalEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end internal */

/**
 * $ANTLR start triple
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:241:1: triple returns [TripleAST* retPtr] :a= LPAR b= idtf c= CONTENT d= idtf e= RPAR ;
 */
TripleAST*
SCsParser::triple()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    TripleAST* retPtr;


    const CommonTokenType*    a;
    const CommonTokenType*    c;
    const CommonTokenType*    e;
    IdentifierAST* b;
    typedef	IdentifierAST* RETURN_TYPE_b;

    IdentifierAST* d;
    typedef	IdentifierAST* RETURN_TYPE_d;

    /* Initialize rule variables
     */


          SNRT
          retPtr = new TripleAST();
        
    a       = NULL;
    c       = NULL;
    e       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:249:7: (a= LPAR b= idtf c= CONTENT d= idtf e= RPAR )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:250:7: a= LPAR b= idtf c= CONTENT d= idtf e= RPAR
        {
            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            a =  this->matchToken(LPAR, &FOLLOW_LPAR_in_triple1223);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 SNRF    retPtr->setLeftPar(QString::fromStdString((a->getText())));   
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_idtf_in_triple1246);
            b=idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletripleEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR   retPtr->setFirstIdentifier(b
                );                 
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            c =  this->matchToken(CONTENT, &FOLLOW_CONTENT_in_triple1268);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 SNRF    retPtr->setContent(QString::fromStdString((c->getText())));   
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_idtf_in_triple1288);
            d=idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletripleEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR   retPtr->setSecondIdentifier(d
                );                
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            e =  this->matchToken(RPAR, &FOLLOW_RPAR_in_triple1310);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 SNRF    retPtr->setRighPar(QString::fromStdString((e->getText())));   
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletripleEx; /* Prevent compiler warnings */
    ruletripleEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end triple */

/**
 * $ANTLR start alias
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:257:1: alias returns [AliasAST* retPtr] :a= ALIASNONAME ;
 */
AliasAST*
SCsParser::alias()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    AliasAST* retPtr;


    const CommonTokenType*    a;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new AliasAST();
    		
    a       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:266:7: (a= ALIASNONAME )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:267:7: a= ALIASNONAME
        {
            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            a =  this->matchToken(ALIASNONAME, &FOLLOW_ALIASNONAME_in_alias1366);
            if  (this->hasException())
            {
                goto rulealiasEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 SNRF     retPtr->setAlias(QString::fromStdString((a->getText()))); 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealiasEx; /* Prevent compiler warnings */
    rulealiasEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end alias */

/**
 * $ANTLR start setIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:271:1: setIdtf returns [SetIdentifierAST* retPtr] :a= LPAR_SET b= attrsList c= idtfWithInt (d= objsep_AttrsList_idtfWithInt )* e= RPAR_SET ;
 */
SetIdentifierAST*
SCsParser::setIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SetIdentifierAST* retPtr;


    const CommonTokenType*    a;
    const CommonTokenType*    e;
    AttributesListAST* b;
    typedef	AttributesListAST* RETURN_TYPE_b;

    IdentifierWithInternalAST* c;
    typedef	IdentifierWithInternalAST* RETURN_TYPE_c;

    ObjSepWAttrListWIdtfWithInt* d;
    typedef	ObjSepWAttrListWIdtfWithInt* RETURN_TYPE_d;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new SetIdentifierAST();
    		
    a       = NULL;
    e       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:279:9: (a= LPAR_SET b= attrsList c= idtfWithInt (d= objsep_AttrsList_idtfWithInt )* e= RPAR_SET )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:280:9: a= LPAR_SET b= attrsList c= idtfWithInt (d= objsep_AttrsList_idtfWithInt )* e= RPAR_SET
        {
            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            a =  this->matchToken(LPAR_SET, &FOLLOW_LPAR_SET_in_setIdtf1428);
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 SNRF     retPtr->setLeftSeparator(QString::fromStdString((a->getText())));    
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_attrsList_in_setIdtf1475);
            b=attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR    retPtr->setAttributeList(b
                );                          
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_idtfWithInt_in_setIdtf1521);
            c=idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR    retPtr->setIdentifier(c
                );                             
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:283:7: (d= objsep_AttrsList_idtfWithInt )*

            for (;;)
            {
                int alt6=2;
                switch ( this->LA(1) )
                {
                case OBJSEP:
                	{
                		alt6=1;
                	}
                    break;

                }

                switch (alt6)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:283:9: d= objsep_AttrsList_idtfWithInt
            	    {
            	        if ( this->get_backtracking()==0 )
            	        {
            	            SNRT
            	        }


            	        this->followPush(FOLLOW_objsep_AttrsList_idtfWithInt_in_setIdtf1566);
            	        d=objsep_AttrsList_idtfWithInt();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesetIdtfEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retPtr;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	             IFNRR    retPtr->addSentence(d
            	            );                               
            	        }


            	    }
            	    break;

            	default:
            	    goto loop6;	/* break out of the loop */
            	    break;
                }
            }
            loop6: ; /* Jump out to here if this rule does not match */


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            e =  this->matchToken(RPAR_SET, &FOLLOW_RPAR_SET_in_setIdtf1597);
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 SNRF     retPtr->setRightSeparator(QString::fromStdString((e->getText())));   
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesetIdtfEx; /* Prevent compiler warnings */
    rulesetIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end setIdtf */

/**
 * $ANTLR start objsep_AttrsList_idtfWithInt
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:287:1: objsep_AttrsList_idtfWithInt returns [ObjSepWAttrListWIdtfWithInt* retPtr] :a= OBJSEP b= attrsList c= idtfWithInt ;
 */
ObjSepWAttrListWIdtfWithInt*
SCsParser::objsep_AttrsList_idtfWithInt()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    ObjSepWAttrListWIdtfWithInt* retPtr;


    const CommonTokenType*    a;
    AttributesListAST* b;
    typedef	AttributesListAST* RETURN_TYPE_b;

    IdentifierWithInternalAST* c;
    typedef	IdentifierWithInternalAST* RETURN_TYPE_c;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new ObjSepWAttrListWIdtfWithInt();
    		
    a       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:295:4: (a= OBJSEP b= attrsList c= idtfWithInt )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:296:4: a= OBJSEP b= attrsList c= idtfWithInt
        {
            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            a =  this->matchToken(OBJSEP, &FOLLOW_OBJSEP_in_objsep_AttrsList_idtfWithInt1666);
            if  (this->hasException())
            {
                goto ruleobjsep_AttrsList_idtfWithIntEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 SNRF     retPtr->setSeparator(QString::fromStdString((a->getText())));    
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_attrsList_in_objsep_AttrsList_idtfWithInt1689);
            b=attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleobjsep_AttrsList_idtfWithIntEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR    retPtr->setAttributeList(b
                );                      
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_idtfWithInt_in_objsep_AttrsList_idtfWithInt1708);
            c=idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleobjsep_AttrsList_idtfWithIntEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR    retPtr->setIdentifier(c
                );                         
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleobjsep_AttrsList_idtfWithIntEx; /* Prevent compiler warnings */
    ruleobjsep_AttrsList_idtfWithIntEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end objsep_AttrsList_idtfWithInt */

/**
 * $ANTLR start osetIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:302:1: osetIdtf returns [OSetIdentifierAST* retPtr] :a= LPAR_OSET b= attrsList c= idtfWithInt (d= objsep_AttrsList_idtfWithInt )* e= RPAR_OSET ;
 */
OSetIdentifierAST*
SCsParser::osetIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    OSetIdentifierAST* retPtr;


    const CommonTokenType*    a;
    const CommonTokenType*    e;
    AttributesListAST* b;
    typedef	AttributesListAST* RETURN_TYPE_b;

    IdentifierWithInternalAST* c;
    typedef	IdentifierWithInternalAST* RETURN_TYPE_c;

    ObjSepWAttrListWIdtfWithInt* d;
    typedef	ObjSepWAttrListWIdtfWithInt* RETURN_TYPE_d;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new OSetIdentifierAST();
    		
    a       = NULL;
    e       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:310:9: (a= LPAR_OSET b= attrsList c= idtfWithInt (d= objsep_AttrsList_idtfWithInt )* e= RPAR_OSET )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:311:9: a= LPAR_OSET b= attrsList c= idtfWithInt (d= objsep_AttrsList_idtfWithInt )* e= RPAR_OSET
        {
            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            a =  this->matchToken(LPAR_OSET, &FOLLOW_LPAR_OSET_in_osetIdtf1766);
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                  retPtr->setLeftSeparator(QString::fromStdString((a->getText())));   
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_attrsList_in_osetIdtf1815);
            b=attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR   retPtr->setAttributeList(b
                );                         
            }


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_idtfWithInt_in_osetIdtf1864);
            c=idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR   retPtr->setIdentifier(c
                );                            
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:314:7: (d= objsep_AttrsList_idtfWithInt )*

            for (;;)
            {
                int alt7=2;
                switch ( this->LA(1) )
                {
                case OBJSEP:
                	{
                		alt7=1;
                	}
                    break;

                }

                switch (alt7)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:314:9: d= objsep_AttrsList_idtfWithInt
            	    {
            	        if ( this->get_backtracking()==0 )
            	        {
            	            SNRT
            	        }


            	        this->followPush(FOLLOW_objsep_AttrsList_idtfWithInt_in_osetIdtf1913);
            	        d=objsep_AttrsList_idtfWithInt();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleosetIdtfEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retPtr;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	             IFNRR   retPtr->addSentence(d
            	            );                              
            	        }


            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            e =  this->matchToken(RPAR_OSET, &FOLLOW_RPAR_OSET_in_osetIdtf1948);
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 SNRF    retPtr->setRightSeparator(QString::fromStdString((e->getText())));  
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleosetIdtfEx; /* Prevent compiler warnings */
    ruleosetIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end osetIdtf */

/**
 * $ANTLR start anyIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:318:1: anyIdtf returns [AnyIdentifierAST* retPtr] : (a= simpleIdtf |b= CONTENT |c= triple |d= setIdtf |e= osetIdtf |f= alias );
 */
AnyIdentifierAST*
SCsParser::anyIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    AnyIdentifierAST* retPtr;


    const CommonTokenType*    b;
    SimpleIdentifierAST* a;
    typedef	SimpleIdentifierAST* RETURN_TYPE_a;

    TripleAST* c;
    typedef	TripleAST* RETURN_TYPE_c;

    SetIdentifierAST* d;
    typedef	SetIdentifierAST* RETURN_TYPE_d;

    OSetIdentifierAST* e;
    typedef	OSetIdentifierAST* RETURN_TYPE_e;

    AliasAST* f;
    typedef	AliasAST* RETURN_TYPE_f;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new AnyIdentifierAST();
    		
    b       = NULL;


 
    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:325:5: (a= simpleIdtf |b= CONTENT |c= triple |d= setIdtf |e= osetIdtf |f= alias )

            ANTLR_UINT32 alt8;

            alt8=6;

            switch ( this->LA(1) )
            {
            case NAME:
            case URL:
            	{
            		alt8=1;
            	}
                break;
            case CONTENT:
            	{
            		alt8=2;
            	}
                break;
            case LPAR:
            	{
            		alt8=3;
            	}
                break;
            case LPAR_SET:
            	{
            		alt8=4;
            	}
                break;
            case LPAR_OSET:
            	{
            		alt8=5;
            	}
                break;
            case ALIASNONAME:
            	{
            		alt8=6;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retPtr;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 8 );
                ex->set_state( 0 );


                goto ruleanyIdtfEx;

            }

            switch (alt8)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:326:9: a= simpleIdtf
        	    {
        	        if ( this->get_backtracking()==0 )
        	        {
        	            SNRT
        	        }


        	        this->followPush(FOLLOW_simpleIdtf_in_anyIdtf2025);
        	        a=simpleIdtf();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	             IFNRR retPtr->setSimpleIdentifier( a
        	             );             
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:327:9: b= CONTENT
        	    {
        	        if ( this->get_backtracking()==0 )
        	        {
        	            SNRT
        	        }


        	        b =  this->matchToken(CONTENT, &FOLLOW_CONTENT_in_anyIdtf2044);
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	             SNRF  retPtr->setContent(QString::fromStdString((b->getText())));  
        	        }


        	    }
        	    break;
        	case 3:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:328:9: c= triple
        	    {
        	        if ( this->get_backtracking()==0 )
        	        {
        	            SNRT
        	        }


        	        this->followPush(FOLLOW_triple_in_anyIdtf2066);
        	        c=triple();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	             IFNRR retPtr->setTriple(c
        	            );                         
        	        }


        	    }
        	    break;
        	case 4:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:329:9: d= setIdtf
        	    {
        	        if ( this->get_backtracking()==0 )
        	        {
        	            SNRT
        	        }


        	        this->followPush(FOLLOW_setIdtf_in_anyIdtf2089);
        	        d=setIdtf();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	             IFNRR retPtr->setSetIdentifier(d
        	            );                  
        	        }


        	    }
        	    break;
        	case 5:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:330:9: e= osetIdtf
        	    {
        	        if ( this->get_backtracking()==0 )
        	        {
        	            SNRT
        	        }


        	        this->followPush(FOLLOW_osetIdtf_in_anyIdtf2111);
        	        e=osetIdtf();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	             IFNRR retPtr->setOSetIdentifier(e
        	            );                 
        	        }


        	    }
        	    break;
        	case 6:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:331:9: f= alias
        	    {
        	        if ( this->get_backtracking()==0 )
        	        {
        	            SNRT
        	        }


        	        this->followPush(FOLLOW_alias_in_anyIdtf2132);
        	        f=alias();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	             IFNRR retPtr->setAlias(f
        	            );                          
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleanyIdtfEx; /* Prevent compiler warnings */
    ruleanyIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end anyIdtf */

/**
 * $ANTLR start idtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:336:1: idtf returns [IdentifierAST* retPtr] :a= anyIdtf ;
 */
IdentifierAST*
SCsParser::idtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    IdentifierAST* retPtr;


    AnyIdentifierAST* a;
    typedef	AnyIdentifierAST* RETURN_TYPE_a;

    /* Initialize rule variables
     */


    			  SNRT
    			  retPtr = new IdentifierAST();
    			

 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:343:5: (a= anyIdtf )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:344:5: a= anyIdtf
        {
            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_anyIdtf_in_idtf2199);
            a=anyIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleidtfEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR  retPtr->setIdentifier(a
                ); 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleidtfEx; /* Prevent compiler warnings */
    ruleidtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end idtf */

/**
 * $ANTLR start simpleIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:347:1: simpleIdtf returns [SimpleIdentifierAST* retPtr] : (a= NAME |b= URL );
 */
SimpleIdentifierAST*
SCsParser::simpleIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SimpleIdentifierAST* retPtr;


    const CommonTokenType*    a;
    const CommonTokenType*    b;

    /* Initialize rule variables
     */


    			  SNRT
    			  retPtr = new SimpleIdentifierAST();
    			
    a       = NULL;
    b       = NULL;


 
    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:356:6: (a= NAME |b= URL )

            ANTLR_UINT32 alt9;

            alt9=2;

            switch ( this->LA(1) )
            {
            case NAME:
            	{
            		alt9=1;
            	}
                break;
            case URL:
            	{
            		alt9=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retPtr;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 9 );
                ex->set_state( 0 );


                goto rulesimpleIdtfEx;

            }

            switch (alt9)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:357:6: a= NAME
        	    {
        	        if ( this->get_backtracking()==0 )
        	        {
        	            SNRT
        	        }


        	        a =  this->matchToken(NAME, &FOLLOW_NAME_in_simpleIdtf2254);
        	        if  (this->hasException())
        	        {
        	            goto rulesimpleIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	              SNRF retPtr->setName(QString::fromStdString((a->getText())));  
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:358:6: b= URL
        	    {
        	        if ( this->get_backtracking()==0 )
        	        {
        	            SNRT
        	        }


        	        b =  this->matchToken(URL, &FOLLOW_URL_in_simpleIdtf2270);
        	        if  (this->hasException())
        	        {
        	            goto rulesimpleIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	              SNRF retPtr->setUrl(QString::fromStdString((b->getText())));  
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesimpleIdtfEx; /* Prevent compiler warnings */
    rulesimpleIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end simpleIdtf */

/**
 * $ANTLR start idtfWithInt
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:363:1: idtfWithInt returns [IdentifierWithInternalAST* retPtr] :a= idtf (b= internal )? ;
 */
IdentifierWithInternalAST*
SCsParser::idtfWithInt()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    IdentifierWithInternalAST* retPtr;


    IdentifierAST* a;
    typedef	IdentifierAST* RETURN_TYPE_a;

    InternalAST* b;
    typedef	InternalAST* RETURN_TYPE_b;

    /* Initialize rule variables
     */


    	  SNRT
    	  retPtr = new IdentifierWithInternalAST();
    	

 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:371:7: (a= idtf (b= internal )? )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:372:7: a= idtf (b= internal )?
        {
            if ( this->get_backtracking()==0 )
            {
                SNRT
            }


            this->followPush(FOLLOW_idtf_in_idtfWithInt2322);
            a=idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleidtfWithIntEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
                 IFNRR   retPtr->setIdentifier(a
                );  
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:373:5: (b= internal )?
            {
                int alt10=2;
                switch ( this->LA(1) )
                {
                    case LPAR_INT:
                    	{
                    		alt10=1;
                    	}
                        break;
                }

                switch (alt10)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:373:7: b= internal
            	    {
            	        if ( this->get_backtracking()==0 )
            	        {
            	            SNRT
            	        }


            	        this->followPush(FOLLOW_internal_in_idtfWithInt2346);
            	        b=internal();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleidtfWithIntEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retPtr;
            	        }


            	        if ( this->get_backtracking()==0 )
            	        {
            	             IFNRR   retPtr->setInternal(b
            	            );  
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleidtfWithIntEx; /* Prevent compiler warnings */
    ruleidtfWithIntEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end idtfWithInt */

// $ANTLR start synpred2_SCs
void SCsParser::msynpred2_SCs_fragment(  )
{
	SentenceLvl1AST* a;
	typedef	SentenceLvl1AST* RETURN_TYPE_a;

    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:90:9: (a= sentence_lv1 )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:90:9: a= sentence_lv1
    {
        this->followPush(FOLLOW_sentence_lv1_in_synpred2_SCs247);
        a=sentence_lv1();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred2_SCsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred2_SCsEx; /* Prevent compiler warnings */
rulesynpred2_SCsEx: ;

}
// $ANTLR end synpred2_SCs

// $ANTLR start synpred3_SCs
void SCsParser::msynpred3_SCs_fragment(  )
{
	SimpleIdtfrWAttrSepAST * a;
	typedef	SimpleIdtfrWAttrSepAST * RETURN_TYPE_a;

    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:140:9: (a= simpleIdtf_attrsep )
    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:140:9: a= simpleIdtf_attrsep
    {
        this->followPush(FOLLOW_simpleIdtf_attrsep_in_synpred3_SCs578);
        a=simpleIdtf_attrsep();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred3_SCsEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred3_SCsEx; /* Prevent compiler warnings */
rulesynpred3_SCsEx: ;

}
// $ANTLR end synpred3_SCs
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
bool SCsParser::msynpred( antlr3::ClassForwarder< synpred2_SCs >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred2_SCs_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool SCsParser::msynpred( antlr3::ClassForwarder< synpred3_SCs >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred3_SCs_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

	}


/* End of code
 * =============================================================================
 */
