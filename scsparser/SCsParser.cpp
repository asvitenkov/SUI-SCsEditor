/** \file
 *  This C++ source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g
 *     -                            On : 2013-04-03 08:49:46
 *     -                for the parser : SCsParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SCsParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

	namespace  SCsParserNS  {

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   SCsParserTokenNames[23+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "ALIASNONAME",
        (ANTLR_UINT8*) "ATTRSEP",
        (ANTLR_UINT8*) "COMMENT",
        (ANTLR_UINT8*) "CONNECTORS",
        (ANTLR_UINT8*) "CONTENT",
        (ANTLR_UINT8*) "ELEMTYPE",
        (ANTLR_UINT8*) "LPAR",
        (ANTLR_UINT8*) "LPAR_INT",
        (ANTLR_UINT8*) "LPAR_OSET",
        (ANTLR_UINT8*) "LPAR_SET",
        (ANTLR_UINT8*) "LPAR_TRF",
        (ANTLR_UINT8*) "NAME",
        (ANTLR_UINT8*) "OBJSEP",
        (ANTLR_UINT8*) "RPAR",
        (ANTLR_UINT8*) "RPAR_INT",
        (ANTLR_UINT8*) "RPAR_OSET",
        (ANTLR_UINT8*) "RPAR_SET",
        (ANTLR_UINT8*) "RPAR_TRF",
        (ANTLR_UINT8*) "SENTSEP",
        (ANTLR_UINT8*) "SYNSEP",
        (ANTLR_UINT8*) "TRIPLESEP",
        (ANTLR_UINT8*) "URL",
        (ANTLR_UINT8*) "WS"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* SCsParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new SCsParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SCsParser::SCsParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new SCsParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SCsParser::SCsParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void SCsParser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( SCsParserTokenNames );


}

void
SCsParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
SCsParser::~SCsParser()
 {
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return SCsParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_sentsep_in_syntax103_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_sentsep_in_syntax103( FOLLOW_sentence_sentsep_in_syntax103_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_EOF_in_syntax113_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_EOF_in_syntax113( FOLLOW_EOF_in_syntax113_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_in_sentence_sentsep158_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_in_sentence_sentsep158( FOLLOW_sentence_in_sentence_sentsep158_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_SENTSEP_in_sentence_sentsep173_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_SENTSEP_in_sentence_sentsep173( FOLLOW_SENTSEP_in_sentence_sentsep173_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_lv1_in_sentence225_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_lv1_in_sentence225( FOLLOW_sentence_lv1_in_sentence225_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_lv23456_in_sentence251_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_lv23456_in_sentence251( FOLLOW_sentence_lv23456_in_sentence251_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_sentence_lv23456300_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_sentence_lv23456300( FOLLOW_idtf_in_sentence_lv23456300_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONNECTORS_in_sentence_lv23456326_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONNECTORS_in_sentence_lv23456326( FOLLOW_CONNECTORS_in_sentence_lv23456326_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_sentence_lv23456347_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_sentence_lv23456347( FOLLOW_attrsList_in_sentence_lv23456347_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objectList_in_sentence_lv23456368_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objectList_in_sentence_lv23456368( FOLLOW_objectList_in_sentence_lv23456368_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1422_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1422( FOLLOW_simpleIdtf_in_sentence_lv1422_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_TRIPLESEP_in_sentence_lv1442_bits[]	= { ANTLR_UINT64_LIT(0x0000000002008000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_TRIPLESEP_in_sentence_lv1442( FOLLOW_TRIPLESEP_in_sentence_lv1442_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1464_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1464( FOLLOW_simpleIdtf_in_sentence_lv1464_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_TRIPLESEP_in_sentence_lv1484_bits[]	= { ANTLR_UINT64_LIT(0x0000000002008000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_TRIPLESEP_in_sentence_lv1484( FOLLOW_TRIPLESEP_in_sentence_lv1484_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1505_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1505( FOLLOW_simpleIdtf_in_sentence_lv1505_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_attrsep_in_attrsList556_bits[]	= { ANTLR_UINT64_LIT(0x0000000002008002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_attrsep_in_attrsList556( FOLLOW_simpleIdtf_attrsep_in_attrsList556_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_simpleIdtf_attrsep607_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000020) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_simpleIdtf_attrsep607( FOLLOW_simpleIdtf_in_simpleIdtf_attrsep607_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_ATTRSEP_in_simpleIdtf_attrsep623_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_ATTRSEP_in_simpleIdtf_attrsep623( FOLLOW_ATTRSEP_in_simpleIdtf_attrsep623_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_objectList685_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_objectList685( FOLLOW_idtfWithInt_in_objectList685_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objsep_IdtfWithInt_in_objectList713_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objsep_IdtfWithInt_in_objectList713( FOLLOW_objsep_IdtfWithInt_in_objectList713_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_OBJSEP_in_objsep_IdtfWithInt763_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_OBJSEP_in_objsep_IdtfWithInt763( FOLLOW_OBJSEP_in_objsep_IdtfWithInt763_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_objsep_IdtfWithInt785_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_objsep_IdtfWithInt785( FOLLOW_idtfWithInt_in_objsep_IdtfWithInt785_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONNECTORS_in_intSentence839_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONNECTORS_in_intSentence839( FOLLOW_CONNECTORS_in_intSentence839_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_intSentence860_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_intSentence860( FOLLOW_attrsList_in_intSentence860_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objectList_in_intSentence882_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objectList_in_intSentence882( FOLLOW_objectList_in_intSentence882_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_INT_in_intSentenceList937_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_INT_in_intSentenceList937( FOLLOW_LPAR_INT_in_intSentenceList937_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_intSentence_sentsep_in_intSentenceList972_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040080) };
static  SCsParserImplTraits::BitsetListType FOLLOW_intSentence_sentsep_in_intSentenceList972( FOLLOW_intSentence_sentsep_in_intSentenceList972_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_INT_in_intSentenceList1002_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_INT_in_intSentenceList1002( FOLLOW_RPAR_INT_in_intSentenceList1002_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_intSentence_in_intSentence_sentsep1062_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_intSentence_in_intSentence_sentsep1062( FOLLOW_intSentence_in_intSentence_sentsep1062_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_SENTSEP_in_intSentence_sentsep1086_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_SENTSEP_in_intSentence_sentsep1086( FOLLOW_SENTSEP_in_intSentence_sentsep1086_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_intSentenceList_in_internal1142_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_intSentenceList_in_internal1142( FOLLOW_intSentenceList_in_internal1142_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_in_triple1201_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_in_triple1201( FOLLOW_LPAR_in_triple1201_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_triple1224_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000100) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_triple1224( FOLLOW_idtf_in_triple1224_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONTENT_in_triple1246_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONTENT_in_triple1246( FOLLOW_CONTENT_in_triple1246_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_triple1266_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_triple1266( FOLLOW_idtf_in_triple1266_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_in_triple1288_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_in_triple1288( FOLLOW_RPAR_in_triple1288_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_ALIASNONAME_in_alias1344_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_ALIASNONAME_in_alias1344( FOLLOW_ALIASNONAME_in_alias1344_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_SET_in_setIdtf1406_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_SET_in_setIdtf1406( FOLLOW_LPAR_SET_in_setIdtf1406_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_setIdtf1453_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_setIdtf1453( FOLLOW_attrsList_in_setIdtf1453_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_setIdtf1499_bits[]	= { ANTLR_UINT64_LIT(0x0000000000110000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_setIdtf1499( FOLLOW_idtfWithInt_in_setIdtf1499_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objsep_AttrsList_idtfWithInt_in_setIdtf1544_bits[]	= { ANTLR_UINT64_LIT(0x0000000000110000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objsep_AttrsList_idtfWithInt_in_setIdtf1544( FOLLOW_objsep_AttrsList_idtfWithInt_in_setIdtf1544_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_SET_in_setIdtf1575_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_SET_in_setIdtf1575( FOLLOW_RPAR_SET_in_setIdtf1575_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_OBJSEP_in_objsep_AttrsList_idtfWithInt1644_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_OBJSEP_in_objsep_AttrsList_idtfWithInt1644( FOLLOW_OBJSEP_in_objsep_AttrsList_idtfWithInt1644_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_objsep_AttrsList_idtfWithInt1667_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_objsep_AttrsList_idtfWithInt1667( FOLLOW_attrsList_in_objsep_AttrsList_idtfWithInt1667_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_objsep_AttrsList_idtfWithInt1686_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_objsep_AttrsList_idtfWithInt1686( FOLLOW_idtfWithInt_in_objsep_AttrsList_idtfWithInt1686_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_OSET_in_osetIdtf1744_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_OSET_in_osetIdtf1744( FOLLOW_LPAR_OSET_in_osetIdtf1744_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_osetIdtf1793_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_osetIdtf1793( FOLLOW_attrsList_in_osetIdtf1793_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_osetIdtf1842_bits[]	= { ANTLR_UINT64_LIT(0x0000000000090000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_osetIdtf1842( FOLLOW_idtfWithInt_in_osetIdtf1842_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objsep_AttrsList_idtfWithInt_in_osetIdtf1891_bits[]	= { ANTLR_UINT64_LIT(0x0000000000090000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objsep_AttrsList_idtfWithInt_in_osetIdtf1891( FOLLOW_objsep_AttrsList_idtfWithInt_in_osetIdtf1891_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_OSET_in_osetIdtf1926_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_OSET_in_osetIdtf1926( FOLLOW_RPAR_OSET_in_osetIdtf1926_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_anyIdtf2003_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_anyIdtf2003( FOLLOW_simpleIdtf_in_anyIdtf2003_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONTENT_in_anyIdtf2022_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONTENT_in_anyIdtf2022( FOLLOW_CONTENT_in_anyIdtf2022_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_triple_in_anyIdtf2044_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_triple_in_anyIdtf2044( FOLLOW_triple_in_anyIdtf2044_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_setIdtf_in_anyIdtf2067_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_setIdtf_in_anyIdtf2067( FOLLOW_setIdtf_in_anyIdtf2067_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_osetIdtf_in_anyIdtf2089_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_osetIdtf_in_anyIdtf2089( FOLLOW_osetIdtf_in_anyIdtf2089_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_alias_in_anyIdtf2110_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_alias_in_anyIdtf2110( FOLLOW_alias_in_anyIdtf2110_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_anyIdtf_in_idtf2177_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_anyIdtf_in_idtf2177( FOLLOW_anyIdtf_in_idtf2177_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_NAME_in_simpleIdtf2232_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_NAME_in_simpleIdtf2232( FOLLOW_NAME_in_simpleIdtf2232_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_URL_in_simpleIdtf2248_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_URL_in_simpleIdtf2248( FOLLOW_URL_in_simpleIdtf2248_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_idtfWithInt2300_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000802) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_idtfWithInt2300( FOLLOW_idtf_in_idtfWithInt2300_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_internal_in_idtfWithInt2324_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_internal_in_idtfWithInt2324( FOLLOW_internal_in_idtfWithInt2324_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start syntax
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:51:1: syntax : (a= sentence_sentsep )* EOF ;
 */
void
SCsParser::syntax()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    SentenceWithSeparator* a;
    typedef	SentenceWithSeparator* RETURN_TYPE_a;

    /* Initialize rule variables
     */



    		  mNeedRecover = false;
    		  SyntaxAST* syntax = new SyntaxAST();
    		

 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:60:7: ( (a= sentence_sentsep )* EOF )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:61:7: (a= sentence_sentsep )* EOF
        {
            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:61:7: (a= sentence_sentsep )*

            for (;;)
            {
                int alt1=2;
                switch ( this->LA(1) )
                {
                case ALIASNONAME:
                case CONTENT:
                case LPAR:
                case LPAR_OSET:
                case LPAR_SET:
                case NAME:
                case URL:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:61:9: a= sentence_sentsep
            	    {
            	        this->followPush(FOLLOW_sentence_sentsep_in_syntax103);
            	        a=sentence_sentsep();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesyntaxEx;
            	        }


            	        {
            	             IFNR syntax->addSentence(a
            	            ); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


             this->matchToken(EOF, &FOLLOW_EOF_in_syntax113);
            if  (this->hasException())
            {
                goto rulesyntaxEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesyntaxEx; /* Prevent compiler warnings */
    rulesyntaxEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return ;
}
/* $ANTLR end syntax */

/**
 * $ANTLR start sentence_sentsep
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:64:1: sentence_sentsep returns [SentenceWithSeparator* retPtr] :a= sentence b= SENTSEP ;
 */
SentenceWithSeparator*
SCsParser::sentence_sentsep()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SentenceWithSeparator* retPtr;


    const CommonTokenType*    b;
    SentenceAST* a;
    typedef	SentenceAST* RETURN_TYPE_a;

    /* Initialize rule variables
     */


    		    SNRT
    		    retPtr = new SentenceWithSeparator();
    		
    b       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:73:5: (a= sentence b= SENTSEP )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:74:5: a= sentence b= SENTSEP
        {
            {
                SNRT
            }


            this->followPush(FOLLOW_sentence_in_sentence_sentsep158);
            a=sentence();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_sentsepEx;
            }


            {
                 IFNRR retPtr->setSentence(a
                );                      
            }


            {
                SNRT
            }


            b =  this->matchToken(SENTSEP, &FOLLOW_SENTSEP_in_sentence_sentsep173);
            if  (this->hasException())
            {
                goto rulesentence_sentsepEx;
            }


            {
                 SNRF retPtr->setSeparator(QString::fromStdString((b->getText())));
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesentence_sentsepEx; /* Prevent compiler warnings */
    rulesentence_sentsepEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end sentence_sentsep */

/**
 * $ANTLR start sentence
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:78:1: sentence returns [SentenceAST* retPtr] : (a= sentence_lv1 |b= sentence_lv23456 );
 */
SentenceAST*
SCsParser::sentence()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SentenceAST* retPtr;


    SentenceLvl1AST* a;
    typedef	SentenceLvl1AST* RETURN_TYPE_a;

    SentenceLv234561AST* b;
    typedef	SentenceLv234561AST* RETURN_TYPE_b;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new SentenceAST();
    		

 
    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:87:9: (a= sentence_lv1 |b= sentence_lv23456 )

            ANTLR_UINT32 alt2;

            alt2=2;

            switch ( this->LA(1) )
            {
            case NAME:
            	{
            		switch ( this->LA(2) )
            		{
            		case TRIPLESEP:
            			{
            				alt2=1;
            			}
            		    break;
            		case CONNECTORS:
            			{
            				alt2=2;
            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 2 );
            		    ex->set_state( 1 );


            		    goto rulesentenceEx;

            		}

            	}
                break;
            case URL:
            	{
            		switch ( this->LA(2) )
            		{
            		case TRIPLESEP:
            			{
            				alt2=1;
            			}
            		    break;
            		case CONNECTORS:
            			{
            				alt2=2;
            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 2 );
            		    ex->set_state( 2 );


            		    goto rulesentenceEx;

            		}

            	}
                break;
            case ALIASNONAME:
            case CONTENT:
            case LPAR:
            case LPAR_OSET:
            case LPAR_SET:
            	{
            		alt2=2;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 2 );
                ex->set_state( 0 );


                goto rulesentenceEx;

            }

            switch (alt2)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:88:9: a= sentence_lv1
        	    {
        	        {
        	            SNRT
        	        }


        	        this->followPush(FOLLOW_sentence_lv1_in_sentence225);
        	        a=sentence_lv1();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesentenceEx;
        	        }


        	        {
        	            IFNRR retPtr->addSentenceLvl1(a
        	            );        
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:89:9: b= sentence_lv23456
        	    {
        	        {
        	            SNRT
        	        }


        	        this->followPush(FOLLOW_sentence_lv23456_in_sentence251);
        	        b=sentence_lv23456();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesentenceEx;
        	        }


        	        {
        	            IFNRR retPtr->addSentenceLv234561(b
        	            );    
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesentenceEx; /* Prevent compiler warnings */
    rulesentenceEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end sentence */

/**
 * $ANTLR start sentence_lv23456
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:93:1: sentence_lv23456 returns [SentenceLv234561AST* retPtr] :a= idtf b= CONNECTORS c= attrsList d= objectList ;
 */
SentenceLv234561AST*
SCsParser::sentence_lv23456()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SentenceLv234561AST* retPtr;


    const CommonTokenType*    b;
    IdentifierAST* a;
    typedef	IdentifierAST* RETURN_TYPE_a;

    AttributesListAST* c;
    typedef	AttributesListAST* RETURN_TYPE_c;

    ObjectListAST* d;
    typedef	ObjectListAST* RETURN_TYPE_d;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new SentenceLv234561AST();
    		
    b       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:102:5: (a= idtf b= CONNECTORS c= attrsList d= objectList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:103:5: a= idtf b= CONNECTORS c= attrsList d= objectList
        {
            {
                SNRT
            }


            this->followPush(FOLLOW_idtf_in_sentence_lv23456300);
            a=idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }


            {
                 IFNRR retPtr->setIdentifier(a
                );                       
            }


            {
                SNRT
            }


            b =  this->matchToken(CONNECTORS, &FOLLOW_CONNECTORS_in_sentence_lv23456326);
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }


            {
                 SNRF  retPtr->setConnector(QString::fromStdString((b->getText())));  
            }


            {
                SNRT
            }


            this->followPush(FOLLOW_attrsList_in_sentence_lv23456347);
            c=attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }


            {
                 IFNRR retPtr->setAttributeList(c
                );                    
            }


            {
                SNRT
            }


            this->followPush(FOLLOW_objectList_in_sentence_lv23456368);
            d=objectList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }


            {
                 IFNRR retPtr->setObjectList(d
                );                       
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesentence_lv23456Ex; /* Prevent compiler warnings */
    rulesentence_lv23456Ex: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end sentence_lv23456 */

/**
 * $ANTLR start sentence_lv1
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:111:1: sentence_lv1 returns [SentenceLvl1AST* retPtr] :a= simpleIdtf b= TRIPLESEP c= simpleIdtf d= TRIPLESEP e= simpleIdtf ;
 */
SentenceLvl1AST*
SCsParser::sentence_lv1()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SentenceLvl1AST* retPtr;


    const CommonTokenType*    b;
    const CommonTokenType*    d;
    SimpleIdentifierAST* a;
    typedef	SimpleIdentifierAST* RETURN_TYPE_a;

    SimpleIdentifierAST* c;
    typedef	SimpleIdentifierAST* RETURN_TYPE_c;

    SimpleIdentifierAST* e;
    typedef	SimpleIdentifierAST* RETURN_TYPE_e;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new SentenceLvl1AST();
    		
    b       = NULL;
    d       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:120:6: (a= simpleIdtf b= TRIPLESEP c= simpleIdtf d= TRIPLESEP e= simpleIdtf )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:121:6: a= simpleIdtf b= TRIPLESEP c= simpleIdtf d= TRIPLESEP e= simpleIdtf
        {
            {
                SNRT
            }


            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1422);
            a=simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


            {
                 IFNRR retPtr->setFirstIdentifier(a
                );                             
            }


            {
                SNRT
            }


            b =  this->matchToken(TRIPLESEP, &FOLLOW_TRIPLESEP_in_sentence_lv1442);
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


            {
                 SNRF retPtr->setFirstTripleSeparator(QString::fromStdString((b->getText())));   
            }


            {
                SNRT
            }


            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1464);
            c=simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


            {
                 IFNRR retPtr->setSecondIdentifier(c
                );                            
            }


            {
                SNRT
            }


            d =  this->matchToken(TRIPLESEP, &FOLLOW_TRIPLESEP_in_sentence_lv1484);
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


            {
                 SNRF retPtr->setSecondTripleSeparator(QString::fromStdString((d->getText())));  
            }


            {
                SNRT
            }


            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1505);
            e=simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


            {
                 IFNRR retPtr->setThirdIdentifier(e
                );                             
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesentence_lv1Ex; /* Prevent compiler warnings */
    rulesentence_lv1Ex: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end sentence_lv1 */

/**
 * $ANTLR start attrsList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:129:1: attrsList returns [AttributesListAST* retPtr] : (a= simpleIdtf_attrsep )* ;
 */
AttributesListAST*
SCsParser::attrsList()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    AttributesListAST* retPtr;


    SimpleIdtfrWAttrSepAST * a;
    typedef	SimpleIdtfrWAttrSepAST * RETURN_TYPE_a;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new AttributesListAST();
    		

 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:137:7: ( (a= simpleIdtf_attrsep )* )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:138:7: (a= simpleIdtf_attrsep )*
        {
            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:138:7: (a= simpleIdtf_attrsep )*

            for (;;)
            {
                int alt3=2;
                switch ( this->LA(1) )
                {
                case NAME:
                	{
                		switch ( this->LA(2) )
                		{
                		case ATTRSEP:
                			{
                				alt3=1;
                			}
                		    break;

                		}

                	}
                    break;
                case URL:
                	{
                		switch ( this->LA(2) )
                		{
                		case ATTRSEP:
                			{
                				alt3=1;
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt3)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:138:9: a= simpleIdtf_attrsep
            	    {
            	        {
            	            SNRT
            	        }


            	        this->followPush(FOLLOW_simpleIdtf_attrsep_in_attrsList556);
            	        a=simpleIdtf_attrsep();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleattrsListEx;
            	        }


            	        {
            	            IFNRR retPtr->addIdentifier(a
            	            ); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop3;	/* break out of the loop */
            	    break;
                }
            }
            loop3: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleattrsListEx; /* Prevent compiler warnings */
    ruleattrsListEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end attrsList */

/**
 * $ANTLR start simpleIdtf_attrsep
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:142:1: simpleIdtf_attrsep returns [SimpleIdtfrWAttrSepAST *retPtr] :a= simpleIdtf b= ATTRSEP ;
 */
SimpleIdtfrWAttrSepAST *
SCsParser::simpleIdtf_attrsep()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SimpleIdtfrWAttrSepAST * retPtr;


    const CommonTokenType*    b;
    SimpleIdentifierAST* a;
    typedef	SimpleIdentifierAST* RETURN_TYPE_a;

    /* Initialize rule variables
     */


    	    SNRT
    	    retPtr = new SimpleIdtfrWAttrSepAST();
    	  
    b       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:150:5: (a= simpleIdtf b= ATTRSEP )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:151:5: a= simpleIdtf b= ATTRSEP
        {
            {
                SNRT
            }


            this->followPush(FOLLOW_simpleIdtf_in_simpleIdtf_attrsep607);
            a=simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimpleIdtf_attrsepEx;
            }


            {
                 IFNRR retPtr->setIdentifier(a
                );                 
            }


            {
                SNRT
            }


            b =  this->matchToken(ATTRSEP, &FOLLOW_ATTRSEP_in_simpleIdtf_attrsep623);
            if  (this->hasException())
            {
                goto rulesimpleIdtf_attrsepEx;
            }


            {
                 SNRF  retPtr->setAttributeSeparator(QString::fromStdString((b->getText()))); 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesimpleIdtf_attrsepEx; /* Prevent compiler warnings */
    rulesimpleIdtf_attrsepEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end simpleIdtf_attrsep */

/**
 * $ANTLR start objectList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:156:1: objectList returns [ObjectListAST* retPtr] :a= idtfWithInt (b= objsep_IdtfWithInt )* ;
 */
ObjectListAST*
SCsParser::objectList()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    ObjectListAST* retPtr;


    IdentifierWithInternalAST* a;
    typedef	IdentifierWithInternalAST* RETURN_TYPE_a;

    ObjSepWIdtfWithInt* b;
    typedef	ObjSepWIdtfWithInt* RETURN_TYPE_b;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new ObjectListAST();
    		

 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:164:11: (a= idtfWithInt (b= objsep_IdtfWithInt )* )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:165:11: a= idtfWithInt (b= objsep_IdtfWithInt )*
        {
            {
                SNRT
            }


            this->followPush(FOLLOW_idtfWithInt_in_objectList685);
            a=idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleobjectListEx;
            }


            {
                 IFNRR retPtr->setIdentifierWithInt(a
                );  
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:166:9: (b= objsep_IdtfWithInt )*

            for (;;)
            {
                int alt4=2;
                switch ( this->LA(1) )
                {
                case OBJSEP:
                	{
                		alt4=1;
                	}
                    break;

                }

                switch (alt4)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:166:11: b= objsep_IdtfWithInt
            	    {
            	        {
            	            SNRT
            	        }


            	        this->followPush(FOLLOW_objsep_IdtfWithInt_in_objectList713);
            	        b=objsep_IdtfWithInt();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleobjectListEx;
            	        }


            	        {
            	             IFNRR retPtr->addIdentifier(b
            	            );         
            	        }


            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleobjectListEx; /* Prevent compiler warnings */
    ruleobjectListEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end objectList */

/**
 * $ANTLR start objsep_IdtfWithInt
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:171:1: objsep_IdtfWithInt returns [ObjSepWIdtfWithInt* retPtr] :a= OBJSEP b= idtfWithInt ;
 */
ObjSepWIdtfWithInt*
SCsParser::objsep_IdtfWithInt()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    ObjSepWIdtfWithInt* retPtr;


    const CommonTokenType*    a;
    IdentifierWithInternalAST* b;
    typedef	IdentifierWithInternalAST* RETURN_TYPE_b;

    /* Initialize rule variables
     */


    	    SNRT
    	    retPtr = new ObjSepWIdtfWithInt();
    	  
    a       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:179:5: (a= OBJSEP b= idtfWithInt )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:180:5: a= OBJSEP b= idtfWithInt
        {
            {
                SNRT
            }


            a =  this->matchToken(OBJSEP, &FOLLOW_OBJSEP_in_objsep_IdtfWithInt763);
            if  (this->hasException())
            {
                goto ruleobjsep_IdtfWithIntEx;
            }


            {
                 SNRF  retPtr->setObjectSeparator(QString::fromStdString((a->getText())));  
            }


            {
                SNRT
            }


            this->followPush(FOLLOW_idtfWithInt_in_objsep_IdtfWithInt785);
            b=idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleobjsep_IdtfWithIntEx;
            }


            {
                 IFNRR retPtr->setIdentifierWithInternal(b
                );                 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleobjsep_IdtfWithIntEx; /* Prevent compiler warnings */
    ruleobjsep_IdtfWithIntEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end objsep_IdtfWithInt */

/**
 * $ANTLR start intSentence
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:185:1: intSentence returns [InternalSentenceAST* retPtr] :a= CONNECTORS b= attrsList c= objectList ;
 */
InternalSentenceAST*
SCsParser::intSentence()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    InternalSentenceAST* retPtr;


    const CommonTokenType*    a;
    AttributesListAST* b;
    typedef	AttributesListAST* RETURN_TYPE_b;

    ObjectListAST* c;
    typedef	ObjectListAST* RETURN_TYPE_c;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new InternalSentenceAST();
    		
    a       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:193:9: (a= CONNECTORS b= attrsList c= objectList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:194:9: a= CONNECTORS b= attrsList c= objectList
        {
            {
                SNRT
            }


            a =  this->matchToken(CONNECTORS, &FOLLOW_CONNECTORS_in_intSentence839);
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }


            {
                 SNRF  retPtr->setConnector(QString::fromStdString((a->getText())));  
            }


            {
                SNRT
            }


            this->followPush(FOLLOW_attrsList_in_intSentence860);
            b=attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }


            {
                 IFNRR retPtr->setAttributeList(b
                );  
            }


            {
                SNRT
            }


            this->followPush(FOLLOW_objectList_in_intSentence882);
            c=objectList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }


            {
                 IFNRR retPtr->setObjectList(c
                );  
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintSentenceEx; /* Prevent compiler warnings */
    ruleintSentenceEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end intSentence */

/**
 * $ANTLR start intSentenceList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:200:1: intSentenceList returns [InternalSentenceListAST* retPtr] :a= LPAR_INT (b= intSentence_sentsep )+ c= RPAR_INT ;
 */
InternalSentenceListAST*
SCsParser::intSentenceList()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    InternalSentenceListAST* retPtr;


    const CommonTokenType*    a;
    const CommonTokenType*    c;
    IntSentenceWSentSep* b;
    typedef	IntSentenceWSentSep* RETURN_TYPE_b;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new InternalSentenceListAST();
    		
    a       = NULL;
    c       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:208:11: (a= LPAR_INT (b= intSentence_sentsep )+ c= RPAR_INT )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:209:11: a= LPAR_INT (b= intSentence_sentsep )+ c= RPAR_INT
        {
            {
                SNRT
            }


            a =  this->matchToken(LPAR_INT, &FOLLOW_LPAR_INT_in_intSentenceList937);
            if  (this->hasException())
            {
                goto ruleintSentenceListEx;
            }


            {
                 SNRF  retPtr->setLeftInternalSeparator(QString::fromStdString((a->getText())));  
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:210:9: (b= intSentence_sentsep )+
            {
                int cnt5=0;

                for (;;)
                {
                    int alt5=2;
            	switch ( this->LA(1) )
            	{
            	case CONNECTORS:
            		{
            			alt5=1;
            		}
            	    break;

            	}

            	switch (alt5)
            	{
            	    case 1:
            	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:210:11: b= intSentence_sentsep
            	        {
            	            {
            	                SNRT
            	            }


            	            this->followPush(FOLLOW_intSentence_sentsep_in_intSentenceList972);
            	            b=intSentence_sentsep();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleintSentenceListEx;
            	            }


            	            {
            	                 IFNRR retPtr->addSentence(b
            	                );                                     
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt5 >= 1 )
            		{
            		    goto loop5;
            		}
            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< SCsParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleintSentenceListEx;
            	}
            	cnt5++;
                }
                loop5: ;	/* Jump to here if this rule does not match */
            }

            {
                SNRT
            }


            c =  this->matchToken(RPAR_INT, &FOLLOW_RPAR_INT_in_intSentenceList1002);
            if  (this->hasException())
            {
                goto ruleintSentenceListEx;
            }


            {
                 SNRF  retPtr->setRigthInternalSeparator(QString::fromStdString((c->getText()))); 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintSentenceListEx; /* Prevent compiler warnings */
    ruleintSentenceListEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end intSentenceList */

/**
 * $ANTLR start intSentence_sentsep
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:214:1: intSentence_sentsep returns [IntSentenceWSentSep* retPtr] :a= intSentence b= SENTSEP ;
 */
IntSentenceWSentSep*
SCsParser::intSentence_sentsep()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    IntSentenceWSentSep* retPtr;


    const CommonTokenType*    b;
    InternalSentenceAST* a;
    typedef	InternalSentenceAST* RETURN_TYPE_a;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new IntSentenceWSentSep();
    		
    b       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:222:5: (a= intSentence b= SENTSEP )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:223:5: a= intSentence b= SENTSEP
        {
            {
                SNRT
            }


            this->followPush(FOLLOW_intSentence_in_intSentence_sentsep1062);
            a=intSentence();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleintSentence_sentsepEx;
            }


            {
                 IFNRR   retPtr->setInternalSentence(a
                );                         
            }


            {
                SNRT
            }


            b =  this->matchToken(SENTSEP, &FOLLOW_SENTSEP_in_intSentence_sentsep1086);
            if  (this->hasException())
            {
                goto ruleintSentence_sentsepEx;
            }


            {
                 SNRF    retPtr->setSentenceSeparator(QString::fromStdString((b->getText())));  
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintSentence_sentsepEx; /* Prevent compiler warnings */
    ruleintSentence_sentsepEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end intSentence_sentsep */

/**
 * $ANTLR start internal
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:227:1: internal returns [InternalAST* retPtr] :a= intSentenceList ;
 */
InternalAST*
SCsParser::internal()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    InternalAST* retPtr;


    InternalSentenceListAST* a;
    typedef	InternalSentenceListAST* RETURN_TYPE_a;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new InternalAST();
    		

 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:235:4: (a= intSentenceList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:236:4: a= intSentenceList
        {
            {
                SNRT
            }


            this->followPush(FOLLOW_intSentenceList_in_internal1142);
            a=intSentenceList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleinternalEx;
            }


            {
                 IFNRR   retPtr->setInternalSentenceList(a
                );   
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinternalEx; /* Prevent compiler warnings */
    ruleinternalEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end internal */

/**
 * $ANTLR start triple
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:239:1: triple returns [TripleAST* retPtr] :a= LPAR b= idtf c= CONTENT d= idtf e= RPAR ;
 */
TripleAST*
SCsParser::triple()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    TripleAST* retPtr;


    const CommonTokenType*    a;
    const CommonTokenType*    c;
    const CommonTokenType*    e;
    IdentifierAST* b;
    typedef	IdentifierAST* RETURN_TYPE_b;

    IdentifierAST* d;
    typedef	IdentifierAST* RETURN_TYPE_d;

    /* Initialize rule variables
     */


          SNRT
          retPtr = new TripleAST();
        
    a       = NULL;
    c       = NULL;
    e       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:247:7: (a= LPAR b= idtf c= CONTENT d= idtf e= RPAR )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:248:7: a= LPAR b= idtf c= CONTENT d= idtf e= RPAR
        {
            {
                SNRT
            }


            a =  this->matchToken(LPAR, &FOLLOW_LPAR_in_triple1201);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


            {
                 SNRF    retPtr->setLeftPar(QString::fromStdString((a->getText())));   
            }


            {
                SNRT
            }


            this->followPush(FOLLOW_idtf_in_triple1224);
            b=idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


            {
                 IFNRR   retPtr->setFirstIdentifier(b
                );                 
            }


            {
                SNRT
            }


            c =  this->matchToken(CONTENT, &FOLLOW_CONTENT_in_triple1246);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


            {
                 SNRF    retPtr->setContent(QString::fromStdString((c->getText())));   
            }


            {
                SNRT
            }


            this->followPush(FOLLOW_idtf_in_triple1266);
            d=idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


            {
                 IFNRR   retPtr->setSecondIdentifier(d
                );                
            }


            {
                SNRT
            }


            e =  this->matchToken(RPAR, &FOLLOW_RPAR_in_triple1288);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


            {
                 SNRF    retPtr->setRighPar(QString::fromStdString((e->getText())));   
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletripleEx; /* Prevent compiler warnings */
    ruletripleEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end triple */

/**
 * $ANTLR start alias
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:255:1: alias returns [AliasAST* retPtr] :a= ALIASNONAME ;
 */
AliasAST*
SCsParser::alias()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    AliasAST* retPtr;


    const CommonTokenType*    a;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new AliasAST();
    		
    a       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:264:7: (a= ALIASNONAME )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:265:7: a= ALIASNONAME
        {
            {
                SNRT
            }


            a =  this->matchToken(ALIASNONAME, &FOLLOW_ALIASNONAME_in_alias1344);
            if  (this->hasException())
            {
                goto rulealiasEx;
            }


            {
                 SNRF     retPtr->setAlias(QString::fromStdString((a->getText()))); 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealiasEx; /* Prevent compiler warnings */
    rulealiasEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end alias */

/**
 * $ANTLR start setIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:269:1: setIdtf returns [SetIdentifierAST* retPtr] :a= LPAR_SET b= attrsList c= idtfWithInt (d= objsep_AttrsList_idtfWithInt )* e= RPAR_SET ;
 */
SetIdentifierAST*
SCsParser::setIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SetIdentifierAST* retPtr;


    const CommonTokenType*    a;
    const CommonTokenType*    e;
    AttributesListAST* b;
    typedef	AttributesListAST* RETURN_TYPE_b;

    IdentifierWithInternalAST* c;
    typedef	IdentifierWithInternalAST* RETURN_TYPE_c;

    ObjSepWAttrListWIdtfWithInt* d;
    typedef	ObjSepWAttrListWIdtfWithInt* RETURN_TYPE_d;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new SetIdentifierAST();
    		
    a       = NULL;
    e       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:277:9: (a= LPAR_SET b= attrsList c= idtfWithInt (d= objsep_AttrsList_idtfWithInt )* e= RPAR_SET )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:278:9: a= LPAR_SET b= attrsList c= idtfWithInt (d= objsep_AttrsList_idtfWithInt )* e= RPAR_SET
        {
            {
                SNRT
            }


            a =  this->matchToken(LPAR_SET, &FOLLOW_LPAR_SET_in_setIdtf1406);
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }


            {
                 SNRF     retPtr->setLeftSeparator(QString::fromStdString((a->getText())));    
            }


            {
                SNRT
            }


            this->followPush(FOLLOW_attrsList_in_setIdtf1453);
            b=attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }


            {
                 IFNRR    retPtr->setAttributeList(b
                );                          
            }


            {
                SNRT
            }


            this->followPush(FOLLOW_idtfWithInt_in_setIdtf1499);
            c=idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }


            {
                 IFNRR    retPtr->setIdentifier(c
                );                             
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:281:7: (d= objsep_AttrsList_idtfWithInt )*

            for (;;)
            {
                int alt6=2;
                switch ( this->LA(1) )
                {
                case OBJSEP:
                	{
                		alt6=1;
                	}
                    break;

                }

                switch (alt6)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:281:9: d= objsep_AttrsList_idtfWithInt
            	    {
            	        {
            	            SNRT
            	        }


            	        this->followPush(FOLLOW_objsep_AttrsList_idtfWithInt_in_setIdtf1544);
            	        d=objsep_AttrsList_idtfWithInt();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesetIdtfEx;
            	        }


            	        {
            	             IFNRR    retPtr->addSentence(d
            	            );                               
            	        }


            	    }
            	    break;

            	default:
            	    goto loop6;	/* break out of the loop */
            	    break;
                }
            }
            loop6: ; /* Jump out to here if this rule does not match */


            {
                SNRT
            }


            e =  this->matchToken(RPAR_SET, &FOLLOW_RPAR_SET_in_setIdtf1575);
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }


            {
                 SNRF     retPtr->setRightSeparator(QString::fromStdString((e->getText())));   
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesetIdtfEx; /* Prevent compiler warnings */
    rulesetIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end setIdtf */

/**
 * $ANTLR start objsep_AttrsList_idtfWithInt
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:285:1: objsep_AttrsList_idtfWithInt returns [ObjSepWAttrListWIdtfWithInt* retPtr] :a= OBJSEP b= attrsList c= idtfWithInt ;
 */
ObjSepWAttrListWIdtfWithInt*
SCsParser::objsep_AttrsList_idtfWithInt()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    ObjSepWAttrListWIdtfWithInt* retPtr;


    const CommonTokenType*    a;
    AttributesListAST* b;
    typedef	AttributesListAST* RETURN_TYPE_b;

    IdentifierWithInternalAST* c;
    typedef	IdentifierWithInternalAST* RETURN_TYPE_c;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new ObjSepWAttrListWIdtfWithInt();
    		
    a       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:293:4: (a= OBJSEP b= attrsList c= idtfWithInt )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:294:4: a= OBJSEP b= attrsList c= idtfWithInt
        {
            {
                SNRT
            }


            a =  this->matchToken(OBJSEP, &FOLLOW_OBJSEP_in_objsep_AttrsList_idtfWithInt1644);
            if  (this->hasException())
            {
                goto ruleobjsep_AttrsList_idtfWithIntEx;
            }


            {
                 SNRF     retPtr->setSeparator(QString::fromStdString((a->getText())));    
            }


            {
                SNRT
            }


            this->followPush(FOLLOW_attrsList_in_objsep_AttrsList_idtfWithInt1667);
            b=attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleobjsep_AttrsList_idtfWithIntEx;
            }


            {
                 IFNRR    retPtr->setAttributeList(b
                );                      
            }


            {
                SNRT
            }


            this->followPush(FOLLOW_idtfWithInt_in_objsep_AttrsList_idtfWithInt1686);
            c=idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleobjsep_AttrsList_idtfWithIntEx;
            }


            {
                 IFNRR    retPtr->setIdentifier(c
                );                         
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleobjsep_AttrsList_idtfWithIntEx; /* Prevent compiler warnings */
    ruleobjsep_AttrsList_idtfWithIntEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end objsep_AttrsList_idtfWithInt */

/**
 * $ANTLR start osetIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:300:1: osetIdtf returns [OSetIdentifierAST* retPtr] :a= LPAR_OSET b= attrsList c= idtfWithInt (d= objsep_AttrsList_idtfWithInt )* e= RPAR_OSET ;
 */
OSetIdentifierAST*
SCsParser::osetIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    OSetIdentifierAST* retPtr;


    const CommonTokenType*    a;
    const CommonTokenType*    e;
    AttributesListAST* b;
    typedef	AttributesListAST* RETURN_TYPE_b;

    IdentifierWithInternalAST* c;
    typedef	IdentifierWithInternalAST* RETURN_TYPE_c;

    ObjSepWAttrListWIdtfWithInt* d;
    typedef	ObjSepWAttrListWIdtfWithInt* RETURN_TYPE_d;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new OSetIdentifierAST();
    		
    a       = NULL;
    e       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:308:9: (a= LPAR_OSET b= attrsList c= idtfWithInt (d= objsep_AttrsList_idtfWithInt )* e= RPAR_OSET )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:309:9: a= LPAR_OSET b= attrsList c= idtfWithInt (d= objsep_AttrsList_idtfWithInt )* e= RPAR_OSET
        {
            {
                SNRT
            }


            a =  this->matchToken(LPAR_OSET, &FOLLOW_LPAR_OSET_in_osetIdtf1744);
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }


            {
                  retPtr->setLeftSeparator(QString::fromStdString((a->getText())));   
            }


            {
                SNRT
            }


            this->followPush(FOLLOW_attrsList_in_osetIdtf1793);
            b=attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }


            {
                 IFNRR   retPtr->setAttributeList(b
                );                         
            }


            {
                SNRT
            }


            this->followPush(FOLLOW_idtfWithInt_in_osetIdtf1842);
            c=idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }


            {
                 IFNRR   retPtr->setIdentifier(c
                );                            
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:312:7: (d= objsep_AttrsList_idtfWithInt )*

            for (;;)
            {
                int alt7=2;
                switch ( this->LA(1) )
                {
                case OBJSEP:
                	{
                		alt7=1;
                	}
                    break;

                }

                switch (alt7)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:312:9: d= objsep_AttrsList_idtfWithInt
            	    {
            	        {
            	            SNRT
            	        }


            	        this->followPush(FOLLOW_objsep_AttrsList_idtfWithInt_in_osetIdtf1891);
            	        d=objsep_AttrsList_idtfWithInt();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleosetIdtfEx;
            	        }


            	        {
            	             IFNRR   retPtr->addSentence(d
            	            );                              
            	        }


            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


            {
                SNRT
            }


            e =  this->matchToken(RPAR_OSET, &FOLLOW_RPAR_OSET_in_osetIdtf1926);
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }


            {
                 SNRF    retPtr->setRightSeparator(QString::fromStdString((e->getText())));  
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleosetIdtfEx; /* Prevent compiler warnings */
    ruleosetIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end osetIdtf */

/**
 * $ANTLR start anyIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:316:1: anyIdtf returns [AnyIdentifierAST* retPtr] : (a= simpleIdtf |b= CONTENT |c= triple |d= setIdtf |e= osetIdtf |f= alias );
 */
AnyIdentifierAST*
SCsParser::anyIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    AnyIdentifierAST* retPtr;


    const CommonTokenType*    b;
    SimpleIdentifierAST* a;
    typedef	SimpleIdentifierAST* RETURN_TYPE_a;

    TripleAST* c;
    typedef	TripleAST* RETURN_TYPE_c;

    SetIdentifierAST* d;
    typedef	SetIdentifierAST* RETURN_TYPE_d;

    OSetIdentifierAST* e;
    typedef	OSetIdentifierAST* RETURN_TYPE_e;

    AliasAST* f;
    typedef	AliasAST* RETURN_TYPE_f;

    /* Initialize rule variables
     */


    		  SNRT
    		  retPtr = new AnyIdentifierAST();
    		
    b       = NULL;


 
    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:323:5: (a= simpleIdtf |b= CONTENT |c= triple |d= setIdtf |e= osetIdtf |f= alias )

            ANTLR_UINT32 alt8;

            alt8=6;

            switch ( this->LA(1) )
            {
            case NAME:
            case URL:
            	{
            		alt8=1;
            	}
                break;
            case CONTENT:
            	{
            		alt8=2;
            	}
                break;
            case LPAR:
            	{
            		alt8=3;
            	}
                break;
            case LPAR_SET:
            	{
            		alt8=4;
            	}
                break;
            case LPAR_OSET:
            	{
            		alt8=5;
            	}
                break;
            case ALIASNONAME:
            	{
            		alt8=6;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 8 );
                ex->set_state( 0 );


                goto ruleanyIdtfEx;

            }

            switch (alt8)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:324:9: a= simpleIdtf
        	    {
        	        {
        	            SNRT
        	        }


        	        this->followPush(FOLLOW_simpleIdtf_in_anyIdtf2003);
        	        a=simpleIdtf();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }


        	        {
        	             IFNRR retPtr->setSimpleIdentifier( a
        	             );             
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:325:9: b= CONTENT
        	    {
        	        {
        	            SNRT
        	        }


        	        b =  this->matchToken(CONTENT, &FOLLOW_CONTENT_in_anyIdtf2022);
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }


        	        {
        	             SNRF  retPtr->setContent(QString::fromStdString((b->getText())));  
        	        }


        	    }
        	    break;
        	case 3:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:326:9: c= triple
        	    {
        	        {
        	            SNRT
        	        }


        	        this->followPush(FOLLOW_triple_in_anyIdtf2044);
        	        c=triple();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }


        	        {
        	             IFNRR retPtr->setTriple(c
        	            );                         
        	        }


        	    }
        	    break;
        	case 4:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:327:9: d= setIdtf
        	    {
        	        {
        	            SNRT
        	        }


        	        this->followPush(FOLLOW_setIdtf_in_anyIdtf2067);
        	        d=setIdtf();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }


        	        {
        	             IFNRR retPtr->setSetIdentifier(d
        	            );                  
        	        }


        	    }
        	    break;
        	case 5:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:328:9: e= osetIdtf
        	    {
        	        {
        	            SNRT
        	        }


        	        this->followPush(FOLLOW_osetIdtf_in_anyIdtf2089);
        	        e=osetIdtf();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }


        	        {
        	             IFNRR retPtr->setOSetIdentifier(e
        	            );                 
        	        }


        	    }
        	    break;
        	case 6:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:329:9: f= alias
        	    {
        	        {
        	            SNRT
        	        }


        	        this->followPush(FOLLOW_alias_in_anyIdtf2110);
        	        f=alias();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }


        	        {
        	             IFNRR retPtr->setAlias(f
        	            );                          
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleanyIdtfEx; /* Prevent compiler warnings */
    ruleanyIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end anyIdtf */

/**
 * $ANTLR start idtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:334:1: idtf returns [IdentifierAST* retPtr] :a= anyIdtf ;
 */
IdentifierAST*
SCsParser::idtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    IdentifierAST* retPtr;


    AnyIdentifierAST* a;
    typedef	AnyIdentifierAST* RETURN_TYPE_a;

    /* Initialize rule variables
     */


    			  SNRT
    			  retPtr = new IdentifierAST();
    			

 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:341:5: (a= anyIdtf )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:342:5: a= anyIdtf
        {
            {
                SNRT
            }


            this->followPush(FOLLOW_anyIdtf_in_idtf2177);
            a=anyIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleidtfEx;
            }


            {
                 IFNRR  retPtr->setIdentifier(a
                ); 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleidtfEx; /* Prevent compiler warnings */
    ruleidtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end idtf */

/**
 * $ANTLR start simpleIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:345:1: simpleIdtf returns [SimpleIdentifierAST* retPtr] : (a= NAME |b= URL );
 */
SimpleIdentifierAST*
SCsParser::simpleIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SimpleIdentifierAST* retPtr;


    const CommonTokenType*    a;
    const CommonTokenType*    b;

    /* Initialize rule variables
     */


    			  SNRT
    			  retPtr = new SimpleIdentifierAST();
    			
    a       = NULL;
    b       = NULL;


 
    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:354:6: (a= NAME |b= URL )

            ANTLR_UINT32 alt9;

            alt9=2;

            switch ( this->LA(1) )
            {
            case NAME:
            	{
            		alt9=1;
            	}
                break;
            case URL:
            	{
            		alt9=2;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 9 );
                ex->set_state( 0 );


                goto rulesimpleIdtfEx;

            }

            switch (alt9)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:355:6: a= NAME
        	    {
        	        {
        	            SNRT
        	        }


        	        a =  this->matchToken(NAME, &FOLLOW_NAME_in_simpleIdtf2232);
        	        if  (this->hasException())
        	        {
        	            goto rulesimpleIdtfEx;
        	        }


        	        {
        	              SNRF retPtr->setName(QString::fromStdString((a->getText())));  
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:356:6: b= URL
        	    {
        	        {
        	            SNRT
        	        }


        	        b =  this->matchToken(URL, &FOLLOW_URL_in_simpleIdtf2248);
        	        if  (this->hasException())
        	        {
        	            goto rulesimpleIdtfEx;
        	        }


        	        {
        	              SNRF retPtr->setUrl(QString::fromStdString((b->getText())));  
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesimpleIdtfEx; /* Prevent compiler warnings */
    rulesimpleIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end simpleIdtf */

/**
 * $ANTLR start idtfWithInt
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:361:1: idtfWithInt returns [IdentifierWithInternalAST* retPtr] :a= idtf (b= internal )? ;
 */
IdentifierWithInternalAST*
SCsParser::idtfWithInt()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    IdentifierWithInternalAST* retPtr;


    IdentifierAST* a;
    typedef	IdentifierAST* RETURN_TYPE_a;

    InternalAST* b;
    typedef	InternalAST* RETURN_TYPE_b;

    /* Initialize rule variables
     */


    	  SNRT
    	  retPtr = new IdentifierWithInternalAST();
    	

 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:369:7: (a= idtf (b= internal )? )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:370:7: a= idtf (b= internal )?
        {
            {
                SNRT
            }


            this->followPush(FOLLOW_idtf_in_idtfWithInt2300);
            a=idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleidtfWithIntEx;
            }


            {
                 IFNRR   retPtr->setIdentifier(a
                );  
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:371:5: (b= internal )?
            {
                int alt10=2;
                switch ( this->LA(1) )
                {
                    case LPAR_INT:
                    	{
                    		alt10=1;
                    	}
                        break;
                }

                switch (alt10)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:371:7: b= internal
            	    {
            	        {
            	            SNRT
            	        }


            	        this->followPush(FOLLOW_internal_in_idtfWithInt2324);
            	        b=internal();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleidtfWithIntEx;
            	        }


            	        {
            	             IFNRR   retPtr->setInternal(b
            	            );  
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleidtfWithIntEx; /* Prevent compiler warnings */
    ruleidtfWithIntEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 SNRF 
            }
        }

    return retPtr;
}
/* $ANTLR end idtfWithInt */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

	}


/* End of code
 * =============================================================================
 */
