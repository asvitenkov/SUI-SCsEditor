/** \file
 *  This C++ source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g
 *     -                            On : 2013-03-30 21:45:38
 *     -                for the parser : SCsParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SCsParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

	namespace  SCsParserNS  {

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   SCsParserTokenNames[23+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "ALIASNONAME",
        (ANTLR_UINT8*) "ATTRSEP",
        (ANTLR_UINT8*) "COMMENT",
        (ANTLR_UINT8*) "CONNECTORS",
        (ANTLR_UINT8*) "CONTENT",
        (ANTLR_UINT8*) "ELEMTYPE",
        (ANTLR_UINT8*) "LPAR",
        (ANTLR_UINT8*) "LPAR_INT",
        (ANTLR_UINT8*) "LPAR_OSET",
        (ANTLR_UINT8*) "LPAR_SET",
        (ANTLR_UINT8*) "LPAR_TRF",
        (ANTLR_UINT8*) "NAME",
        (ANTLR_UINT8*) "OBJSEP",
        (ANTLR_UINT8*) "RPAR",
        (ANTLR_UINT8*) "RPAR_INT",
        (ANTLR_UINT8*) "RPAR_OSET",
        (ANTLR_UINT8*) "RPAR_SET",
        (ANTLR_UINT8*) "RPAR_TRF",
        (ANTLR_UINT8*) "SENTSEP",
        (ANTLR_UINT8*) "SYNSEP",
        (ANTLR_UINT8*) "TRIPLESEP",
        (ANTLR_UINT8*) "URL",
        (ANTLR_UINT8*) "WS"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* SCsParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new SCsParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SCsParser::SCsParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new SCsParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SCsParser::SCsParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void SCsParser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( SCsParserTokenNames );


}

void
SCsParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
SCsParser::~SCsParser()
 {
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return SCsParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_in_syntax100_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_in_syntax100( FOLLOW_sentence_in_syntax100_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_SENTSEP_in_syntax102_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B512) };
static  SCsParserImplTraits::BitsetListType FOLLOW_SENTSEP_in_syntax102( FOLLOW_SENTSEP_in_syntax102_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_lv1_in_sentence135_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_lv1_in_sentence135( FOLLOW_sentence_lv1_in_sentence135_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_lv23456_in_sentence139_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_lv23456_in_sentence139( FOLLOW_sentence_lv23456_in_sentence139_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_sentence_lv23456165_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_sentence_lv23456165( FOLLOW_idtf_in_sentence_lv23456165_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONNECTORS_in_sentence_lv23456167_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONNECTORS_in_sentence_lv23456167( FOLLOW_CONNECTORS_in_sentence_lv23456167_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_sentence_lv23456171_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_sentence_lv23456171( FOLLOW_attrsList_in_sentence_lv23456171_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objectList_in_sentence_lv23456173_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objectList_in_sentence_lv23456173( FOLLOW_objectList_in_sentence_lv23456173_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1200_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1200( FOLLOW_simpleIdtf_in_sentence_lv1200_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_TRIPLESEP_in_sentence_lv1202_bits[]	= { ANTLR_UINT64_LIT(0x0000000002008000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_TRIPLESEP_in_sentence_lv1202( FOLLOW_TRIPLESEP_in_sentence_lv1202_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1204_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1204( FOLLOW_simpleIdtf_in_sentence_lv1204_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_TRIPLESEP_in_sentence_lv1206_bits[]	= { ANTLR_UINT64_LIT(0x0000000002008000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_TRIPLESEP_in_sentence_lv1206( FOLLOW_TRIPLESEP_in_sentence_lv1206_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1208_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1208( FOLLOW_simpleIdtf_in_sentence_lv1208_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_attrsList237_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000020) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_attrsList237( FOLLOW_simpleIdtf_in_attrsList237_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_ATTRSEP_in_attrsList239_bits[]	= { ANTLR_UINT64_LIT(0x0000000002008002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_ATTRSEP_in_attrsList239( FOLLOW_ATTRSEP_in_attrsList239_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_objectList270_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_objectList270( FOLLOW_idtfWithInt_in_objectList270_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_OBJSEP_in_objectList273_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_OBJSEP_in_objectList273( FOLLOW_OBJSEP_in_objectList273_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_objectList275_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_objectList275( FOLLOW_idtfWithInt_in_objectList275_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONNECTORS_in_intSentence306_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONNECTORS_in_intSentence306( FOLLOW_CONNECTORS_in_intSentence306_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_intSentence308_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_intSentence308( FOLLOW_attrsList_in_intSentence308_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objectList_in_intSentence311_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objectList_in_intSentence311( FOLLOW_objectList_in_intSentence311_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_INT_in_intSentenceList341_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_INT_in_intSentenceList341( FOLLOW_LPAR_INT_in_intSentenceList341_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_intSentence_in_intSentenceList345_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_intSentence_in_intSentenceList345( FOLLOW_intSentence_in_intSentenceList345_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_SENTSEP_in_intSentenceList347_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040080) };
static  SCsParserImplTraits::BitsetListType FOLLOW_SENTSEP_in_intSentenceList347( FOLLOW_SENTSEP_in_intSentenceList347_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_INT_in_intSentenceList352_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_INT_in_intSentenceList352( FOLLOW_RPAR_INT_in_intSentenceList352_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_intSentenceList_in_internal378_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_intSentenceList_in_internal378( FOLLOW_intSentenceList_in_internal378_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_in_triple407_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_in_triple407( FOLLOW_LPAR_in_triple407_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_triple409_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000100) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_triple409( FOLLOW_idtf_in_triple409_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONTENT_in_triple411_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONTENT_in_triple411( FOLLOW_CONTENT_in_triple411_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_triple413_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_triple413( FOLLOW_idtf_in_triple413_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_in_triple415_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_in_triple415( FOLLOW_RPAR_in_triple415_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_ALIASNONAME_in_alias440_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_ALIASNONAME_in_alias440( FOLLOW_ALIASNONAME_in_alias440_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_SET_in_setIdtf470_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_SET_in_setIdtf470( FOLLOW_LPAR_SET_in_setIdtf470_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_setIdtf472_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_setIdtf472( FOLLOW_attrsList_in_setIdtf472_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_setIdtf474_bits[]	= { ANTLR_UINT64_LIT(0x0000000000110000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_setIdtf474( FOLLOW_idtfWithInt_in_setIdtf474_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_OBJSEP_in_setIdtf477_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_OBJSEP_in_setIdtf477( FOLLOW_OBJSEP_in_setIdtf477_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_setIdtf479_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_setIdtf479( FOLLOW_attrsList_in_setIdtf479_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_setIdtf481_bits[]	= { ANTLR_UINT64_LIT(0x0000000000110000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_setIdtf481( FOLLOW_idtfWithInt_in_setIdtf481_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_SET_in_setIdtf487_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_SET_in_setIdtf487( FOLLOW_RPAR_SET_in_setIdtf487_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_OSET_in_osetIdtf518_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_OSET_in_osetIdtf518( FOLLOW_LPAR_OSET_in_osetIdtf518_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_osetIdtf520_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_osetIdtf520( FOLLOW_attrsList_in_osetIdtf520_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_osetIdtf522_bits[]	= { ANTLR_UINT64_LIT(0x0000000000090000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_osetIdtf522( FOLLOW_idtfWithInt_in_osetIdtf522_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_OBJSEP_in_osetIdtf526_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_OBJSEP_in_osetIdtf526( FOLLOW_OBJSEP_in_osetIdtf526_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_osetIdtf528_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_osetIdtf528( FOLLOW_attrsList_in_osetIdtf528_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_osetIdtf530_bits[]	= { ANTLR_UINT64_LIT(0x0000000000090000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_osetIdtf530( FOLLOW_idtfWithInt_in_osetIdtf530_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_OSET_in_osetIdtf535_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_OSET_in_osetIdtf535( FOLLOW_RPAR_OSET_in_osetIdtf535_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_anyIdtf570_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_anyIdtf570( FOLLOW_simpleIdtf_in_anyIdtf570_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONTENT_in_anyIdtf580_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONTENT_in_anyIdtf580( FOLLOW_CONTENT_in_anyIdtf580_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_triple_in_anyIdtf590_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_triple_in_anyIdtf590( FOLLOW_triple_in_anyIdtf590_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_setIdtf_in_anyIdtf600_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_setIdtf_in_anyIdtf600( FOLLOW_setIdtf_in_anyIdtf600_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_osetIdtf_in_anyIdtf610_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_osetIdtf_in_anyIdtf610( FOLLOW_osetIdtf_in_anyIdtf610_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_alias_in_anyIdtf620_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_alias_in_anyIdtf620( FOLLOW_alias_in_anyIdtf620_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_anyIdtf_in_idtf654_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_anyIdtf_in_idtf654( FOLLOW_anyIdtf_in_idtf654_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_NAME_in_simpleIdtf683_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_NAME_in_simpleIdtf683( FOLLOW_NAME_in_simpleIdtf683_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_URL_in_simpleIdtf693_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_URL_in_simpleIdtf693( FOLLOW_URL_in_simpleIdtf693_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_idtfWithInt723_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000802) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_idtfWithInt723( FOLLOW_idtf_in_idtfWithInt723_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_internal_in_idtfWithInt725_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_internal_in_idtfWithInt725( FOLLOW_internal_in_idtfWithInt725_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start syntax
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:45:1: syntax : ( sentence SENTSEP )* ;
 */
void
SCsParser::syntax()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:46:5: ( ( sentence SENTSEP )* )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:46:7: ( sentence SENTSEP )*
        {
            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:46:7: ( sentence SENTSEP )*

            for (;;)
            {
                int alt1=2;
                switch ( this->LA(1) )
                {
                case ALIASNONAME:
                case CONTENT:
                case LPAR:
                case LPAR_OSET:
                case LPAR_SET:
                case NAME:
                case URL:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:46:9: sentence SENTSEP
            	    {
            	        this->followPush(FOLLOW_sentence_in_syntax100);
            	        sentence();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesyntaxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(SENTSEP, &FOLLOW_SENTSEP_in_syntax102);
            	        if  (this->hasException())
            	        {
            	            goto rulesyntaxEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesyntaxEx; /* Prevent compiler warnings */
    rulesyntaxEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end syntax */

/**
 * $ANTLR start sentence
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:50:1: sentence returns [SentenceAST *retPtr] : ( sentence_lv1 | sentence_lv23456 );
 */
SentenceAST *
SCsParser::sentence()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SentenceAST * retPtr;


    /* Initialize rule variables
     */


      retPtr = NULL;


 
    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:54:5: ( sentence_lv1 | sentence_lv23456 )

            ANTLR_UINT32 alt2;

            alt2=2;

            switch ( this->LA(1) )
            {
            case NAME:
            	{
            		switch ( this->LA(2) )
            		{
            		case TRIPLESEP:
            			{
            				alt2=1;
            			}
            		    break;
            		case CONNECTORS:
            			{
            				alt2=2;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return retPtr;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 2 );
            		    ex->set_state( 1 );


            		    goto rulesentenceEx;

            		}

            	}
                break;
            case URL:
            	{
            		switch ( this->LA(2) )
            		{
            		case TRIPLESEP:
            			{
            				alt2=1;
            			}
            		    break;
            		case CONNECTORS:
            			{
            				alt2=2;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return retPtr;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 2 );
            		    ex->set_state( 2 );


            		    goto rulesentenceEx;

            		}

            	}
                break;
            case ALIASNONAME:
            case CONTENT:
            case LPAR:
            case LPAR_OSET:
            case LPAR_SET:
            	{
            		alt2=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retPtr;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 2 );
                ex->set_state( 0 );


                goto rulesentenceEx;

            }

            switch (alt2)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:54:7: sentence_lv1
        	    {
        	        this->followPush(FOLLOW_sentence_lv1_in_sentence135);
        	        sentence_lv1();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesentenceEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:54:22: sentence_lv23456
        	    {
        	        this->followPush(FOLLOW_sentence_lv23456_in_sentence139);
        	        sentence_lv23456();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesentenceEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesentenceEx; /* Prevent compiler warnings */
    rulesentenceEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retPtr;
}
/* $ANTLR end sentence */

/**
 * $ANTLR start sentence_lv23456
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:58:1: sentence_lv23456 returns [SentenceLv234561AST *retPtr] : idtf CONNECTORS attrsList objectList ;
 */
SentenceLv234561AST *
SCsParser::sentence_lv23456()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SentenceLv234561AST * retPtr;


    /* Initialize rule variables
     */


      retPtr = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:62:5: ( idtf CONNECTORS attrsList objectList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:62:7: idtf CONNECTORS attrsList objectList
        {
            this->followPush(FOLLOW_idtf_in_sentence_lv23456165);
            idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


             this->matchToken(CONNECTORS, &FOLLOW_CONNECTORS_in_sentence_lv23456167);
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            this->followPush(FOLLOW_attrsList_in_sentence_lv23456171);
            attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            this->followPush(FOLLOW_objectList_in_sentence_lv23456173);
            objectList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesentence_lv23456Ex; /* Prevent compiler warnings */
    rulesentence_lv23456Ex: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retPtr;
}
/* $ANTLR end sentence_lv23456 */

/**
 * $ANTLR start sentence_lv1
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:67:1: sentence_lv1 returns [SentenceLvl1AST *retPtr] : simpleIdtf TRIPLESEP simpleIdtf TRIPLESEP simpleIdtf ;
 */
SentenceLvl1AST *
SCsParser::sentence_lv1()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SentenceLvl1AST * retPtr;


    /* Initialize rule variables
     */


      retPtr = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:71:5: ( simpleIdtf TRIPLESEP simpleIdtf TRIPLESEP simpleIdtf )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:71:7: simpleIdtf TRIPLESEP simpleIdtf TRIPLESEP simpleIdtf
        {
            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1200);
            simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


             this->matchToken(TRIPLESEP, &FOLLOW_TRIPLESEP_in_sentence_lv1202);
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1204);
            simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


             this->matchToken(TRIPLESEP, &FOLLOW_TRIPLESEP_in_sentence_lv1206);
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1208);
            simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesentence_lv1Ex; /* Prevent compiler warnings */
    rulesentence_lv1Ex: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retPtr;
}
/* $ANTLR end sentence_lv1 */

/**
 * $ANTLR start attrsList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:75:1: attrsList returns [AttributesListAST *retPtr] : ( simpleIdtf ATTRSEP )* ;
 */
AttributesListAST *
SCsParser::attrsList()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    AttributesListAST * retPtr;


    /* Initialize rule variables
     */


      retPtr = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:79:5: ( ( simpleIdtf ATTRSEP )* )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:79:8: ( simpleIdtf ATTRSEP )*
        {
            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:79:8: ( simpleIdtf ATTRSEP )*

            for (;;)
            {
                int alt3=2;
                switch ( this->LA(1) )
                {
                case NAME:
                	{
                		switch ( this->LA(2) )
                		{
                		case ATTRSEP:
                			{
                				alt3=1;
                			}
                		    break;

                		}

                	}
                    break;
                case URL:
                	{
                		switch ( this->LA(2) )
                		{
                		case ATTRSEP:
                			{
                				alt3=1;
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt3)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:79:9: simpleIdtf ATTRSEP
            	    {
            	        this->followPush(FOLLOW_simpleIdtf_in_attrsList237);
            	        simpleIdtf();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleattrsListEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retPtr;
            	        }


            	         this->matchToken(ATTRSEP, &FOLLOW_ATTRSEP_in_attrsList239);
            	        if  (this->hasException())
            	        {
            	            goto ruleattrsListEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retPtr;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop3;	/* break out of the loop */
            	    break;
                }
            }
            loop3: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleattrsListEx; /* Prevent compiler warnings */
    ruleattrsListEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retPtr;
}
/* $ANTLR end attrsList */

/**
 * $ANTLR start objectList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:82:1: objectList returns [ObjectListAST *retPtr] : idtfWithInt ( OBJSEP idtfWithInt )* ;
 */
ObjectListAST *
SCsParser::objectList()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    ObjectListAST * retPtr;


    /* Initialize rule variables
     */


      retPtr = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:86:5: ( idtfWithInt ( OBJSEP idtfWithInt )* )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:86:7: idtfWithInt ( OBJSEP idtfWithInt )*
        {
            this->followPush(FOLLOW_idtfWithInt_in_objectList270);
            idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleobjectListEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:86:19: ( OBJSEP idtfWithInt )*

            for (;;)
            {
                int alt4=2;
                switch ( this->LA(1) )
                {
                case OBJSEP:
                	{
                		alt4=1;
                	}
                    break;

                }

                switch (alt4)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:86:20: OBJSEP idtfWithInt
            	    {
            	         this->matchToken(OBJSEP, &FOLLOW_OBJSEP_in_objectList273);
            	        if  (this->hasException())
            	        {
            	            goto ruleobjectListEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retPtr;
            	        }


            	        this->followPush(FOLLOW_idtfWithInt_in_objectList275);
            	        idtfWithInt();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleobjectListEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retPtr;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleobjectListEx; /* Prevent compiler warnings */
    ruleobjectListEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retPtr;
}
/* $ANTLR end objectList */

/**
 * $ANTLR start intSentence
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:89:1: intSentence returns [InternalSentenceAST *retPtr] : CONNECTORS attrsList objectList ;
 */
InternalSentenceAST *
SCsParser::intSentence()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    InternalSentenceAST * retPtr;


    /* Initialize rule variables
     */


      retPtr = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:93:5: ( CONNECTORS attrsList objectList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:93:7: CONNECTORS attrsList objectList
        {
             this->matchToken(CONNECTORS, &FOLLOW_CONNECTORS_in_intSentence306);
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            this->followPush(FOLLOW_attrsList_in_intSentence308);
            attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            this->followPush(FOLLOW_objectList_in_intSentence311);
            objectList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintSentenceEx; /* Prevent compiler warnings */
    ruleintSentenceEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retPtr;
}
/* $ANTLR end intSentence */

/**
 * $ANTLR start intSentenceList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:97:1: intSentenceList returns [InternalSentenceListAST *retPtr] : LPAR_INT ( intSentence SENTSEP )+ RPAR_INT ;
 */
InternalSentenceListAST *
SCsParser::intSentenceList()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    InternalSentenceListAST * retPtr;


    /* Initialize rule variables
     */


      retPtr = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:101:5: ( LPAR_INT ( intSentence SENTSEP )+ RPAR_INT )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:101:7: LPAR_INT ( intSentence SENTSEP )+ RPAR_INT
        {
             this->matchToken(LPAR_INT, &FOLLOW_LPAR_INT_in_intSentenceList341);
            if  (this->hasException())
            {
                goto ruleintSentenceListEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:101:16: ( intSentence SENTSEP )+
            {
                int cnt5=0;

                for (;;)
                {
                    int alt5=2;
            	switch ( this->LA(1) )
            	{
            	case CONNECTORS:
            		{
            			alt5=1;
            		}
            	    break;

            	}

            	switch (alt5)
            	{
            	    case 1:
            	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:101:18: intSentence SENTSEP
            	        {
            	            this->followPush(FOLLOW_intSentence_in_intSentenceList345);
            	            intSentence();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleintSentenceListEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return retPtr;
            	            }


            	             this->matchToken(SENTSEP, &FOLLOW_SENTSEP_in_intSentenceList347);
            	            if  (this->hasException())
            	            {
            	                goto ruleintSentenceListEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return retPtr;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt5 >= 1 )
            		{
            		    goto loop5;
            		}
            		if (this->get_backtracking()>0)
            		{
            		    this->set_failedflag( true );
            		    return retPtr;
            		}

            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< SCsParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleintSentenceListEx;
            	}
            	cnt5++;
                }
                loop5: ;	/* Jump to here if this rule does not match */
            }

             this->matchToken(RPAR_INT, &FOLLOW_RPAR_INT_in_intSentenceList352);
            if  (this->hasException())
            {
                goto ruleintSentenceListEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintSentenceListEx; /* Prevent compiler warnings */
    ruleintSentenceListEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retPtr;
}
/* $ANTLR end intSentenceList */

/**
 * $ANTLR start internal
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:104:1: internal returns [InternalAST *retPtr] : intSentenceList ;
 */
InternalAST *
SCsParser::internal()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    InternalAST * retPtr;


    /* Initialize rule variables
     */


      retPtr = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:108:5: ( intSentenceList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:108:8: intSentenceList
        {
            this->followPush(FOLLOW_intSentenceList_in_internal378);
            intSentenceList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleinternalEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinternalEx; /* Prevent compiler warnings */
    ruleinternalEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retPtr;
}
/* $ANTLR end internal */

/**
 * $ANTLR start triple
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:111:1: triple returns [TripleAST *retPtr] : LPAR idtf CONTENT idtf RPAR ;
 */
TripleAST *
SCsParser::triple()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    TripleAST * retPtr;


    /* Initialize rule variables
     */


      retPtr = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:115:5: ( LPAR idtf CONTENT idtf RPAR )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:115:7: LPAR idtf CONTENT idtf RPAR
        {
             this->matchToken(LPAR, &FOLLOW_LPAR_in_triple407);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            this->followPush(FOLLOW_idtf_in_triple409);
            idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletripleEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


             this->matchToken(CONTENT, &FOLLOW_CONTENT_in_triple411);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            this->followPush(FOLLOW_idtf_in_triple413);
            idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletripleEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


             this->matchToken(RPAR, &FOLLOW_RPAR_in_triple415);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletripleEx; /* Prevent compiler warnings */
    ruletripleEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retPtr;
}
/* $ANTLR end triple */

/**
 * $ANTLR start alias
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:118:1: alias returns [AliasAST *retPtr] : ALIASNONAME ;
 */
AliasAST *
SCsParser::alias()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    AliasAST * retPtr;


    /* Initialize rule variables
     */


      retPtr = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:122:5: ( ALIASNONAME )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:122:7: ALIASNONAME
        {
             this->matchToken(ALIASNONAME, &FOLLOW_ALIASNONAME_in_alias440);
            if  (this->hasException())
            {
                goto rulealiasEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealiasEx; /* Prevent compiler warnings */
    rulealiasEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retPtr;
}
/* $ANTLR end alias */

/**
 * $ANTLR start setIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:125:1: setIdtf returns [SetIdentifierAST *retPtr] : LPAR_SET attrsList idtfWithInt ( OBJSEP attrsList idtfWithInt )* RPAR_SET ;
 */
SetIdentifierAST *
SCsParser::setIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SetIdentifierAST * retPtr;


    /* Initialize rule variables
     */


      retPtr = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:130:5: ( LPAR_SET attrsList idtfWithInt ( OBJSEP attrsList idtfWithInt )* RPAR_SET )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:130:7: LPAR_SET attrsList idtfWithInt ( OBJSEP attrsList idtfWithInt )* RPAR_SET
        {
             this->matchToken(LPAR_SET, &FOLLOW_LPAR_SET_in_setIdtf470);
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            this->followPush(FOLLOW_attrsList_in_setIdtf472);
            attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            this->followPush(FOLLOW_idtfWithInt_in_setIdtf474);
            idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:130:38: ( OBJSEP attrsList idtfWithInt )*

            for (;;)
            {
                int alt6=2;
                switch ( this->LA(1) )
                {
                case OBJSEP:
                	{
                		alt6=1;
                	}
                    break;

                }

                switch (alt6)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:130:39: OBJSEP attrsList idtfWithInt
            	    {
            	         this->matchToken(OBJSEP, &FOLLOW_OBJSEP_in_setIdtf477);
            	        if  (this->hasException())
            	        {
            	            goto rulesetIdtfEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retPtr;
            	        }


            	        this->followPush(FOLLOW_attrsList_in_setIdtf479);
            	        attrsList();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesetIdtfEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retPtr;
            	        }


            	        this->followPush(FOLLOW_idtfWithInt_in_setIdtf481);
            	        idtfWithInt();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesetIdtfEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retPtr;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop6;	/* break out of the loop */
            	    break;
                }
            }
            loop6: ; /* Jump out to here if this rule does not match */


             this->matchToken(RPAR_SET, &FOLLOW_RPAR_SET_in_setIdtf487);
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesetIdtfEx; /* Prevent compiler warnings */
    rulesetIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retPtr;
}
/* $ANTLR end setIdtf */

/**
 * $ANTLR start osetIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:134:1: osetIdtf returns [OSetIdentifierAST *retPtr] : LPAR_OSET attrsList idtfWithInt ( OBJSEP attrsList idtfWithInt )* RPAR_OSET ;
 */
OSetIdentifierAST *
SCsParser::osetIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    OSetIdentifierAST * retPtr;


    /* Initialize rule variables
     */


      retPtr = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:139:5: ( LPAR_OSET attrsList idtfWithInt ( OBJSEP attrsList idtfWithInt )* RPAR_OSET )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:139:7: LPAR_OSET attrsList idtfWithInt ( OBJSEP attrsList idtfWithInt )* RPAR_OSET
        {
             this->matchToken(LPAR_OSET, &FOLLOW_LPAR_OSET_in_osetIdtf518);
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            this->followPush(FOLLOW_attrsList_in_osetIdtf520);
            attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            this->followPush(FOLLOW_idtfWithInt_in_osetIdtf522);
            idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:139:40: ( OBJSEP attrsList idtfWithInt )*

            for (;;)
            {
                int alt7=2;
                switch ( this->LA(1) )
                {
                case OBJSEP:
                	{
                		alt7=1;
                	}
                    break;

                }

                switch (alt7)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:139:41: OBJSEP attrsList idtfWithInt
            	    {
            	         this->matchToken(OBJSEP, &FOLLOW_OBJSEP_in_osetIdtf526);
            	        if  (this->hasException())
            	        {
            	            goto ruleosetIdtfEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retPtr;
            	        }


            	        this->followPush(FOLLOW_attrsList_in_osetIdtf528);
            	        attrsList();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleosetIdtfEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retPtr;
            	        }


            	        this->followPush(FOLLOW_idtfWithInt_in_osetIdtf530);
            	        idtfWithInt();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleosetIdtfEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retPtr;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


             this->matchToken(RPAR_OSET, &FOLLOW_RPAR_OSET_in_osetIdtf535);
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleosetIdtfEx; /* Prevent compiler warnings */
    ruleosetIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retPtr;
}
/* $ANTLR end osetIdtf */

/**
 * $ANTLR start anyIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:142:1: anyIdtf returns [AnyIdentifierAST *retPtr] : ( simpleIdtf | CONTENT | triple | setIdtf | osetIdtf | alias );
 */
AnyIdentifierAST *
SCsParser::anyIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    AnyIdentifierAST * retPtr;


    /* Initialize rule variables
     */


      retPtr = NULL;


 
    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:146:5: ( simpleIdtf | CONTENT | triple | setIdtf | osetIdtf | alias )

            ANTLR_UINT32 alt8;

            alt8=6;

            switch ( this->LA(1) )
            {
            case NAME:
            case URL:
            	{
            		alt8=1;
            	}
                break;
            case CONTENT:
            	{
            		alt8=2;
            	}
                break;
            case LPAR:
            	{
            		alt8=3;
            	}
                break;
            case LPAR_SET:
            	{
            		alt8=4;
            	}
                break;
            case LPAR_OSET:
            	{
            		alt8=5;
            	}
                break;
            case ALIASNONAME:
            	{
            		alt8=6;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retPtr;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 8 );
                ex->set_state( 0 );


                goto ruleanyIdtfEx;

            }

            switch (alt8)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:147:9: simpleIdtf
        	    {
        	        this->followPush(FOLLOW_simpleIdtf_in_anyIdtf570);
        	        simpleIdtf();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:148:9: CONTENT
        	    {
        	         this->matchToken(CONTENT, &FOLLOW_CONTENT_in_anyIdtf580);
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	    }
        	    break;
        	case 3:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:149:9: triple
        	    {
        	        this->followPush(FOLLOW_triple_in_anyIdtf590);
        	        triple();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	    }
        	    break;
        	case 4:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:150:9: setIdtf
        	    {
        	        this->followPush(FOLLOW_setIdtf_in_anyIdtf600);
        	        setIdtf();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	    }
        	    break;
        	case 5:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:151:9: osetIdtf
        	    {
        	        this->followPush(FOLLOW_osetIdtf_in_anyIdtf610);
        	        osetIdtf();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	    }
        	    break;
        	case 6:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:152:9: alias
        	    {
        	        this->followPush(FOLLOW_alias_in_anyIdtf620);
        	        alias();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleanyIdtfEx; /* Prevent compiler warnings */
    ruleanyIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retPtr;
}
/* $ANTLR end anyIdtf */

/**
 * $ANTLR start idtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:156:1: idtf returns [IdentifierAST *retPtr] : anyIdtf ;
 */
IdentifierAST *
SCsParser::idtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    IdentifierAST * retPtr;


    /* Initialize rule variables
     */


      retPtr = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:160:5: ( anyIdtf )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:160:7: anyIdtf
        {
            this->followPush(FOLLOW_anyIdtf_in_idtf654);
            anyIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleidtfEx;
            }
            if (this->hasFailed())
            {
                return retPtr;
            }


            if ( this->get_backtracking()==0 )
            {
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleidtfEx; /* Prevent compiler warnings */
    ruleidtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retPtr;
}
/* $ANTLR end idtf */

/**
 * $ANTLR start simpleIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:163:1: simpleIdtf returns [SimpleIdentifierAST *retPtr] : ( NAME | URL );
 */
SimpleIdentifierAST *
SCsParser::simpleIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SimpleIdentifierAST * retPtr;


    const CommonTokenType*    NAME1;
    const CommonTokenType*    URL2;

    /* Initialize rule variables
     */


      retPtr = new SimpleIdentifierAST();

    NAME1       = NULL;
    URL2       = NULL;


 
    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:167:6: ( NAME | URL )

            ANTLR_UINT32 alt9;

            alt9=2;

            switch ( this->LA(1) )
            {
            case NAME:
            	{
            		alt9=1;
            	}
                break;
            case URL:
            	{
            		alt9=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return retPtr;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 9 );
                ex->set_state( 0 );


                goto rulesimpleIdtfEx;

            }

            switch (alt9)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:168:6: NAME
        	    {
        	        NAME1 =  this->matchToken(NAME, &FOLLOW_NAME_in_simpleIdtf683);
        	        if  (this->hasException())
        	        {
        	            goto rulesimpleIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	             retPtr->setName(QString::fromStdString((NAME1->getText())));  
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:169:6: URL
        	    {
        	        URL2 =  this->matchToken(URL, &FOLLOW_URL_in_simpleIdtf693);
        	        if  (this->hasException())
        	        {
        	            goto rulesimpleIdtfEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return retPtr;
        	        }


        	        if ( this->get_backtracking()==0 )
        	        {
        	             retPtr->setUrl(QString::fromStdString((URL2->getText())));  
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesimpleIdtfEx; /* Prevent compiler warnings */
    rulesimpleIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retPtr;
}
/* $ANTLR end simpleIdtf */

/**
 * $ANTLR start idtfWithInt
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:174:1: idtfWithInt returns [IdentifierWithInternalAST *retPrt] : idtf ( internal )? ;
 */
IdentifierWithInternalAST *
SCsParser::idtfWithInt()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    IdentifierWithInternalAST * retPrt;


    /* Initialize rule variables
     */


      //retPtr = new IdentifierWithInternalAST();


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:178:5: ( idtf ( internal )? )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:178:8: idtf ( internal )?
        {
            this->followPush(FOLLOW_idtf_in_idtfWithInt723);
            idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleidtfWithIntEx;
            }
            if (this->hasFailed())
            {
                return retPrt;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:178:13: ( internal )?
            {
                int alt10=2;
                switch ( this->LA(1) )
                {
                    case LPAR_INT:
                    	{
                    		alt10=1;
                    	}
                        break;
                }

                switch (alt10)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:178:13: internal
            	    {
            	        this->followPush(FOLLOW_internal_in_idtfWithInt725);
            	        internal();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleidtfWithIntEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return retPrt;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleidtfWithIntEx; /* Prevent compiler warnings */
    ruleidtfWithIntEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return retPrt;
}
/* $ANTLR end idtfWithInt */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

	}


/* End of code
 * =============================================================================
 */
