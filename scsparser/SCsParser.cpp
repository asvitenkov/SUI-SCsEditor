/** \file
 *  This C++ source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g
 *     -                            On : 2012-12-03 14:11:16
 *     -                for the parser : SCsParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//d
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SCsParser.hpp"
#include <QDebug>

/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

namespace 	SCsParserNS  {

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   SCsParserTokenNames[24+4]
= {
    (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
    (ANTLR_UINT8*) "<EOR>",
    (ANTLR_UINT8*) "<DOWN>",
    (ANTLR_UINT8*) "<UP>",
    (ANTLR_UINT8*) "ALIASNONAME",
    (ANTLR_UINT8*) "ATTRSEP",
    (ANTLR_UINT8*) "COMMENT",
    (ANTLR_UINT8*) "CONNECTORS",
    (ANTLR_UINT8*) "LPAR",
    (ANTLR_UINT8*) "LPAR_INT",
    (ANTLR_UINT8*) "LPAR_OSET",
    (ANTLR_UINT8*) "LPAR_SET",
    (ANTLR_UINT8*) "LPAR_TRF",
    (ANTLR_UINT8*) "NAME",
    (ANTLR_UINT8*) "OBJSEP",
    (ANTLR_UINT8*) "RPAR",
    (ANTLR_UINT8*) "RPAR_INT",
    (ANTLR_UINT8*) "RPAR_OSET",
    (ANTLR_UINT8*) "RPAR_SET",
    (ANTLR_UINT8*) "RPAR_TRF",
    (ANTLR_UINT8*) "SENTSEP",
    (ANTLR_UINT8*) "SYNSEP",
    (ANTLR_UINT8*) "TRIPLESEP",
    (ANTLR_UINT8*) "UNICODE_CHAR",
    (ANTLR_UINT8*) "URL",
    (ANTLR_UINT8*) "WS",
    (ANTLR_UINT8*) "'\\\\['",
    (ANTLR_UINT8*) "'\\\\]'"
};


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* SCsParser::getGrammarFileName()
{
    return fileName;
}
/** \brief Create a new SCsParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SCsParser::SCsParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
    // See if we can create a new parser with the standard constructor
    //
    this->init(instream);
}

/** \brief Create a new SCsParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SCsParser::SCsParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
    this->init(instream );
}

void SCsParser::init(StreamType* instream)
{
    /* Install the token table
    */
    this->get_psrstate()->set_tokenNames( SCsParserTokenNames );


}

void
SCsParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
SCsParser::~SCsParser()
{
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
    return SCsParserTokenNames;
}





/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_in_syntax86_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_in_syntax86( FOLLOW_sentence_in_syntax86_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_SENTSEP_in_syntax88_bits[]	= { ANTLR_UINT64_LIT(0x0000000001003D12) };
static  SCsParserImplTraits::BitsetListType FOLLOW_SENTSEP_in_syntax88( FOLLOW_SENTSEP_in_syntax88_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_lv1_in_sentence113_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_lv1_in_sentence113( FOLLOW_sentence_lv1_in_sentence113_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_lv23456_in_sentence117_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_lv23456_in_sentence117( FOLLOW_sentence_lv23456_in_sentence117_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_sentence_lv23456135_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_sentence_lv23456135( FOLLOW_idtf_in_sentence_lv23456135_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONNECTORS_in_sentence_lv23456137_bits[]	= { ANTLR_UINT64_LIT(0x0000000001003D10) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONNECTORS_in_sentence_lv23456137( FOLLOW_CONNECTORS_in_sentence_lv23456137_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_sentence_lv23456139_bits[]	= { ANTLR_UINT64_LIT(0x0000000001003D10) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_sentence_lv23456139( FOLLOW_attrsList_in_sentence_lv23456139_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objectList_in_sentence_lv23456141_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objectList_in_sentence_lv23456141( FOLLOW_objectList_in_sentence_lv23456141_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1159_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1159( FOLLOW_simpleIdtf_in_sentence_lv1159_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_TRIPLESEP_in_sentence_lv1161_bits[]	= { ANTLR_UINT64_LIT(0x0000000001002000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_TRIPLESEP_in_sentence_lv1161( FOLLOW_TRIPLESEP_in_sentence_lv1161_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1163_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1163( FOLLOW_simpleIdtf_in_sentence_lv1163_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_TRIPLESEP_in_sentence_lv1165_bits[]	= { ANTLR_UINT64_LIT(0x0000000001002000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_TRIPLESEP_in_sentence_lv1165( FOLLOW_TRIPLESEP_in_sentence_lv1165_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1167_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1167( FOLLOW_simpleIdtf_in_sentence_lv1167_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_attrsList188_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000020) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_attrsList188( FOLLOW_simpleIdtf_in_attrsList188_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_ATTRSEP_in_attrsList190_bits[]	= { ANTLR_UINT64_LIT(0x0000000001002002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_ATTRSEP_in_attrsList190( FOLLOW_ATTRSEP_in_attrsList190_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_objectList213_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_objectList213( FOLLOW_idtfWithInt_in_objectList213_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_OBJSEP_in_objectList216_bits[]	= { ANTLR_UINT64_LIT(0x0000000001003D10) };
static  SCsParserImplTraits::BitsetListType FOLLOW_OBJSEP_in_objectList216( FOLLOW_OBJSEP_in_objectList216_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_objectList218_bits[]	= { ANTLR_UINT64_LIT(0x0000000000004002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_objectList218( FOLLOW_idtfWithInt_in_objectList218_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONNECTORS_in_intSentence246_bits[]	= { ANTLR_UINT64_LIT(0x0000000001003D10) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONNECTORS_in_intSentence246( FOLLOW_CONNECTORS_in_intSentence246_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_intSentence248_bits[]	= { ANTLR_UINT64_LIT(0x0000000001003D10) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_intSentence248( FOLLOW_attrsList_in_intSentence248_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objectList_in_intSentence251_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objectList_in_intSentence251( FOLLOW_objectList_in_intSentence251_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_INT_in_intSentenceList269_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_INT_in_intSentenceList269( FOLLOW_LPAR_INT_in_intSentenceList269_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_intSentence_in_intSentenceList273_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_intSentence_in_intSentenceList273( FOLLOW_intSentence_in_intSentenceList273_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_SENTSEP_in_intSentenceList275_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010080) };
static  SCsParserImplTraits::BitsetListType FOLLOW_SENTSEP_in_intSentenceList275( FOLLOW_SENTSEP_in_intSentenceList275_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_INT_in_intSentenceList280_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_INT_in_intSentenceList280( FOLLOW_RPAR_INT_in_intSentenceList280_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_intSentenceList_in_internal298_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_intSentenceList_in_internal298( FOLLOW_intSentenceList_in_internal298_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_TRF_in_content330_bits[]	= { ANTLR_UINT64_LIT(0x000000000C082000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_TRF_in_content330( FOLLOW_LPAR_TRF_in_content330_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_TRF_in_content347_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_TRF_in_content347( FOLLOW_RPAR_TRF_in_content347_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_in_triple364_bits[]	= { ANTLR_UINT64_LIT(0x0000000001003D10) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_in_triple364( FOLLOW_LPAR_in_triple364_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_triple366_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_triple366( FOLLOW_idtf_in_triple366_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_content_in_triple368_bits[]	= { ANTLR_UINT64_LIT(0x0000000001003D10) };
static  SCsParserImplTraits::BitsetListType FOLLOW_content_in_triple368( FOLLOW_content_in_triple368_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_triple370_bits[]	= { ANTLR_UINT64_LIT(0x0000000000008000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_triple370( FOLLOW_idtf_in_triple370_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_in_triple372_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_in_triple372( FOLLOW_RPAR_in_triple372_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_ALIASNONAME_in_alias389_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_ALIASNONAME_in_alias389( FOLLOW_ALIASNONAME_in_alias389_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_SET_in_setIdtf406_bits[]	= { ANTLR_UINT64_LIT(0x0000000001043D10) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_SET_in_setIdtf406( FOLLOW_LPAR_SET_in_setIdtf406_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_setIdtf409_bits[]	= { ANTLR_UINT64_LIT(0x0000000001003D10) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_setIdtf409( FOLLOW_attrsList_in_setIdtf409_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_setIdtf411_bits[]	= { ANTLR_UINT64_LIT(0x0000000001047D10) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_setIdtf411( FOLLOW_idtfWithInt_in_setIdtf411_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_OBJSEP_in_setIdtf413_bits[]	= { ANTLR_UINT64_LIT(0x0000000001043D10) };
static  SCsParserImplTraits::BitsetListType FOLLOW_OBJSEP_in_setIdtf413( FOLLOW_OBJSEP_in_setIdtf413_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_SET_in_setIdtf421_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_SET_in_setIdtf421( FOLLOW_RPAR_SET_in_setIdtf421_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_OSET_in_osetIdtf439_bits[]	= { ANTLR_UINT64_LIT(0x0000000001023D10) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_OSET_in_osetIdtf439( FOLLOW_LPAR_OSET_in_osetIdtf439_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_osetIdtf443_bits[]	= { ANTLR_UINT64_LIT(0x0000000001003D10) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_osetIdtf443( FOLLOW_attrsList_in_osetIdtf443_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_osetIdtf445_bits[]	= { ANTLR_UINT64_LIT(0x0000000001027D10) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_osetIdtf445( FOLLOW_idtfWithInt_in_osetIdtf445_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_OBJSEP_in_osetIdtf447_bits[]	= { ANTLR_UINT64_LIT(0x0000000001023D10) };
static  SCsParserImplTraits::BitsetListType FOLLOW_OBJSEP_in_osetIdtf447( FOLLOW_OBJSEP_in_osetIdtf447_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_OSET_in_osetIdtf454_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_OSET_in_osetIdtf454( FOLLOW_RPAR_OSET_in_osetIdtf454_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_anyIdtf481_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_anyIdtf481( FOLLOW_simpleIdtf_in_anyIdtf481_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_content_in_anyIdtf491_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_content_in_anyIdtf491( FOLLOW_content_in_anyIdtf491_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_triple_in_anyIdtf501_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_triple_in_anyIdtf501( FOLLOW_triple_in_anyIdtf501_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_setIdtf_in_anyIdtf511_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_setIdtf_in_anyIdtf511( FOLLOW_setIdtf_in_anyIdtf511_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_osetIdtf_in_anyIdtf521_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_osetIdtf_in_anyIdtf521( FOLLOW_osetIdtf_in_anyIdtf521_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_alias_in_anyIdtf531_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_alias_in_anyIdtf531( FOLLOW_alias_in_anyIdtf531_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_anyIdtf_in_idtf557_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_anyIdtf_in_idtf557( FOLLOW_anyIdtf_in_idtf557_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_idtfWithInt594_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000202) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_idtfWithInt594( FOLLOW_idtf_in_idtfWithInt594_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_internal_in_idtfWithInt596_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_internal_in_idtfWithInt596( FOLLOW_internal_in_idtfWithInt596_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start syntax
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:59:1: syntax : ( sentence SENTSEP )* ;
 */
void
SCsParser::syntax()
{
    SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);


    /* Initialize rule variables
     */



    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:60:5: ( ( sentence SENTSEP )* )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:60:7: ( sentence SENTSEP )*
        {
            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:60:7: ( sentence SENTSEP )*

            for (;;)
            {
                int alt1=2;
                switch ( this->LA(1) )
                {
                case ALIASNONAME:
                case LPAR:
                case LPAR_OSET:
                case LPAR_SET:
                case LPAR_TRF:
                case NAME:
                case URL:
                {
                    alt1=1;
                }
                    break;

                }

                switch (alt1)
                {
                case 1:
                    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:60:9: sentence SENTSEP
                {
                    this->followPush(FOLLOW_sentence_in_syntax86);
                    sentence();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto rulesyntaxEx;
                    }


                    this->matchToken(SENTSEP, &FOLLOW_SENTSEP_in_syntax88);
                    if  (this->hasException())
                    {
                        goto rulesyntaxEx;
                    }


                }
                    break;

                default:
                    goto loop1;	/* break out of the loop */
                    break;
                }
            }
loop1: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesyntaxEx; /* Prevent compiler warnings */
rulesyntaxEx: ;


    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    return ;
}
/* $ANTLR end syntax */

/**
 * $ANTLR start sentence
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:64:1: sentence : ( sentence_lv1 | sentence_lv23456 );
 */
void
SCsParser::sentence()
{
    SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);


    /* Initialize rule variables
     */



    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:65:5: ( sentence_lv1 | sentence_lv23456 )

            ANTLR_UINT32 alt2;

            alt2=2;

            switch ( this->LA(1) )
            {
            case NAME:
            case URL:
            {
                switch ( this->LA(2) )
                {
                case TRIPLESEP:
                {
                    alt2=1;
                }
                    break;
                case CONNECTORS:
                {
                    alt2=2;
                }
                    break;

                default:
                    ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 2 );
                    ex->set_state( 1 );


                    goto rulesentenceEx;

                }

            }
                break;
            case ALIASNONAME:
            case LPAR:
            case LPAR_OSET:
            case LPAR_SET:
            case LPAR_TRF:
            {
                alt2=2;
            }
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 2 );
                ex->set_state( 0 );


                goto rulesentenceEx;

            }

            switch (alt2)
            {
            case 1:
                // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:65:7: sentence_lv1
            {
                this->followPush(FOLLOW_sentence_lv1_in_sentence113);
                sentence_lv1();

                this->followPop();
                if  (this->hasException())
                {
                    goto rulesentenceEx;
                }


            }
                break;
            case 2:
                // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:65:22: sentence_lv23456
            {
                this->followPush(FOLLOW_sentence_lv23456_in_sentence117);
                sentence_lv23456();

                this->followPop();
                if  (this->hasException())
                {
                    goto rulesentenceEx;
                }


            }
                break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesentenceEx; /* Prevent compiler warnings */
rulesentenceEx: ;


    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    return ;
}
/* $ANTLR end sentence */

/**
 * $ANTLR start sentence_lv23456
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:69:1: sentence_lv23456 : idtf CONNECTORS attrsList objectList ;
 */
void
SCsParser::sentence_lv23456()
{
    SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);


    /* Initialize rule variables
     */



    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:70:5: ( idtf CONNECTORS attrsList objectList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:70:7: idtf CONNECTORS attrsList objectList
        {
            this->followPush(FOLLOW_idtf_in_sentence_lv23456135);
            idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }


            this->matchToken(CONNECTORS, &FOLLOW_CONNECTORS_in_sentence_lv23456137);
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }


            this->followPush(FOLLOW_attrsList_in_sentence_lv23456139);
            attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }


            this->followPush(FOLLOW_objectList_in_sentence_lv23456141);
            objectList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesentence_lv23456Ex; /* Prevent compiler warnings */
rulesentence_lv23456Ex: ;


    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    return ;
}
/* $ANTLR end sentence_lv23456 */

/**
 * $ANTLR start sentence_lv1
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:74:1: sentence_lv1 : simpleIdtf TRIPLESEP simpleIdtf TRIPLESEP simpleIdtf ;
 */
void
SCsParser::sentence_lv1()
{
    SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);


    /* Initialize rule variables
     */



    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:75:5: ( simpleIdtf TRIPLESEP simpleIdtf TRIPLESEP simpleIdtf )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:75:7: simpleIdtf TRIPLESEP simpleIdtf TRIPLESEP simpleIdtf
        {
            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1159);
            simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


            this->matchToken(TRIPLESEP, &FOLLOW_TRIPLESEP_in_sentence_lv1161);
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1163);
            simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


            this->matchToken(TRIPLESEP, &FOLLOW_TRIPLESEP_in_sentence_lv1165);
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1167);
            simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesentence_lv1Ex; /* Prevent compiler warnings */
rulesentence_lv1Ex: ;


    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    return ;
}
/* $ANTLR end sentence_lv1 */

/**
 * $ANTLR start attrsList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:79:1: attrsList : ( simpleIdtf ATTRSEP )* ;
 */
void
SCsParser::attrsList()
{
    SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);


    /* Initialize rule variables
     */



    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:80:5: ( ( simpleIdtf ATTRSEP )* )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:80:8: ( simpleIdtf ATTRSEP )*
        {
            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:80:8: ( simpleIdtf ATTRSEP )*

            for (;;)
            {
                int alt3=2;
                switch ( this->LA(1) )
                {
                case NAME:
                case URL:
                {
                    switch ( this->LA(2) )
                    {
                    case ATTRSEP:
                    {
                        alt3=1;
                    }
                        break;

                    }

                }
                    break;

                }

                switch (alt3)
                {
                case 1:
                    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:80:9: simpleIdtf ATTRSEP
                {
                    this->followPush(FOLLOW_simpleIdtf_in_attrsList188);
                    simpleIdtf();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleattrsListEx;
                    }


                    this->matchToken(ATTRSEP, &FOLLOW_ATTRSEP_in_attrsList190);
                    if  (this->hasException())
                    {
                        goto ruleattrsListEx;
                    }


                }
                    break;

                default:
                    goto loop3;	/* break out of the loop */
                    break;
                }
            }
loop3: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleattrsListEx; /* Prevent compiler warnings */
ruleattrsListEx: ;


    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    return ;
}
/* $ANTLR end attrsList */

/**
 * $ANTLR start objectList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:83:1: objectList : idtfWithInt ( OBJSEP idtfWithInt )* ;
 */
void
SCsParser::objectList()
{
    SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);


    /* Initialize rule variables
     */



    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:84:5: ( idtfWithInt ( OBJSEP idtfWithInt )* )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:84:7: idtfWithInt ( OBJSEP idtfWithInt )*
        {
            this->followPush(FOLLOW_idtfWithInt_in_objectList213);
            idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleobjectListEx;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:84:19: ( OBJSEP idtfWithInt )*

            for (;;)
            {
                int alt4=2;
                switch ( this->LA(1) )
                {
                case OBJSEP:
                {
                    alt4=1;
                }
                    break;

                }

                switch (alt4)
                {
                case 1:
                    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:84:20: OBJSEP idtfWithInt
                {
                    this->matchToken(OBJSEP, &FOLLOW_OBJSEP_in_objectList216);
                    if  (this->hasException())
                    {
                        goto ruleobjectListEx;
                    }


                    this->followPush(FOLLOW_idtfWithInt_in_objectList218);
                    idtfWithInt();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleobjectListEx;
                    }


                }
                    break;

                default:
                    goto loop4;	/* break out of the loop */
                    break;
                }
            }
loop4: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleobjectListEx; /* Prevent compiler warnings */
ruleobjectListEx: ;


    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    return ;
}
/* $ANTLR end objectList */

/**
 * $ANTLR start intSentence
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:88:1: intSentence : CONNECTORS attrsList objectList ;
 */
void
SCsParser::intSentence()
{
    SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);


    /* Initialize rule variables
     */



    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:89:5: ( CONNECTORS attrsList objectList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:89:7: CONNECTORS attrsList objectList
        {
            this->matchToken(CONNECTORS, &FOLLOW_CONNECTORS_in_intSentence246);
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }


            this->followPush(FOLLOW_attrsList_in_intSentence248);
            attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }


            this->followPush(FOLLOW_objectList_in_intSentence251);
            objectList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintSentenceEx; /* Prevent compiler warnings */
ruleintSentenceEx: ;


    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    return ;
}
/* $ANTLR end intSentence */

/**
 * $ANTLR start intSentenceList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:92:1: intSentenceList : LPAR_INT ( intSentence SENTSEP )+ RPAR_INT ;
 */
void
SCsParser::intSentenceList()
{
    SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);


    /* Initialize rule variables
     */



    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:93:5: ( LPAR_INT ( intSentence SENTSEP )+ RPAR_INT )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:93:7: LPAR_INT ( intSentence SENTSEP )+ RPAR_INT
        {
            this->matchToken(LPAR_INT, &FOLLOW_LPAR_INT_in_intSentenceList269);
            if  (this->hasException())
            {
                goto ruleintSentenceListEx;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:93:16: ( intSentence SENTSEP )+
            {
                int cnt5=0;

                for (;;)
                {
                    int alt5=2;
                    switch ( this->LA(1) )
                    {
                    case CONNECTORS:
                    {
                        alt5=1;
                    }
                        break;

                    }

                    switch (alt5)
                    {
                    case 1:
                        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:93:18: intSentence SENTSEP
                    {
                        this->followPush(FOLLOW_intSentence_in_intSentenceList273);
                        intSentence();

                        this->followPop();
                        if  (this->hasException())
                        {
                            goto ruleintSentenceListEx;
                        }


                        this->matchToken(SENTSEP, &FOLLOW_SENTSEP_in_intSentenceList275);
                        if  (this->hasException())
                        {
                            goto ruleintSentenceListEx;
                        }


                    }
                        break;

                    default:

                        if ( cnt5 >= 1 )
                        {
                            goto loop5;
                        }
                        /* mismatchedSetEx()
                     */
                        new ANTLR_Exception< SCsParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


                        goto ruleintSentenceListEx;
                    }
                    cnt5++;
                }
loop5: ;	/* Jump to here if this rule does not match */
            }

            this->matchToken(RPAR_INT, &FOLLOW_RPAR_INT_in_intSentenceList280);
            if  (this->hasException())
            {
                goto ruleintSentenceListEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintSentenceListEx; /* Prevent compiler warnings */
ruleintSentenceListEx: ;


    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    return ;
}
/* $ANTLR end intSentenceList */

/**
 * $ANTLR start internal
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:96:1: internal : intSentenceList ;
 */
void
SCsParser::internal()
{
    SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);


    /* Initialize rule variables
     */



    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:97:5: ( intSentenceList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:97:8: intSentenceList
        {
            this->followPush(FOLLOW_intSentenceList_in_internal298);
            intSentenceList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleinternalEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinternalEx; /* Prevent compiler warnings */
ruleinternalEx: ;


    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    return ;
}
/* $ANTLR end internal */

/**
 * $ANTLR start content
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:102:1: content : '[' ( NAME | '\\\\[' | '\\\\]' )* ']' ;
 */
void
SCsParser::content()
{
    SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);


    /* Initialize rule variables
     */



    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:103:5: ( '[' ( NAME | '\\\\[' | '\\\\]' )* ']' )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:103:8: '[' ( NAME | '\\\\[' | '\\\\]' )* ']'
        {
            this->matchToken(LPAR_TRF, &FOLLOW_LPAR_TRF_in_content330);
            if  (this->hasException())
            {
                goto rulecontentEx;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:103:12: ( NAME | '\\\\[' | '\\\\]' )*

            for (;;)
            {
                int alt6=2;
                switch ( this->LA(1) )
                {
                case NAME:
                case 26:
                case 27:
                {
                    alt6=1;
                }
                    break;

                }

                switch (alt6)
                {
                case 1:
                    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:
                {
                    if ( this->LA(1) == NAME || ((this->LA(1) >= 26) && (this->LA(1) <= 27)) )
                    {
                        this->consume();
                        this->set_perror_recovery(false);
                    }
                    else
                    {
                        new ANTLR_Exception< SCsParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                        this->get_exception()->set_expectingSet(NULL);

                        goto rulecontentEx;
                    }


                }
                    break;

                default:
                    goto loop6;	/* break out of the loop */
                    break;
                }
            }
loop6: ; /* Jump out to here if this rule does not match */


            this->matchToken(RPAR_TRF, &FOLLOW_RPAR_TRF_in_content347);
            if  (this->hasException())
            {
                goto rulecontentEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecontentEx; /* Prevent compiler warnings */
rulecontentEx: ;


    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    return ;
}
/* $ANTLR end content */

/**
 * $ANTLR start triple
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:106:1: triple : LPAR idtf content idtf RPAR ;
 */
void
SCsParser::triple()
{
    SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);


    /* Initialize rule variables
     */



    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:107:5: ( LPAR idtf content idtf RPAR )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:107:7: LPAR idtf content idtf RPAR
        {
            this->matchToken(LPAR, &FOLLOW_LPAR_in_triple364);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


            this->followPush(FOLLOW_idtf_in_triple366);
            idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


            this->followPush(FOLLOW_content_in_triple368);
            content();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


            this->followPush(FOLLOW_idtf_in_triple370);
            idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


            this->matchToken(RPAR, &FOLLOW_RPAR_in_triple372);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletripleEx; /* Prevent compiler warnings */
ruletripleEx: ;


    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    return ;
}
/* $ANTLR end triple */

/**
 * $ANTLR start alias
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:110:1: alias : ALIASNONAME ;
 */
void
SCsParser::alias()
{
    SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);


    /* Initialize rule variables
     */



    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:111:5: ( ALIASNONAME )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:111:7: ALIASNONAME
        {
            this->matchToken(ALIASNONAME, &FOLLOW_ALIASNONAME_in_alias389);
            if  (this->hasException())
            {
                goto rulealiasEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealiasEx; /* Prevent compiler warnings */
rulealiasEx: ;


    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    return ;
}
/* $ANTLR end alias */

/**
 * $ANTLR start setIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:114:1: setIdtf : LPAR_SET ( attrsList idtfWithInt ( OBJSEP )? )* RPAR_SET ;
 */
void
SCsParser::setIdtf()
{
    SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);


    /* Initialize rule variables
     */



    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:115:5: ( LPAR_SET ( attrsList idtfWithInt ( OBJSEP )? )* RPAR_SET )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:115:7: LPAR_SET ( attrsList idtfWithInt ( OBJSEP )? )* RPAR_SET
        {
            this->matchToken(LPAR_SET, &FOLLOW_LPAR_SET_in_setIdtf406);
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:115:16: ( attrsList idtfWithInt ( OBJSEP )? )*

            for (;;)
            {
                int alt8=2;
                switch ( this->LA(1) )
                {
                case ALIASNONAME:
                case LPAR:
                case LPAR_OSET:
                case LPAR_SET:
                case LPAR_TRF:
                case NAME:
                case URL:
                {
                    alt8=1;
                }
                    break;

                }

                switch (alt8)
                {
                case 1:
                    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:115:17: attrsList idtfWithInt ( OBJSEP )?
                {
                    this->followPush(FOLLOW_attrsList_in_setIdtf409);
                    attrsList();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto rulesetIdtfEx;
                    }


                    this->followPush(FOLLOW_idtfWithInt_in_setIdtf411);
                    idtfWithInt();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto rulesetIdtfEx;
                    }


                    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:115:39: ( OBJSEP )?
                    {
                        int alt7=2;
                        switch ( this->LA(1) )
                        {
                        case OBJSEP:
                        {
                            alt7=1;
                        }
                            break;
                        }

                        switch (alt7)
                        {
                        case 1:
                            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:115:39: OBJSEP
                        {
                            this->matchToken(OBJSEP, &FOLLOW_OBJSEP_in_setIdtf413);
                            if  (this->hasException())
                            {
                                goto rulesetIdtfEx;
                            }


                        }
                            break;

                        }
                    }

                }
                    break;

                default:
                    goto loop8;	/* break out of the loop */
                    break;
                }
            }
loop8: ; /* Jump out to here if this rule does not match */


            this->matchToken(RPAR_SET, &FOLLOW_RPAR_SET_in_setIdtf421);
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesetIdtfEx; /* Prevent compiler warnings */
rulesetIdtfEx: ;


    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    return ;
}
/* $ANTLR end setIdtf */

/**
 * $ANTLR start osetIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:119:1: osetIdtf : LPAR_OSET ( attrsList idtfWithInt ( OBJSEP )? )* RPAR_OSET ;
 */
void
SCsParser::osetIdtf()
{
    SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);


    /* Initialize rule variables
     */



    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:120:5: ( LPAR_OSET ( attrsList idtfWithInt ( OBJSEP )? )* RPAR_OSET )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:120:7: LPAR_OSET ( attrsList idtfWithInt ( OBJSEP )? )* RPAR_OSET
        {
            this->matchToken(LPAR_OSET, &FOLLOW_LPAR_OSET_in_osetIdtf439);
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:120:17: ( attrsList idtfWithInt ( OBJSEP )? )*

            for (;;)
            {
                int alt10=2;
                switch ( this->LA(1) )
                {
                case ALIASNONAME:
                case LPAR:
                case LPAR_OSET:
                case LPAR_SET:
                case LPAR_TRF:
                case NAME:
                case URL:
                {
                    alt10=1;
                }
                    break;

                }

                switch (alt10)
                {
                case 1:
                    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:120:19: attrsList idtfWithInt ( OBJSEP )?
                {
                    this->followPush(FOLLOW_attrsList_in_osetIdtf443);
                    attrsList();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleosetIdtfEx;
                    }


                    this->followPush(FOLLOW_idtfWithInt_in_osetIdtf445);
                    idtfWithInt();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleosetIdtfEx;
                    }


                    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:120:41: ( OBJSEP )?
                    {
                        int alt9=2;
                        switch ( this->LA(1) )
                        {
                        case OBJSEP:
                        {
                            alt9=1;
                        }
                            break;
                        }

                        switch (alt9)
                        {
                        case 1:
                            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:120:41: OBJSEP
                        {
                            this->matchToken(OBJSEP, &FOLLOW_OBJSEP_in_osetIdtf447);
                            if  (this->hasException())
                            {
                                goto ruleosetIdtfEx;
                            }


                        }
                            break;

                        }
                    }

                }
                    break;

                default:
                    goto loop10;	/* break out of the loop */
                    break;
                }
            }
loop10: ; /* Jump out to here if this rule does not match */


            this->matchToken(RPAR_OSET, &FOLLOW_RPAR_OSET_in_osetIdtf454);
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleosetIdtfEx; /* Prevent compiler warnings */
ruleosetIdtfEx: ;


    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    return ;
}
/* $ANTLR end osetIdtf */

/**
 * $ANTLR start anyIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:123:1: anyIdtf : ( simpleIdtf | content | triple | setIdtf | osetIdtf | alias );
 */
void
SCsParser::anyIdtf()
{
    SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);


    /* Initialize rule variables
     */



    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:124:5: ( simpleIdtf | content | triple | setIdtf | osetIdtf | alias )

            ANTLR_UINT32 alt11;

            alt11=6;

            switch ( this->LA(1) )
            {
            case NAME:
            case URL:
            {
                alt11=1;
            }
                break;
            case LPAR_TRF:
            {
                alt11=2;
            }
                break;
            case LPAR:
            {
                alt11=3;
            }
                break;
            case LPAR_SET:
            {
                alt11=4;
            }
                break;
            case LPAR_OSET:
            {
                alt11=5;
            }
                break;
            case ALIASNONAME:
            {
                alt11=6;
            }
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 11 );
                ex->set_state( 0 );


                goto ruleanyIdtfEx;

            }

            switch (alt11)
            {
            case 1:
                // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:125:9: simpleIdtf
            {
                this->followPush(FOLLOW_simpleIdtf_in_anyIdtf481);
                simpleIdtf();

                this->followPop();
                if  (this->hasException())
                {
                    goto ruleanyIdtfEx;
                }


            }
                break;
            case 2:
                // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:126:9: content
            {
                this->followPush(FOLLOW_content_in_anyIdtf491);
                content();

                this->followPop();
                if  (this->hasException())
                {
                    goto ruleanyIdtfEx;
                }


            }
                break;
            case 3:
                // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:127:9: triple
            {
                this->followPush(FOLLOW_triple_in_anyIdtf501);
                triple();

                this->followPop();
                if  (this->hasException())
                {
                    goto ruleanyIdtfEx;
                }


            }
                break;
            case 4:
                // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:128:9: setIdtf
            {
                this->followPush(FOLLOW_setIdtf_in_anyIdtf511);
                setIdtf();

                this->followPop();
                if  (this->hasException())
                {
                    goto ruleanyIdtfEx;
                }


            }
                break;
            case 5:
                // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:129:9: osetIdtf
            {
                this->followPush(FOLLOW_osetIdtf_in_anyIdtf521);
                osetIdtf();

                this->followPop();
                if  (this->hasException())
                {
                    goto ruleanyIdtfEx;
                }


            }
                break;
            case 6:
                // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:130:9: alias
            {
                this->followPush(FOLLOW_alias_in_anyIdtf531);
                alias();

                this->followPop();
                if  (this->hasException())
                {
                    goto ruleanyIdtfEx;
                }


            }
                break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleanyIdtfEx; /* Prevent compiler warnings */
ruleanyIdtfEx: ;


    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    return ;
}
/* $ANTLR end anyIdtf */

/**
 * $ANTLR start idtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:134:1: idtf : anyIdtf ;
 */
void
SCsParser::idtf()
{
    SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);


    /* Initialize rule variables
     */



    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:135:5: ( anyIdtf )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:135:7: anyIdtf
        {
            this->followPush(FOLLOW_anyIdtf_in_idtf557);
            anyIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleidtfEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleidtfEx; /* Prevent compiler warnings */
ruleidtfEx: ;


    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    return ;
}
/* $ANTLR end idtf */

/**
 * $ANTLR start simpleIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:138:1: simpleIdtf : ( NAME | URL );
 */
void
SCsParser::simpleIdtf()
{
    SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);


    /* Initialize rule variables
     */



    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:138:13: ( NAME | URL )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:
        {
            if ( this->LA(1) == NAME || this->LA(1) == URL )
            {
                this->consume();
                this->set_perror_recovery(false);
            }
            else
            {
                new ANTLR_Exception< SCsParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto rulesimpleIdtfEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesimpleIdtfEx; /* Prevent compiler warnings */
rulesimpleIdtfEx: ;


    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    return ;
}
/* $ANTLR end simpleIdtf */

/**
 * $ANTLR start idtfWithInt
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:143:1: idtfWithInt : idtf ( internal )? ;
 */
void
SCsParser::idtfWithInt()
{
    SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);


    /* Initialize rule variables
     */



    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:144:5: ( idtf ( internal )? )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:144:8: idtf ( internal )?
        {
            this->followPush(FOLLOW_idtf_in_idtfWithInt594);
            idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleidtfWithIntEx;
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:144:13: ( internal )?
            {
                int alt12=2;
                switch ( this->LA(1) )
                {
                case LPAR_INT:
                {
                    alt12=1;
                }
                    break;
                }

                switch (alt12)
                {
                case 1:
                    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:144:13: internal
                {
                    this->followPush(FOLLOW_internal_in_idtfWithInt596);
                    internal();

                    this->followPop();
                    if  (this->hasException())
                    {
                        goto ruleidtfWithIntEx;
                    }


                }
                    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleidtfWithIntEx; /* Prevent compiler warnings */
ruleidtfWithIntEx: ;


    if (this->hasException())
    {
        this->preporterror();
        this->precover();
    }
    return ;
}
/* $ANTLR end idtfWithInt */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

//add
void SCsParser::displayRecognitionError(ANTLR_UINT8** tokenNames, ExceptionBaseType* ex )
{
    fprintf(stderr,"parser line:%d pos:%d\n",ex->get_line(),ex->get_charPositionInLine());
    mErrorsArray.push_back(new SCsParserNS::SCsParser::RuntimeParserError(tokenNames, ex) );
}

}


/* End of code
 * =============================================================================
 */



