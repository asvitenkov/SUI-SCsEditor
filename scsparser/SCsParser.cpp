/** \file
 *  This C++ source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g
 *     -                            On : 2013-04-08 06:21:29
 *     -                for the parser : SCsParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SCsParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

	namespace  SCsParserNS  {

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   SCsParserTokenNames[23+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "ALIASNONAME",
        (ANTLR_UINT8*) "ATTRSEP",
        (ANTLR_UINT8*) "COMMENT",
        (ANTLR_UINT8*) "CONNECTORS",
        (ANTLR_UINT8*) "CONTENT",
        (ANTLR_UINT8*) "ELEMTYPE",
        (ANTLR_UINT8*) "LPAR",
        (ANTLR_UINT8*) "LPAR_INT",
        (ANTLR_UINT8*) "LPAR_OSET",
        (ANTLR_UINT8*) "LPAR_SET",
        (ANTLR_UINT8*) "LPAR_TRF",
        (ANTLR_UINT8*) "NAME",
        (ANTLR_UINT8*) "OBJSEP",
        (ANTLR_UINT8*) "RPAR",
        (ANTLR_UINT8*) "RPAR_INT",
        (ANTLR_UINT8*) "RPAR_OSET",
        (ANTLR_UINT8*) "RPAR_SET",
        (ANTLR_UINT8*) "RPAR_TRF",
        (ANTLR_UINT8*) "SENTSEP",
        (ANTLR_UINT8*) "SYNSEP",
        (ANTLR_UINT8*) "TRIPLESEP",
        (ANTLR_UINT8*) "URL",
        (ANTLR_UINT8*) "WS"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* SCsParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new SCsParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SCsParser::SCsParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new SCsParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
SCsParser::SCsParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void SCsParser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( SCsParserTokenNames );


}

void
SCsParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
SCsParser::~SCsParser()
 {
	std::list<SCsParserNS::SCsParser::RuntimeParserError*>::iterator it;
	for(it=mErrorsArray.begin(); it!=mErrorsArray.end(); ++it)
		delete *it;
	mErrorsArray.clear();
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return SCsParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_sentsep_in_syntax108_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_sentsep_in_syntax108( FOLLOW_sentence_sentsep_in_syntax108_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_EOF_in_syntax138_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_EOF_in_syntax138( FOLLOW_EOF_in_syntax138_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_in_sentence_sentsep183_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_in_sentence_sentsep183( FOLLOW_sentence_in_sentence_sentsep183_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_SENTSEP_in_sentence_sentsep198_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_SENTSEP_in_sentence_sentsep198( FOLLOW_SENTSEP_in_sentence_sentsep198_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_lv1_in_sentence250_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_lv1_in_sentence250( FOLLOW_sentence_lv1_in_sentence250_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_sentence_lv23456_in_sentence276_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_sentence_lv23456_in_sentence276( FOLLOW_sentence_lv23456_in_sentence276_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_sentence_lv23456325_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_sentence_lv23456325( FOLLOW_idtf_in_sentence_lv23456325_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONNECTORS_in_sentence_lv23456351_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONNECTORS_in_sentence_lv23456351( FOLLOW_CONNECTORS_in_sentence_lv23456351_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_sentence_lv23456372_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_sentence_lv23456372( FOLLOW_attrsList_in_sentence_lv23456372_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objectList_in_sentence_lv23456393_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objectList_in_sentence_lv23456393( FOLLOW_objectList_in_sentence_lv23456393_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1447_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1447( FOLLOW_simpleIdtf_in_sentence_lv1447_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_TRIPLESEP_in_sentence_lv1467_bits[]	= { ANTLR_UINT64_LIT(0x0000000002008000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_TRIPLESEP_in_sentence_lv1467( FOLLOW_TRIPLESEP_in_sentence_lv1467_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1489_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1489( FOLLOW_simpleIdtf_in_sentence_lv1489_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_TRIPLESEP_in_sentence_lv1509_bits[]	= { ANTLR_UINT64_LIT(0x0000000002008000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_TRIPLESEP_in_sentence_lv1509( FOLLOW_TRIPLESEP_in_sentence_lv1509_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_sentence_lv1530_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_sentence_lv1530( FOLLOW_simpleIdtf_in_sentence_lv1530_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_attrsep_in_attrsList581_bits[]	= { ANTLR_UINT64_LIT(0x0000000002008002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_attrsep_in_attrsList581( FOLLOW_simpleIdtf_attrsep_in_attrsList581_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_simpleIdtf_attrsep632_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000020) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_simpleIdtf_attrsep632( FOLLOW_simpleIdtf_in_simpleIdtf_attrsep632_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_ATTRSEP_in_simpleIdtf_attrsep648_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_ATTRSEP_in_simpleIdtf_attrsep648( FOLLOW_ATTRSEP_in_simpleIdtf_attrsep648_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_objectList710_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_objectList710( FOLLOW_idtfWithInt_in_objectList710_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objsep_IdtfWithInt_in_objectList738_bits[]	= { ANTLR_UINT64_LIT(0x0000000000010002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objsep_IdtfWithInt_in_objectList738( FOLLOW_objsep_IdtfWithInt_in_objectList738_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_OBJSEP_in_objsep_IdtfWithInt788_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_OBJSEP_in_objsep_IdtfWithInt788( FOLLOW_OBJSEP_in_objsep_IdtfWithInt788_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_objsep_IdtfWithInt810_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_objsep_IdtfWithInt810( FOLLOW_idtfWithInt_in_objsep_IdtfWithInt810_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONNECTORS_in_intSentence864_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONNECTORS_in_intSentence864( FOLLOW_CONNECTORS_in_intSentence864_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_intSentence885_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_intSentence885( FOLLOW_attrsList_in_intSentence885_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objectList_in_intSentence907_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objectList_in_intSentence907( FOLLOW_objectList_in_intSentence907_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_INT_in_intSentenceList962_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000080) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_INT_in_intSentenceList962( FOLLOW_LPAR_INT_in_intSentenceList962_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_intSentence_sentsep_in_intSentenceList997_bits[]	= { ANTLR_UINT64_LIT(0x0000000000040080) };
static  SCsParserImplTraits::BitsetListType FOLLOW_intSentence_sentsep_in_intSentenceList997( FOLLOW_intSentence_sentsep_in_intSentenceList997_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_INT_in_intSentenceList1027_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_INT_in_intSentenceList1027( FOLLOW_RPAR_INT_in_intSentenceList1027_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_intSentence_in_intSentence_sentsep1087_bits[]	= { ANTLR_UINT64_LIT(0x0000000000400000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_intSentence_in_intSentence_sentsep1087( FOLLOW_intSentence_in_intSentence_sentsep1087_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_SENTSEP_in_intSentence_sentsep1111_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_SENTSEP_in_intSentence_sentsep1111( FOLLOW_SENTSEP_in_intSentence_sentsep1111_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_intSentenceList_in_internal1167_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_intSentenceList_in_internal1167( FOLLOW_intSentenceList_in_internal1167_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_in_triple1226_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_in_triple1226( FOLLOW_LPAR_in_triple1226_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_triple1249_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000100) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_triple1249( FOLLOW_idtf_in_triple1249_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONTENT_in_triple1271_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONTENT_in_triple1271( FOLLOW_CONTENT_in_triple1271_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_triple1291_bits[]	= { ANTLR_UINT64_LIT(0x0000000000020000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_triple1291( FOLLOW_idtf_in_triple1291_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_in_triple1313_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_in_triple1313( FOLLOW_RPAR_in_triple1313_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_ALIASNONAME_in_alias1369_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_ALIASNONAME_in_alias1369( FOLLOW_ALIASNONAME_in_alias1369_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_SET_in_setIdtf1431_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_SET_in_setIdtf1431( FOLLOW_LPAR_SET_in_setIdtf1431_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_setIdtf1478_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_setIdtf1478( FOLLOW_attrsList_in_setIdtf1478_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_setIdtf1524_bits[]	= { ANTLR_UINT64_LIT(0x0000000000110000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_setIdtf1524( FOLLOW_idtfWithInt_in_setIdtf1524_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objsep_AttrsList_idtfWithInt_in_setIdtf1569_bits[]	= { ANTLR_UINT64_LIT(0x0000000000110000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objsep_AttrsList_idtfWithInt_in_setIdtf1569( FOLLOW_objsep_AttrsList_idtfWithInt_in_setIdtf1569_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_SET_in_setIdtf1599_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_SET_in_setIdtf1599( FOLLOW_RPAR_SET_in_setIdtf1599_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_OBJSEP_in_objsep_AttrsList_idtfWithInt1668_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_OBJSEP_in_objsep_AttrsList_idtfWithInt1668( FOLLOW_OBJSEP_in_objsep_AttrsList_idtfWithInt1668_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_objsep_AttrsList_idtfWithInt1691_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_objsep_AttrsList_idtfWithInt1691( FOLLOW_attrsList_in_objsep_AttrsList_idtfWithInt1691_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_objsep_AttrsList_idtfWithInt1710_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_objsep_AttrsList_idtfWithInt1710( FOLLOW_idtfWithInt_in_objsep_AttrsList_idtfWithInt1710_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_LPAR_OSET_in_osetIdtf1768_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_LPAR_OSET_in_osetIdtf1768( FOLLOW_LPAR_OSET_in_osetIdtf1768_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_attrsList_in_osetIdtf1817_bits[]	= { ANTLR_UINT64_LIT(0x000000000200B510) };
static  SCsParserImplTraits::BitsetListType FOLLOW_attrsList_in_osetIdtf1817( FOLLOW_attrsList_in_osetIdtf1817_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtfWithInt_in_osetIdtf1866_bits[]	= { ANTLR_UINT64_LIT(0x0000000000090000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtfWithInt_in_osetIdtf1866( FOLLOW_idtfWithInt_in_osetIdtf1866_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_objsep_AttrsList_idtfWithInt_in_osetIdtf1915_bits[]	= { ANTLR_UINT64_LIT(0x0000000000090000) };
static  SCsParserImplTraits::BitsetListType FOLLOW_objsep_AttrsList_idtfWithInt_in_osetIdtf1915( FOLLOW_objsep_AttrsList_idtfWithInt_in_osetIdtf1915_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_RPAR_OSET_in_osetIdtf1950_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_RPAR_OSET_in_osetIdtf1950( FOLLOW_RPAR_OSET_in_osetIdtf1950_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_simpleIdtf_in_anyIdtf2027_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_simpleIdtf_in_anyIdtf2027( FOLLOW_simpleIdtf_in_anyIdtf2027_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_CONTENT_in_anyIdtf2046_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_CONTENT_in_anyIdtf2046( FOLLOW_CONTENT_in_anyIdtf2046_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_triple_in_anyIdtf2068_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_triple_in_anyIdtf2068( FOLLOW_triple_in_anyIdtf2068_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_setIdtf_in_anyIdtf2091_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_setIdtf_in_anyIdtf2091( FOLLOW_setIdtf_in_anyIdtf2091_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_osetIdtf_in_anyIdtf2113_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_osetIdtf_in_anyIdtf2113( FOLLOW_osetIdtf_in_anyIdtf2113_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_alias_in_anyIdtf2134_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_alias_in_anyIdtf2134( FOLLOW_alias_in_anyIdtf2134_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_anyIdtf_in_idtf2201_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_anyIdtf_in_idtf2201( FOLLOW_anyIdtf_in_idtf2201_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_NAME_in_simpleIdtf2256_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_NAME_in_simpleIdtf2256( FOLLOW_NAME_in_simpleIdtf2256_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_URL_in_simpleIdtf2272_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_URL_in_simpleIdtf2272( FOLLOW_URL_in_simpleIdtf2272_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_idtf_in_idtfWithInt2324_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000802) };
static  SCsParserImplTraits::BitsetListType FOLLOW_idtf_in_idtfWithInt2324( FOLLOW_idtf_in_idtfWithInt2324_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: SCsParser  */
static	ANTLR_BITWORD FOLLOW_internal_in_idtfWithInt2348_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  SCsParserImplTraits::BitsetListType FOLLOW_internal_in_idtfWithInt2348( FOLLOW_internal_in_idtfWithInt2348_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start syntax
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:77:1: syntax : (a= sentence_sentsep )* EOF ;
 */
void
SCsParser::syntax()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    SentenceWithSeparator* a;
    typedef	SentenceWithSeparator* RETURN_TYPE_a;

    /* Initialize rule variables
     */



    		  mNeedRecover = false;
    		  SyntaxAST* retPtr = new SyntaxAST();
    		  INIT_RULE(retPtr);
    		  mHasException = false;
    		  mLastExceptionCheked = true;
    		

 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:89:7: ( (a= sentence_sentsep )* EOF )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:90:7: (a= sentence_sentsep )* EOF
        {
            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:90:7: (a= sentence_sentsep )*

            for (;;)
            {
                int alt1=2;
                switch ( this->LA(1) )
                {
                case ALIASNONAME:
                case CONTENT:
                case LPAR:
                case LPAR_OSET:
                case LPAR_SET:
                case NAME:
                case URL:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:90:9: a= sentence_sentsep
            	    {
            	        {
            	            BNTS(a)
            	        }


            	        this->followPush(FOLLOW_sentence_sentsep_in_syntax108);
            	        a=sentence_sentsep();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesyntaxEx;
            	        }


            	        {
            	             
            	            						        if(a!=NULL)
            	            						              {
            	            						                retPtr->addSentence(a); 
            	            						                if( a->setSeparatorCheckError() == true  || mNeedRecover )
            	            						                {
            	            						                  //mNeedRecover = false;
            	            						                  this->recover();
            	            						                }
            	            						                else
            	            						                {
            	            						                  //this->recover();
            	            						                }
            	            						              }
            	            						      
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


             this->matchToken(EOF, &FOLLOW_EOF_in_syntax138);
            if  (this->hasException())
            {
                goto rulesyntaxEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesyntaxEx; /* Prevent compiler warnings */
    rulesyntaxEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }


	delete retPtr;
    return ;
}
/* $ANTLR end syntax */

/**
 * $ANTLR start sentence_sentsep
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:109:1: sentence_sentsep returns [SentenceWithSeparator* retPtr] :a= sentence b= SENTSEP ;
 */
SentenceWithSeparator*
SCsParser::sentence_sentsep()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SentenceWithSeparator* retPtr;


    const CommonTokenType*    b;
    SentenceAST* a;
    typedef	SentenceAST* RETURN_TYPE_a;

    /* Initialize rule variables
     */


    		    retPtr = new SentenceWithSeparator();
    		    INIT_RULE(retPtr);
    		
    b       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:118:5: (a= sentence b= SENTSEP )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:119:5: a= sentence b= SENTSEP
        {
            {
                BNTS(a)
            }


            this->followPush(FOLLOW_sentence_in_sentence_sentsep183);
            a=sentence();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_sentsepEx;
            }


            {
                 ANTS(a,setSentence)
            }


            {
                BTS(b) 
            }


            b =  this->matchToken(SENTSEP, &FOLLOW_SENTSEP_in_sentence_sentsep198);
            if  (this->hasException())
            {
                goto rulesentence_sentsepEx;
            }


            {
                 ATS(b,setSeparator)
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesentence_sentsepEx; /* Prevent compiler warnings */
    rulesentence_sentsepEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end sentence_sentsep */

/**
 * $ANTLR start sentence
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:123:1: sentence returns [SentenceAST* retPtr] : (a= sentence_lv1 |b= sentence_lv23456 );
 */
SentenceAST*
SCsParser::sentence()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SentenceAST* retPtr;


    SentenceLvl1AST* a;
    typedef	SentenceLvl1AST* RETURN_TYPE_a;

    SentenceLv234561AST* b;
    typedef	SentenceLv234561AST* RETURN_TYPE_b;

    /* Initialize rule variables
     */


    		  retPtr = new SentenceAST();
    		  INIT_RULE(retPtr);
    		

 
    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:132:9: (a= sentence_lv1 |b= sentence_lv23456 )

            ANTLR_UINT32 alt2;

            alt2=2;

            switch ( this->LA(1) )
            {
            case NAME:
            	{
            		switch ( this->LA(2) )
            		{
            		case TRIPLESEP:
            			{
            				alt2=1;
            			}
            		    break;
            		case CONNECTORS:
            			{
            				alt2=2;
            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 2 );
            		    ex->set_state( 1 );


            		    goto rulesentenceEx;

            		}

            	}
                break;
            case URL:
            	{
            		switch ( this->LA(2) )
            		{
            		case TRIPLESEP:
            			{
            				alt2=1;
            			}
            		    break;
            		case CONNECTORS:
            			{
            				alt2=2;
            			}
            		    break;

            		default:
            		    ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 2 );
            		    ex->set_state( 2 );


            		    goto rulesentenceEx;

            		}

            	}
                break;
            case ALIASNONAME:
            case CONTENT:
            case LPAR:
            case LPAR_OSET:
            case LPAR_SET:
            	{
            		alt2=2;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 2 );
                ex->set_state( 0 );


                goto rulesentenceEx;

            }

            switch (alt2)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:133:9: a= sentence_lv1
        	    {
        	        {
        	            BNTS(a)
        	        }


        	        this->followPush(FOLLOW_sentence_lv1_in_sentence250);
        	        a=sentence_lv1();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesentenceEx;
        	        }


        	        {
        	            ANTS(a,addSentenceLvl1)
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:134:9: b= sentence_lv23456
        	    {
        	        {
        	            BNTS(b)
        	        }


        	        this->followPush(FOLLOW_sentence_lv23456_in_sentence276);
        	        b=sentence_lv23456();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesentenceEx;
        	        }


        	        {
        	            ANTS(b,addSentenceLv234561)
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesentenceEx; /* Prevent compiler warnings */
    rulesentenceEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end sentence */

/**
 * $ANTLR start sentence_lv23456
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:138:1: sentence_lv23456 returns [SentenceLv234561AST* retPtr] :a= idtf b= CONNECTORS c= attrsList d= objectList ;
 */
SentenceLv234561AST*
SCsParser::sentence_lv23456()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SentenceLv234561AST* retPtr;


    const CommonTokenType*    b;
    IdentifierAST* a;
    typedef	IdentifierAST* RETURN_TYPE_a;

    AttributesListAST* c;
    typedef	AttributesListAST* RETURN_TYPE_c;

    ObjectListAST* d;
    typedef	ObjectListAST* RETURN_TYPE_d;

    /* Initialize rule variables
     */


    		  retPtr = new SentenceLv234561AST();
    		  INIT_RULE(retPtr);
    		
    b       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:147:5: (a= idtf b= CONNECTORS c= attrsList d= objectList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:148:5: a= idtf b= CONNECTORS c= attrsList d= objectList
        {
            {
                BNTS(a)
            }


            this->followPush(FOLLOW_idtf_in_sentence_lv23456325);
            a=idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }


            {
                 ANTS(a,setIdentifier)
            }


            {
                BTS(b) 
            }


            b =  this->matchToken(CONNECTORS, &FOLLOW_CONNECTORS_in_sentence_lv23456351);
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }


            {
                 ATS(b,setConnector)
            }


            {
                BNTS(c)
            }


            this->followPush(FOLLOW_attrsList_in_sentence_lv23456372);
            c=attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }


            {
                 ANTS(c,setAttributeList)
            }


            {
                BNTS(d)
            }


            this->followPush(FOLLOW_objectList_in_sentence_lv23456393);
            d=objectList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv23456Ex;
            }


            {
                 ANTS(d,setObjectList) 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesentence_lv23456Ex; /* Prevent compiler warnings */
    rulesentence_lv23456Ex: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end sentence_lv23456 */

/**
 * $ANTLR start sentence_lv1
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:156:1: sentence_lv1 returns [SentenceLvl1AST* retPtr] :a= simpleIdtf b= TRIPLESEP c= simpleIdtf d= TRIPLESEP e= simpleIdtf ;
 */
SentenceLvl1AST*
SCsParser::sentence_lv1()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SentenceLvl1AST* retPtr;


    const CommonTokenType*    b;
    const CommonTokenType*    d;
    SimpleIdentifierAST* a;
    typedef	SimpleIdentifierAST* RETURN_TYPE_a;

    SimpleIdentifierAST* c;
    typedef	SimpleIdentifierAST* RETURN_TYPE_c;

    SimpleIdentifierAST* e;
    typedef	SimpleIdentifierAST* RETURN_TYPE_e;

    /* Initialize rule variables
     */


    		  retPtr = new SentenceLvl1AST();
    		  INIT_RULE(retPtr);
    		
    b       = NULL;
    d       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:165:6: (a= simpleIdtf b= TRIPLESEP c= simpleIdtf d= TRIPLESEP e= simpleIdtf )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:166:6: a= simpleIdtf b= TRIPLESEP c= simpleIdtf d= TRIPLESEP e= simpleIdtf
        {
            {
                BNTS(a)
            }


            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1447);
            a=simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


            {
                 ANTS(a,setFirstIdentifier)
            }


            {
                BTS(b) 
            }


            b =  this->matchToken(TRIPLESEP, &FOLLOW_TRIPLESEP_in_sentence_lv1467);
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


            {
                 ATS(b,setFirstTripleSeparator)
            }


            {
                BNTS(c)
            }


            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1489);
            c=simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


            {
                 ANTS(c,setSecondIdentifier)
            }


            {
                BTS(d) 
            }


            d =  this->matchToken(TRIPLESEP, &FOLLOW_TRIPLESEP_in_sentence_lv1509);
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


            {
                 ATS(d,setSecondTripleSeparator)
            }


            {
                BNTS(e)
            }


            this->followPush(FOLLOW_simpleIdtf_in_sentence_lv1530);
            e=simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesentence_lv1Ex;
            }


            {
                 ANTS(e,setThirdIdentifier)
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesentence_lv1Ex; /* Prevent compiler warnings */
    rulesentence_lv1Ex: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end sentence_lv1 */

/**
 * $ANTLR start attrsList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:174:1: attrsList returns [AttributesListAST* retPtr] : (a= simpleIdtf_attrsep )* ;
 */
AttributesListAST*
SCsParser::attrsList()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    AttributesListAST* retPtr;


    SimpleIdtfrWAttrSepAST * a;
    typedef	SimpleIdtfrWAttrSepAST * RETURN_TYPE_a;

    /* Initialize rule variables
     */


    		  retPtr = new AttributesListAST();
    		  INIT_RULE(retPtr);
    		

 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:182:7: ( (a= simpleIdtf_attrsep )* )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:183:7: (a= simpleIdtf_attrsep )*
        {
            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:183:7: (a= simpleIdtf_attrsep )*

            for (;;)
            {
                int alt3=2;
                switch ( this->LA(1) )
                {
                case NAME:
                	{
                		switch ( this->LA(2) )
                		{
                		case ATTRSEP:
                			{
                				alt3=1;
                			}
                		    break;

                		}

                	}
                    break;
                case URL:
                	{
                		switch ( this->LA(2) )
                		{
                		case ATTRSEP:
                			{
                				alt3=1;
                			}
                		    break;

                		}

                	}
                    break;

                }

                switch (alt3)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:183:9: a= simpleIdtf_attrsep
            	    {
            	        {
            	            BNTS(a)
            	        }


            	        this->followPush(FOLLOW_simpleIdtf_attrsep_in_attrsList581);
            	        a=simpleIdtf_attrsep();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleattrsListEx;
            	        }


            	        {
            	            ANTS(a,addIdentifier)
            	        }


            	    }
            	    break;

            	default:
            	    goto loop3;	/* break out of the loop */
            	    break;
                }
            }
            loop3: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleattrsListEx; /* Prevent compiler warnings */
    ruleattrsListEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end attrsList */

/**
 * $ANTLR start simpleIdtf_attrsep
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:187:1: simpleIdtf_attrsep returns [SimpleIdtfrWAttrSepAST *retPtr] :a= simpleIdtf b= ATTRSEP ;
 */
SimpleIdtfrWAttrSepAST *
SCsParser::simpleIdtf_attrsep()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SimpleIdtfrWAttrSepAST * retPtr;


    const CommonTokenType*    b;
    SimpleIdentifierAST* a;
    typedef	SimpleIdentifierAST* RETURN_TYPE_a;

    /* Initialize rule variables
     */


    	    retPtr = new SimpleIdtfrWAttrSepAST();
    	    INIT_RULE(retPtr);
    	  
    b       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:195:5: (a= simpleIdtf b= ATTRSEP )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:196:5: a= simpleIdtf b= ATTRSEP
        {
            {
                BNTS(a)
            }


            this->followPush(FOLLOW_simpleIdtf_in_simpleIdtf_attrsep632);
            a=simpleIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesimpleIdtf_attrsepEx;
            }


            {
                 ANTS(a,setIdentifier)
            }


            {
                BTS(b) 
            }


            b =  this->matchToken(ATTRSEP, &FOLLOW_ATTRSEP_in_simpleIdtf_attrsep648);
            if  (this->hasException())
            {
                goto rulesimpleIdtf_attrsepEx;
            }


            {
                 ATS(b,setAttributeSeparator)
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesimpleIdtf_attrsepEx; /* Prevent compiler warnings */
    rulesimpleIdtf_attrsepEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end simpleIdtf_attrsep */

/**
 * $ANTLR start objectList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:201:1: objectList returns [ObjectListAST* retPtr] :a= idtfWithInt (b= objsep_IdtfWithInt )* ;
 */
ObjectListAST*
SCsParser::objectList()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    ObjectListAST* retPtr;


    IdentifierWithInternalAST* a;
    typedef	IdentifierWithInternalAST* RETURN_TYPE_a;

    ObjSepWIdtfWithInt* b;
    typedef	ObjSepWIdtfWithInt* RETURN_TYPE_b;

    /* Initialize rule variables
     */


    		  retPtr = new ObjectListAST();
    		  INIT_RULE(retPtr);
    		

 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:209:11: (a= idtfWithInt (b= objsep_IdtfWithInt )* )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:210:11: a= idtfWithInt (b= objsep_IdtfWithInt )*
        {
            {
                BNTS(a)
            }


            this->followPush(FOLLOW_idtfWithInt_in_objectList710);
            a=idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleobjectListEx;
            }


            {
                 ANTS(a,setIdentifierWithInt)
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:211:9: (b= objsep_IdtfWithInt )*

            for (;;)
            {
                int alt4=2;
                switch ( this->LA(1) )
                {
                case OBJSEP:
                	{
                		alt4=1;
                	}
                    break;

                }

                switch (alt4)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:211:11: b= objsep_IdtfWithInt
            	    {
            	        {
            	            BNTS(b)
            	        }


            	        this->followPush(FOLLOW_objsep_IdtfWithInt_in_objectList738);
            	        b=objsep_IdtfWithInt();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleobjectListEx;
            	        }


            	        {
            	             ANTS(b,addIdentifier)
            	        }


            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleobjectListEx; /* Prevent compiler warnings */
    ruleobjectListEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end objectList */

/**
 * $ANTLR start objsep_IdtfWithInt
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:216:1: objsep_IdtfWithInt returns [ObjSepWIdtfWithInt* retPtr] :a= OBJSEP b= idtfWithInt ;
 */
ObjSepWIdtfWithInt*
SCsParser::objsep_IdtfWithInt()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    ObjSepWIdtfWithInt* retPtr;


    const CommonTokenType*    a;
    IdentifierWithInternalAST* b;
    typedef	IdentifierWithInternalAST* RETURN_TYPE_b;

    /* Initialize rule variables
     */


    	    retPtr = new ObjSepWIdtfWithInt();
    	    INIT_RULE(retPtr);
    	  
    a       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:224:5: (a= OBJSEP b= idtfWithInt )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:225:5: a= OBJSEP b= idtfWithInt
        {
            {
                BTS(a) 
            }


            a =  this->matchToken(OBJSEP, &FOLLOW_OBJSEP_in_objsep_IdtfWithInt788);
            if  (this->hasException())
            {
                goto ruleobjsep_IdtfWithIntEx;
            }


            {
                 ATS(a,setObjectSeparator)
            }


            {
                BNTS(b)
            }


            this->followPush(FOLLOW_idtfWithInt_in_objsep_IdtfWithInt810);
            b=idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleobjsep_IdtfWithIntEx;
            }


            {
                 ANTS(b,setIdentifierWithInternal)
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleobjsep_IdtfWithIntEx; /* Prevent compiler warnings */
    ruleobjsep_IdtfWithIntEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end objsep_IdtfWithInt */

/**
 * $ANTLR start intSentence
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:230:1: intSentence returns [InternalSentenceAST* retPtr] :a= CONNECTORS b= attrsList c= objectList ;
 */
InternalSentenceAST*
SCsParser::intSentence()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    InternalSentenceAST* retPtr;


    const CommonTokenType*    a;
    AttributesListAST* b;
    typedef	AttributesListAST* RETURN_TYPE_b;

    ObjectListAST* c;
    typedef	ObjectListAST* RETURN_TYPE_c;

    /* Initialize rule variables
     */


    		  retPtr = new InternalSentenceAST();
    		  INIT_RULE(retPtr);
    		
    a       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:238:9: (a= CONNECTORS b= attrsList c= objectList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:239:9: a= CONNECTORS b= attrsList c= objectList
        {
            {
                BTS(a) 
            }


            a =  this->matchToken(CONNECTORS, &FOLLOW_CONNECTORS_in_intSentence864);
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }


            {
                 ATS(a,setConnector)
            }


            {
                BNTS(b)
            }


            this->followPush(FOLLOW_attrsList_in_intSentence885);
            b=attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }


            {
                 ANTS(b,setAttributeList)
            }


            {
                BNTS(c)
            }


            this->followPush(FOLLOW_objectList_in_intSentence907);
            c=objectList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleintSentenceEx;
            }


            {
                 ANTS(c,setObjectList)
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintSentenceEx; /* Prevent compiler warnings */
    ruleintSentenceEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end intSentence */

/**
 * $ANTLR start intSentenceList
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:245:1: intSentenceList returns [InternalSentenceListAST* retPtr] :a= LPAR_INT (b= intSentence_sentsep )+ c= RPAR_INT ;
 */
InternalSentenceListAST*
SCsParser::intSentenceList()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    InternalSentenceListAST* retPtr;


    const CommonTokenType*    a;
    const CommonTokenType*    c;
    IntSentenceWSentSep* b;
    typedef	IntSentenceWSentSep* RETURN_TYPE_b;

    /* Initialize rule variables
     */


    		  retPtr = new InternalSentenceListAST();
    		  INIT_RULE(retPtr);
    		
    a       = NULL;
    c       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:253:11: (a= LPAR_INT (b= intSentence_sentsep )+ c= RPAR_INT )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:254:11: a= LPAR_INT (b= intSentence_sentsep )+ c= RPAR_INT
        {
            {
                BTS(a) 
            }


            a =  this->matchToken(LPAR_INT, &FOLLOW_LPAR_INT_in_intSentenceList962);
            if  (this->hasException())
            {
                goto ruleintSentenceListEx;
            }


            {
                 ATS(a,setLeftInternalSeparator)
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:255:9: (b= intSentence_sentsep )+
            {
                int cnt5=0;

                for (;;)
                {
                    int alt5=2;
            	switch ( this->LA(1) )
            	{
            	case CONNECTORS:
            		{
            			alt5=1;
            		}
            	    break;

            	}

            	switch (alt5)
            	{
            	    case 1:
            	        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:255:11: b= intSentence_sentsep
            	        {
            	            {
            	                BNTS(b)
            	            }


            	            this->followPush(FOLLOW_intSentence_sentsep_in_intSentenceList997);
            	            b=intSentence_sentsep();

            	            this->followPop();
            	            if  (this->hasException())
            	            {
            	                goto ruleintSentenceListEx;
            	            }


            	            {
            	                 ANTS(b,addSentence)
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt5 >= 1 )
            		{
            		    goto loop5;
            		}
            		/* mismatchedSetEx()
            		 */
            		new ANTLR_Exception< SCsParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


            		goto ruleintSentenceListEx;
            	}
            	cnt5++;
                }
                loop5: ;	/* Jump to here if this rule does not match */
            }

            {
                BTS(c) 
            }


            c =  this->matchToken(RPAR_INT, &FOLLOW_RPAR_INT_in_intSentenceList1027);
            if  (this->hasException())
            {
                goto ruleintSentenceListEx;
            }


            {
                 ATS(c,setRigthInternalSeparator)
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintSentenceListEx; /* Prevent compiler warnings */
    ruleintSentenceListEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end intSentenceList */

/**
 * $ANTLR start intSentence_sentsep
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:259:1: intSentence_sentsep returns [IntSentenceWSentSep* retPtr] :a= intSentence b= SENTSEP ;
 */
IntSentenceWSentSep*
SCsParser::intSentence_sentsep()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    IntSentenceWSentSep* retPtr;


    const CommonTokenType*    b;
    InternalSentenceAST* a;
    typedef	InternalSentenceAST* RETURN_TYPE_a;

    /* Initialize rule variables
     */


    		  retPtr = new IntSentenceWSentSep();
    		  INIT_RULE(retPtr);
    		
    b       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:267:5: (a= intSentence b= SENTSEP )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:268:5: a= intSentence b= SENTSEP
        {
            {
                BNTS(a)
            }


            this->followPush(FOLLOW_intSentence_in_intSentence_sentsep1087);
            a=intSentence();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleintSentence_sentsepEx;
            }


            {
                 ANTS(a,setInternalSentence)
            }


            {
                BTS(b) 
            }


            b =  this->matchToken(SENTSEP, &FOLLOW_SENTSEP_in_intSentence_sentsep1111);
            if  (this->hasException())
            {
                goto ruleintSentence_sentsepEx;
            }


            {
                 ATS(b,setSentenceSeparator)
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleintSentence_sentsepEx; /* Prevent compiler warnings */
    ruleintSentence_sentsepEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end intSentence_sentsep */

/**
 * $ANTLR start internal
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:272:1: internal returns [InternalAST* retPtr] :a= intSentenceList ;
 */
InternalAST*
SCsParser::internal()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    InternalAST* retPtr;


    InternalSentenceListAST* a;
    typedef	InternalSentenceListAST* RETURN_TYPE_a;

    /* Initialize rule variables
     */


    		  retPtr = new InternalAST();
    		  INIT_RULE(retPtr);
    		

 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:280:4: (a= intSentenceList )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:281:4: a= intSentenceList
        {
            {
                BNTS(a)
            }


            this->followPush(FOLLOW_intSentenceList_in_internal1167);
            a=intSentenceList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleinternalEx;
            }


            {
                 ANTS(a,setInternalSentenceList)
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleinternalEx; /* Prevent compiler warnings */
    ruleinternalEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end internal */

/**
 * $ANTLR start triple
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:284:1: triple returns [TripleAST* retPtr] :a= LPAR b= idtf c= CONTENT d= idtf e= RPAR ;
 */
TripleAST*
SCsParser::triple()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    TripleAST* retPtr;


    const CommonTokenType*    a;
    const CommonTokenType*    c;
    const CommonTokenType*    e;
    IdentifierAST* b;
    typedef	IdentifierAST* RETURN_TYPE_b;

    IdentifierAST* d;
    typedef	IdentifierAST* RETURN_TYPE_d;

    /* Initialize rule variables
     */


          retPtr = new TripleAST();
          INIT_RULE(retPtr);
        
    a       = NULL;
    c       = NULL;
    e       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:292:7: (a= LPAR b= idtf c= CONTENT d= idtf e= RPAR )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:293:7: a= LPAR b= idtf c= CONTENT d= idtf e= RPAR
        {
            {
                BTS(a) 
            }


            a =  this->matchToken(LPAR, &FOLLOW_LPAR_in_triple1226);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


            {
                 ATS(a,setLeftPar)
            }


            {
                BNTS(b)
            }


            this->followPush(FOLLOW_idtf_in_triple1249);
            b=idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


            {
                 ANTS(b,setFirstIdentifier)
            }


            {
                BTS(c) 
            }


            c =  this->matchToken(CONTENT, &FOLLOW_CONTENT_in_triple1271);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


            {
                 ATS(c,setContent)
            }


            {
                BNTS(d)
            }


            this->followPush(FOLLOW_idtf_in_triple1291);
            d=idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


            {
                 ANTS(d,setSecondIdentifier)
            }


            {
                BTS(e) 
            }


            e =  this->matchToken(RPAR, &FOLLOW_RPAR_in_triple1313);
            if  (this->hasException())
            {
                goto ruletripleEx;
            }


            {
                 ATS(e,setRighPar)
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruletripleEx; /* Prevent compiler warnings */
    ruletripleEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end triple */

/**
 * $ANTLR start alias
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:300:1: alias returns [AliasAST* retPtr] :a= ALIASNONAME ;
 */
AliasAST*
SCsParser::alias()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    AliasAST* retPtr;


    const CommonTokenType*    a;

    /* Initialize rule variables
     */


    		  retPtr = new AliasAST();
    		  INIT_RULE(retPtr);
    		
    a       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:309:7: (a= ALIASNONAME )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:310:7: a= ALIASNONAME
        {
            {
                BTS(a) 
            }


            a =  this->matchToken(ALIASNONAME, &FOLLOW_ALIASNONAME_in_alias1369);
            if  (this->hasException())
            {
                goto rulealiasEx;
            }


            {
                 ATS(a,setAlias)
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulealiasEx; /* Prevent compiler warnings */
    rulealiasEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end alias */

/**
 * $ANTLR start setIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:314:1: setIdtf returns [SetIdentifierAST* retPtr] :a= LPAR_SET b= attrsList c= idtfWithInt (d= objsep_AttrsList_idtfWithInt )* e= RPAR_SET ;
 */
SetIdentifierAST*
SCsParser::setIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SetIdentifierAST* retPtr;


    const CommonTokenType*    a;
    const CommonTokenType*    e;
    AttributesListAST* b;
    typedef	AttributesListAST* RETURN_TYPE_b;

    IdentifierWithInternalAST* c;
    typedef	IdentifierWithInternalAST* RETURN_TYPE_c;

    ObjSepWAttrListWIdtfWithInt* d;
    typedef	ObjSepWAttrListWIdtfWithInt* RETURN_TYPE_d;

    /* Initialize rule variables
     */


    		  retPtr = new SetIdentifierAST();
    		  INIT_RULE(retPtr);
    		
    a       = NULL;
    e       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:322:9: (a= LPAR_SET b= attrsList c= idtfWithInt (d= objsep_AttrsList_idtfWithInt )* e= RPAR_SET )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:323:9: a= LPAR_SET b= attrsList c= idtfWithInt (d= objsep_AttrsList_idtfWithInt )* e= RPAR_SET
        {
            {
                BTS(a) 
            }


            a =  this->matchToken(LPAR_SET, &FOLLOW_LPAR_SET_in_setIdtf1431);
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }


            {
                 ATS(a,setLeftSeparator) 
            }


            {
                BNTS(b)
            }


            this->followPush(FOLLOW_attrsList_in_setIdtf1478);
            b=attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }


            {
                 ANTS(b,setAttributeList) 
            }


            {
                BNTS(c)
            }


            this->followPush(FOLLOW_idtfWithInt_in_setIdtf1524);
            c=idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }


            {
                 ANTS(c,setIdentifier) 
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:326:7: (d= objsep_AttrsList_idtfWithInt )*

            for (;;)
            {
                int alt6=2;
                switch ( this->LA(1) )
                {
                case OBJSEP:
                	{
                		alt6=1;
                	}
                    break;

                }

                switch (alt6)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:326:9: d= objsep_AttrsList_idtfWithInt
            	    {
            	        {
            	            BNTS(d)
            	        }


            	        this->followPush(FOLLOW_objsep_AttrsList_idtfWithInt_in_setIdtf1569);
            	        d=objsep_AttrsList_idtfWithInt();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulesetIdtfEx;
            	        }


            	        {
            	             ANTS(d,addSentence) 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop6;	/* break out of the loop */
            	    break;
                }
            }
            loop6: ; /* Jump out to here if this rule does not match */


            {
                BTS(e) 
            }


            e =  this->matchToken(RPAR_SET, &FOLLOW_RPAR_SET_in_setIdtf1599);
            if  (this->hasException())
            {
                goto rulesetIdtfEx;
            }


            {
                 ATS(e,setRightSeparator)
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulesetIdtfEx; /* Prevent compiler warnings */
    rulesetIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end setIdtf */

/**
 * $ANTLR start objsep_AttrsList_idtfWithInt
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:330:1: objsep_AttrsList_idtfWithInt returns [ObjSepWAttrListWIdtfWithInt* retPtr] :a= OBJSEP b= attrsList c= idtfWithInt ;
 */
ObjSepWAttrListWIdtfWithInt*
SCsParser::objsep_AttrsList_idtfWithInt()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    ObjSepWAttrListWIdtfWithInt* retPtr;


    const CommonTokenType*    a;
    AttributesListAST* b;
    typedef	AttributesListAST* RETURN_TYPE_b;

    IdentifierWithInternalAST* c;
    typedef	IdentifierWithInternalAST* RETURN_TYPE_c;

    /* Initialize rule variables
     */


    		  retPtr = new ObjSepWAttrListWIdtfWithInt();
    		  INIT_RULE(retPtr);
    		
    a       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:338:4: (a= OBJSEP b= attrsList c= idtfWithInt )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:339:4: a= OBJSEP b= attrsList c= idtfWithInt
        {
            {
                BTS(a) 
            }


            a =  this->matchToken(OBJSEP, &FOLLOW_OBJSEP_in_objsep_AttrsList_idtfWithInt1668);
            if  (this->hasException())
            {
                goto ruleobjsep_AttrsList_idtfWithIntEx;
            }


            {
                 ATS(a,setSeparator)
            }


            {
                BNTS(b)
            }


            this->followPush(FOLLOW_attrsList_in_objsep_AttrsList_idtfWithInt1691);
            b=attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleobjsep_AttrsList_idtfWithIntEx;
            }


            {
                 ANTS(b,setAttributeList)
            }


            {
                BNTS(c)
            }


            this->followPush(FOLLOW_idtfWithInt_in_objsep_AttrsList_idtfWithInt1710);
            c=idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleobjsep_AttrsList_idtfWithIntEx;
            }


            {
                 ANTS(c,setIdentifier)
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleobjsep_AttrsList_idtfWithIntEx; /* Prevent compiler warnings */
    ruleobjsep_AttrsList_idtfWithIntEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end objsep_AttrsList_idtfWithInt */

/**
 * $ANTLR start osetIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:345:1: osetIdtf returns [OSetIdentifierAST* retPtr] :a= LPAR_OSET b= attrsList c= idtfWithInt (d= objsep_AttrsList_idtfWithInt )* e= RPAR_OSET ;
 */
OSetIdentifierAST*
SCsParser::osetIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    OSetIdentifierAST* retPtr;


    const CommonTokenType*    a;
    const CommonTokenType*    e;
    AttributesListAST* b;
    typedef	AttributesListAST* RETURN_TYPE_b;

    IdentifierWithInternalAST* c;
    typedef	IdentifierWithInternalAST* RETURN_TYPE_c;

    ObjSepWAttrListWIdtfWithInt* d;
    typedef	ObjSepWAttrListWIdtfWithInt* RETURN_TYPE_d;

    /* Initialize rule variables
     */


    		  retPtr = new OSetIdentifierAST();
    		  INIT_RULE(retPtr);
    		
    a       = NULL;
    e       = NULL;


 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:353:9: (a= LPAR_OSET b= attrsList c= idtfWithInt (d= objsep_AttrsList_idtfWithInt )* e= RPAR_OSET )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:354:9: a= LPAR_OSET b= attrsList c= idtfWithInt (d= objsep_AttrsList_idtfWithInt )* e= RPAR_OSET
        {
            {
                BTS(a) 
            }


            a =  this->matchToken(LPAR_OSET, &FOLLOW_LPAR_OSET_in_osetIdtf1768);
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }


            {
                 ATS(a,setLeftSeparator)   
            }


            {
                BNTS(b)
            }


            this->followPush(FOLLOW_attrsList_in_osetIdtf1817);
            b=attrsList();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }


            {
                 ANTS(b,setAttributeList)  
            }


            {
                BNTS(c)
            }


            this->followPush(FOLLOW_idtfWithInt_in_osetIdtf1866);
            c=idtfWithInt();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }


            {
                 ANTS(c,setIdentifier)      
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:357:7: (d= objsep_AttrsList_idtfWithInt )*

            for (;;)
            {
                int alt7=2;
                switch ( this->LA(1) )
                {
                case OBJSEP:
                	{
                		alt7=1;
                	}
                    break;

                }

                switch (alt7)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:357:9: d= objsep_AttrsList_idtfWithInt
            	    {
            	        {
            	            BNTS(d)
            	        }


            	        this->followPush(FOLLOW_objsep_AttrsList_idtfWithInt_in_osetIdtf1915);
            	        d=objsep_AttrsList_idtfWithInt();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleosetIdtfEx;
            	        }


            	        {
            	             ANTS(d,addSentence)    
            	        }


            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


            {
                BTS(e) 
            }


            e =  this->matchToken(RPAR_OSET, &FOLLOW_RPAR_OSET_in_osetIdtf1950);
            if  (this->hasException())
            {
                goto ruleosetIdtfEx;
            }


            {
                 ATS(e,setRightSeparator)               
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleosetIdtfEx; /* Prevent compiler warnings */
    ruleosetIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end osetIdtf */

/**
 * $ANTLR start anyIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:361:1: anyIdtf returns [AnyIdentifierAST* retPtr] : (a= simpleIdtf |b= CONTENT |c= triple |d= setIdtf |e= osetIdtf |f= alias );
 */
AnyIdentifierAST*
SCsParser::anyIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    AnyIdentifierAST* retPtr;


    const CommonTokenType*    b;
    SimpleIdentifierAST* a;
    typedef	SimpleIdentifierAST* RETURN_TYPE_a;

    TripleAST* c;
    typedef	TripleAST* RETURN_TYPE_c;

    SetIdentifierAST* d;
    typedef	SetIdentifierAST* RETURN_TYPE_d;

    OSetIdentifierAST* e;
    typedef	OSetIdentifierAST* RETURN_TYPE_e;

    AliasAST* f;
    typedef	AliasAST* RETURN_TYPE_f;

    /* Initialize rule variables
     */


    		  retPtr = new AnyIdentifierAST();
    		  INIT_RULE(retPtr);
    		
    b       = NULL;


 
    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:368:5: (a= simpleIdtf |b= CONTENT |c= triple |d= setIdtf |e= osetIdtf |f= alias )

            ANTLR_UINT32 alt8;

            alt8=6;

            switch ( this->LA(1) )
            {
            case NAME:
            case URL:
            	{
            		alt8=1;
            	}
                break;
            case CONTENT:
            	{
            		alt8=2;
            	}
                break;
            case LPAR:
            	{
            		alt8=3;
            	}
                break;
            case LPAR_SET:
            	{
            		alt8=4;
            	}
                break;
            case LPAR_OSET:
            	{
            		alt8=5;
            	}
                break;
            case ALIASNONAME:
            	{
            		alt8=6;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 8 );
                ex->set_state( 0 );


                goto ruleanyIdtfEx;

            }

            switch (alt8)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:369:9: a= simpleIdtf
        	    {
        	        {
        	            BNTS(a)
        	        }


        	        this->followPush(FOLLOW_simpleIdtf_in_anyIdtf2027);
        	        a=simpleIdtf();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }


        	        {
        	             ANTS(a,setSimpleIdentifier) 
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:370:9: b= CONTENT
        	    {
        	        {
        	            BTS(b) 
        	        }


        	        b =  this->matchToken(CONTENT, &FOLLOW_CONTENT_in_anyIdtf2046);
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }


        	        {
        	             ATS(b,setContent)           
        	        }


        	    }
        	    break;
        	case 3:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:371:9: c= triple
        	    {
        	        {
        	            BNTS(c)
        	        }


        	        this->followPush(FOLLOW_triple_in_anyIdtf2068);
        	        c=triple();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }


        	        {
        	             ANTS(c,setTriple)           
        	        }


        	    }
        	    break;
        	case 4:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:372:9: d= setIdtf
        	    {
        	        {
        	            BNTS(d)
        	        }


        	        this->followPush(FOLLOW_setIdtf_in_anyIdtf2091);
        	        d=setIdtf();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }


        	        {
        	             ANTS(d,setSetIdentifier)    
        	        }


        	    }
        	    break;
        	case 5:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:373:9: e= osetIdtf
        	    {
        	        {
        	            BNTS(e)
        	        }


        	        this->followPush(FOLLOW_osetIdtf_in_anyIdtf2113);
        	        e=osetIdtf();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }


        	        {
        	             ANTS(e,setOSetIdentifier)   
        	        }


        	    }
        	    break;
        	case 6:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:374:9: f= alias
        	    {
        	        {
        	            BNTS(f)
        	        }


        	        this->followPush(FOLLOW_alias_in_anyIdtf2134);
        	        f=alias();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleanyIdtfEx;
        	        }


        	        {
        	             ANTS(f,setAlias)            
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleanyIdtfEx; /* Prevent compiler warnings */
    ruleanyIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end anyIdtf */

/**
 * $ANTLR start idtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:379:1: idtf returns [IdentifierAST* retPtr] :a= anyIdtf ;
 */
IdentifierAST*
SCsParser::idtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    IdentifierAST* retPtr;


    AnyIdentifierAST* a;
    typedef	AnyIdentifierAST* RETURN_TYPE_a;

    /* Initialize rule variables
     */


    			  retPtr = new IdentifierAST();
    			  INIT_RULE(retPtr);
    			

 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:386:5: (a= anyIdtf )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:387:5: a= anyIdtf
        {
            {
                BNTS(a)
            }


            this->followPush(FOLLOW_anyIdtf_in_idtf2201);
            a=anyIdtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleidtfEx;
            }


            {
                 ANTS(a,setIdentifier) 
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleidtfEx; /* Prevent compiler warnings */
    ruleidtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end idtf */

/**
 * $ANTLR start simpleIdtf
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:390:1: simpleIdtf returns [SimpleIdentifierAST* retPtr] : (a= NAME |b= URL );
 */
SimpleIdentifierAST*
SCsParser::simpleIdtf()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    SimpleIdentifierAST* retPtr;


    const CommonTokenType*    a;
    const CommonTokenType*    b;

    /* Initialize rule variables
     */


    			  retPtr = new SimpleIdentifierAST();
    			  INIT_RULE(retPtr);
    			
    a       = NULL;
    b       = NULL;


 
    {
        {
            //  D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:399:6: (a= NAME |b= URL )

            ANTLR_UINT32 alt9;

            alt9=2;

            switch ( this->LA(1) )
            {
            case NAME:
            	{
            		alt9=1;
            	}
                break;
            case URL:
            	{
            		alt9=2;
            	}
                break;

            default:
                ExceptionBaseType* ex = new ANTLR_Exception< SCsParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 9 );
                ex->set_state( 0 );


                goto rulesimpleIdtfEx;

            }

            switch (alt9)
            {
        	case 1:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:400:6: a= NAME
        	    {
        	        {
        	            BTS(a) 
        	        }


        	        a =  this->matchToken(NAME, &FOLLOW_NAME_in_simpleIdtf2256);
        	        if  (this->hasException())
        	        {
        	            goto rulesimpleIdtfEx;
        	        }


        	        {
        	              ATS(a,setName)  
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:401:6: b= URL
        	    {
        	        {
        	            BTS(b) 
        	        }


        	        b =  this->matchToken(URL, &FOLLOW_URL_in_simpleIdtf2272);
        	        if  (this->hasException())
        	        {
        	            goto rulesimpleIdtfEx;
        	        }


        	        {
        	              ATS(b,setUrl)   
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulesimpleIdtfEx; /* Prevent compiler warnings */
    rulesimpleIdtfEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end simpleIdtf */

/**
 * $ANTLR start idtfWithInt
 * D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:406:1: idtfWithInt returns [IdentifierWithInternalAST* retPtr] :a= idtf (b= internal )? ;
 */
IdentifierWithInternalAST*
SCsParser::idtfWithInt()
{
        SCsParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      
    IdentifierWithInternalAST* retPtr;


    IdentifierAST* a;
    typedef	IdentifierAST* RETURN_TYPE_a;

    InternalAST* b;
    typedef	InternalAST* RETURN_TYPE_b;

    /* Initialize rule variables
     */


    	  retPtr = new IdentifierWithInternalAST();
    	  INIT_RULE(retPtr);
    	

 
    {
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:414:7: (a= idtf (b= internal )? )
        // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:415:7: a= idtf (b= internal )?
        {
            {
                BNTS(a)
            }


            this->followPush(FOLLOW_idtf_in_idtfWithInt2324);
            a=idtf();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleidtfWithIntEx;
            }


            {
                 ANTS(a,setIdentifier)   
            }


            // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:416:5: (b= internal )?
            {
                int alt10=2;
                switch ( this->LA(1) )
                {
                    case LPAR_INT:
                    	{
                    		alt10=1;
                    	}
                        break;
                }

                switch (alt10)
                {
            	case 1:
            	    // D:\\Programming\\PROJECTS\\Eclipse\\workspace\\ScsGrammar\\src\\SCs.g:416:7: b= internal
            	    {
            	        {
            	            BNTS(b)
            	        }


            	        this->followPush(FOLLOW_internal_in_idtfWithInt2348);
            	        b=internal();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleidtfWithIntEx;
            	        }


            	        {
            	             ANTS(b,setInternal)     
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleidtfWithIntEx; /* Prevent compiler warnings */
    ruleidtfWithIntEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
        else
        {
            {
                 CODE_AFTER_RULE 
            }
        }

    return retPtr;
}
/* $ANTLR end idtfWithInt */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

	}


/* End of code
 * =============================================================================
 */
